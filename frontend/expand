#![feature(prelude_import)]
#![forbid(unsafe_code)]
#![warn(missing_docs, clippy::missing_docs_in_private_items)]
//! Main dashboard console for Patr
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
/// Prelude module. Used to re-export commonly used items.
pub mod prelude {
    /// The global Portal ID for creating any portals
    pub struct PortalId;
    pub use leptos::*;
    pub use log::{debug, error, info, trace, warn};
    pub use crate::{components::*, pages::*, utils::*};
}
use leptos_declarative::prelude::*;
use prelude::*;
mod app {
    use leptos_router::{
        use_location, Outlet, ProtectedRoute, Redirect, Route, Router, Routes,
    };
    use leptos_use::storage::use_local_storage;
    use crate::prelude::*;
    /**Serialized arguments for the [`test`] server function.

*/
    pub struct Test {
        pub name: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Test {
        #[inline]
        fn clone(&self) -> Test {
            Test {
                name: ::core::clone::Clone::clone(&self.name),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Test {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Test",
                "name",
                &&self.name,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Test {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Test",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Test {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Test>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Test;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Test",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Test with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Test { name: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        _serde::__private::Ok(Test { name: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["name"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Test",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Test>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Test {
        const URL: &str = if "".is_empty() {
            ::const_format::pmr::__AssertStr {
                x: {
                    use ::const_format::__cf_osRcTFl4A;
                    ({
                        #[doc(hidden)]
                        #[allow(unused_mut, non_snake_case)]
                        const CONCATP_NHPMWYD3NJA: &[__cf_osRcTFl4A::pmr::PArgument] = {
                            let fmt = __cf_osRcTFl4A::pmr::FormattingFlags::NEW;
                            &[
                                __cf_osRcTFl4A::pmr::PConvWrapper("test")
                                    .to_pargument_display(fmt),
                                __cf_osRcTFl4A::pmr::PConvWrapper(
                                        ::leptos::server_fn::xxhash_rust::const_xxh64::xxh64(
                                            "/home/rakshith/Projects/bytesonus/api/frontend:frontend/src/app.rs:14:1"
                                                .as_bytes(),
                                            0,
                                        ),
                                    )
                                    .to_pargument_display(fmt),
                            ]
                        };
                        {
                            #[doc(hidden)]
                            const ARR_LEN: usize = ::const_format::pmr::PArgument::calc_len(
                                CONCATP_NHPMWYD3NJA,
                            );
                            #[doc(hidden)]
                            const CONCAT_ARR: &::const_format::pmr::LenAndArray<
                                [u8; ARR_LEN],
                            > = {
                                use ::const_format::{__write_pvariant, pmr::PVariant};
                                let mut out = ::const_format::pmr::LenAndArray {
                                    len: 0,
                                    array: [0u8; ARR_LEN],
                                };
                                let input = CONCATP_NHPMWYD3NJA;
                                {
                                    let ::const_format::pmr::Range {
                                        start: mut outer_i,
                                        end,
                                    } = 0..input.len();
                                    while outer_i < end {
                                        {
                                            let current = &input[outer_i];
                                            match current.elem {
                                                PVariant::Str(s) => {
                                                    let str = s.as_bytes();
                                                    let is_display = current.fmt.is_display();
                                                    let mut i = 0;
                                                    if is_display {
                                                        while i < str.len() {
                                                            out.array[out.len] = str[i];
                                                            out.len += 1;
                                                            i += 1;
                                                        }
                                                    } else {
                                                        out.array[out.len] = b'"';
                                                        out.len += 1;
                                                        while i < str.len() {
                                                            use ::const_format::pmr::{
                                                                hex_as_ascii, ForEscaping, FOR_ESCAPING,
                                                            };
                                                            let c = str[i];
                                                            let mut written_c = c;
                                                            if c < 128 {
                                                                let shifted = 1 << c;
                                                                if (FOR_ESCAPING.is_escaped & shifted) != 0 {
                                                                    out.array[out.len] = b'\\';
                                                                    out.len += 1;
                                                                    if (FOR_ESCAPING.is_backslash_escaped & shifted) == 0 {
                                                                        out.array[out.len] = b'x';
                                                                        out
                                                                            .array[out.len
                                                                            + 1] = hex_as_ascii(
                                                                            c >> 4,
                                                                            ::const_format::pmr::HexFormatting::Upper,
                                                                        );
                                                                        out.len += 2;
                                                                        written_c = hex_as_ascii(
                                                                            c & 0b1111,
                                                                            ::const_format::pmr::HexFormatting::Upper,
                                                                        );
                                                                    } else {
                                                                        written_c = ForEscaping::get_backslash_escape(c);
                                                                    };
                                                                }
                                                            }
                                                            out.array[out.len] = written_c;
                                                            out.len += 1;
                                                            i += 1;
                                                        }
                                                        out.array[out.len] = b'"';
                                                        out.len += 1;
                                                    }
                                                }
                                                PVariant::Int(int) => {
                                                    let wrapper = ::const_format::pmr::PWrapper(int);
                                                    let debug_display;
                                                    let bin;
                                                    let hex;
                                                    let sa: &::const_format::pmr::StartAndArray<[_]> = match current
                                                        .fmt
                                                    {
                                                        ::const_format::pmr::Formatting::Display => {
                                                            debug_display = wrapper.to_start_array_display();
                                                            &debug_display
                                                        }
                                                        ::const_format::pmr::Formatting::Debug => {
                                                            match current.fmt_flags.num_fmt() {
                                                                ::const_format::pmr::NumberFormatting::Decimal => {
                                                                    debug_display = wrapper.to_start_array_debug();
                                                                    &debug_display
                                                                }
                                                                ::const_format::pmr::NumberFormatting::Binary => {
                                                                    bin = wrapper.to_start_array_binary(current.fmt_flags);
                                                                    &bin
                                                                }
                                                                ::const_format::pmr::NumberFormatting::Hexadecimal => {
                                                                    hex = wrapper.to_start_array_hexadecimal(current.fmt_flags);
                                                                    &hex
                                                                }
                                                            }
                                                        }
                                                    };
                                                    let mut start = sa.start;
                                                    while start < sa.array.len() {
                                                        out.array[out.len] = sa.array[start];
                                                        out.len += 1;
                                                        start += 1;
                                                    }
                                                }
                                                PVariant::Char(c) => {
                                                    let encoded = c.encoded();
                                                    let len = c.len();
                                                    let mut start = 0;
                                                    while start < len {
                                                        out.array[out.len] = encoded[start];
                                                        out.len += 1;
                                                        start += 1;
                                                    }
                                                }
                                            }
                                        }
                                        outer_i += 1;
                                    }
                                }
                                &{ out }
                            };
                            #[doc(hidden)]
                            #[allow(clippy::transmute_ptr_to_ptr)]
                            const CONCAT_STR: &str = unsafe {
                                let slice = ::const_format::pmr::transmute::<
                                    &[u8; ARR_LEN],
                                    &[u8; CONCAT_ARR.len],
                                >(&CONCAT_ARR.array);
                                {
                                    let bytes: &'static [::const_format::pmr::u8] = slice;
                                    let string: &'static ::const_format::pmr::str = {
                                        ::const_format::__hidden_utils::PtrToRef {
                                            ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                        }
                                            .reff
                                    };
                                    string
                                }
                            };
                            CONCAT_STR
                        }
                    })
                },
            }
                .x
        } else {
            ""
        };
        const PREFIX: &str = "";
        const ENCODING: ::leptos::server_fn::Encoding = ::leptos::server_fn::Encoding::Url;
    }
    impl ::leptos::server_fn::ServerFn<::leptos::Scope> for Test {
        type Output = String;
        fn prefix() -> &'static str {
            Self::PREFIX
        }
        fn url() -> &'static str {
            Self::URL
        }
        fn encoding() -> ::leptos::server_fn::Encoding {
            Self::ENCODING
        }
        fn call_fn_client(
            self,
            cx: ::leptos::Scope,
        ) -> std::pin::Pin<
            Box<
                dyn std::future::Future<
                    Output = Result<Self::Output, ::leptos::server_fn::ServerFnError>,
                >,
            >,
        > {
            let Test { name } = self;
            Box::pin(async move { test(name).await })
        }
    }
    #[allow(unused_variables)]
    async fn test(name: String) -> Result<String, ServerFnError> {
        ::leptos::server_fn::call_server_fn(
                &{
                    let prefix = Test::PREFIX.to_string();
                    prefix + "/" + Test::URL
                },
                Test { name },
                ::leptos::server_fn::Encoding::Url,
            )
            .await
    }
    ///Props for the [`App`] component.
    ///
    ///# Required Props
    ///- **cx**: [`Scope`]
    #[builder(doc)]
    pub struct AppProps {}
    impl AppProps {
        /**
                Create a builder for building `AppProps`.
                On the builder, call  to set the values of the fields.
                Finally, call `.build()` to create the instance of `AppProps`.
                */
        #[allow(dead_code, clippy::default_trait_access)]
        pub fn builder() -> AppPropsBuilder<()> {
            AppPropsBuilder {
                fields: (),
                phantom: ::core::default::Default::default(),
            }
        }
    }
    #[must_use]
    /**Builder for [`AppProps`] instances.

See [`AppProps::builder()`] for more info.*/
    #[allow(dead_code, non_camel_case_types, non_snake_case)]
    pub struct AppPropsBuilder<TypedBuilderFields = ()> {
        fields: TypedBuilderFields,
        phantom: (),
    }
    impl<TypedBuilderFields> Clone for AppPropsBuilder<TypedBuilderFields>
    where
        TypedBuilderFields: Clone,
    {
        #[allow(clippy::default_trait_access)]
        fn clone(&self) -> Self {
            Self {
                fields: self.fields.clone(),
                phantom: ::core::default::Default::default(),
            }
        }
    }
    #[doc(hidden)]
    #[allow(dead_code, non_camel_case_types, non_snake_case)]
    pub trait AppPropsBuilder_Optional<T> {
        fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
    }
    impl<T> AppPropsBuilder_Optional<T> for () {
        fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
            default()
        }
    }
    impl<T> AppPropsBuilder_Optional<T> for (T,) {
        fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
            self.0
        }
    }
    #[allow(dead_code, non_camel_case_types, missing_docs)]
    impl AppPropsBuilder<()> {
        ///Finalise the builder and create its [`AppProps`] instance
        #[allow(clippy::default_trait_access)]
        pub fn build(self) -> AppProps {
            let () = self.fields;
            AppProps {}.into()
        }
    }
    impl ::leptos::Props for AppProps {
        type Builder = AppPropsBuilder;
        fn builder() -> Self::Builder {
            AppProps::builder()
        }
    }
    impl ::leptos::IntoView for AppProps {
        fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
            App(cx).into_view(cx)
        }
    }
    ///# Required Props
    ///- **cx**: [`Scope`]
    #[allow(non_snake_case, clippy::too_many_arguments)]
    #[allow(clippy::let_with_type_underscore)]
    pub fn App(#[allow(unused_variables)] cx: ::leptos::Scope) -> impl IntoView {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::INFO
                    <= ::tracing::level_filters::LevelFilter::current()
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "<App />",
                                "frontend::app",
                                tracing::Level::INFO,
                                Some("frontend/src/app.rs"),
                                Some(19u32),
                                Some("frontend::app"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            CALLSITE.metadata(),
                        );
                        if (match tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{ CALLSITE.metadata().fields().value_set(&[]) },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore
                )]
                if false {
                    let __tracing_attr_fake_return: _ = {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!(
                                    "this is just for type inference, and is unreachable code",
                                ),
                            ),
                        );
                    };
                    return __tracing_attr_fake_return;
                }
                {
                    #[allow(clippy::needless_lifetimes)]
                    pub fn __App(cx: Scope) -> impl IntoView {
                        let (state, set_state, _) = use_local_storage(
                            cx,
                            "app-storage",
                            AppStorage::default(),
                        );
                        provide_context(cx, state);
                        provide_context(cx, set_state);
                        {
                            ::leptos::component_view(
                                &Router,
                                cx,
                                ::leptos::component_props_builder(&Router)
                                    .children({
                                        Box::new(move |cx| {
                                            {
                                                ::leptos::Fragment::lazy(|| {
                                                    [
                                                        ::leptos::component_view(
                                                                &Routes,
                                                                cx,
                                                                ::leptos::component_props_builder(&Routes)
                                                                    .children({
                                                                        Box::new(move |cx| {
                                                                            {
                                                                                ::leptos::Fragment::lazy(|| {
                                                                                    [
                                                                                        ::leptos::component_view(
                                                                                                &ProtectedRoute,
                                                                                                cx,
                                                                                                ::leptos::component_props_builder(&ProtectedRoute)
                                                                                                    .path(#[allow(unused_braces)] AppRoute::Empty)
                                                                                                    .redirect_path(
                                                                                                        #[allow(unused_braces)]
                                                                                                        AppRoute::LoggedInRoutes(LoggedInRoutes::Home),
                                                                                                    )
                                                                                                    .condition(
                                                                                                        #[allow(unused_braces)]
                                                                                                        move |_| !is_logged_in(cx),
                                                                                                    )
                                                                                                    .view(
                                                                                                        #[allow(unused_braces)]
                                                                                                        |cx| {
                                                                                                            {
                                                                                                                let _ = ::leptos::leptos_dom::html::div;
                                                                                                                ::leptos::leptos_dom::html::div(cx)
                                                                                                                    .attr("class", (cx, "fc-ct-ct bg-page bg-onboard"))
                                                                                                                    .child((
                                                                                                                        cx,
                                                                                                                        ::leptos::component_view(
                                                                                                                            &Outlet,
                                                                                                                            cx,
                                                                                                                            ::leptos::component_props_builder(&Outlet).build(),
                                                                                                                        ),
                                                                                                                    ))
                                                                                                            }
                                                                                                        },
                                                                                                    )
                                                                                                    .children({
                                                                                                        Box::new(move |cx| {
                                                                                                            {
                                                                                                                ::leptos::Fragment::lazy(|| {
                                                                                                                    [
                                                                                                                        ::leptos::component_view(
                                                                                                                                &Route,
                                                                                                                                cx,
                                                                                                                                ::leptos::component_props_builder(&Route)
                                                                                                                                    .path(#[allow(unused_braces)] "*")
                                                                                                                                    .view(
                                                                                                                                        #[allow(unused_braces)]
                                                                                                                                        |cx| {
                                                                                                                                            let location = use_location(cx);
                                                                                                                                            {
                                                                                                                                                let lvl = ::log::Level::Info;
                                                                                                                                                if lvl <= ::log::STATIC_MAX_LEVEL
                                                                                                                                                    && lvl <= ::log::max_level()
                                                                                                                                                {
                                                                                                                                                    ::log::__private_api::log(
                                                                                                                                                        format_args!("location: {0}", location.pathname.get()),
                                                                                                                                                        lvl,
                                                                                                                                                        &("frontend::app", "frontend::app", "frontend/src/app.rs"),
                                                                                                                                                        45u32,
                                                                                                                                                        ::log::__private_api::Option::None,
                                                                                                                                                    );
                                                                                                                                                }
                                                                                                                                            };
                                                                                                                                            let to = if location.search.get().is_empty() {
                                                                                                                                                {
                                                                                                                                                    let res = ::alloc::fmt::format(
                                                                                                                                                        format_args!(
                                                                                                                                                            "{0}{1}",
                                                                                                                                                            location.pathname.get(),
                                                                                                                                                            location.hash.get(),
                                                                                                                                                        ),
                                                                                                                                                    );
                                                                                                                                                    res
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                {
                                                                                                                                                    let res = ::alloc::fmt::format(
                                                                                                                                                        format_args!(
                                                                                                                                                            "{0}{1}{2}",
                                                                                                                                                            location.pathname.get(),
                                                                                                                                                            location.search.get(),
                                                                                                                                                            location.hash.get(),
                                                                                                                                                        ),
                                                                                                                                                    );
                                                                                                                                                    res
                                                                                                                                                }
                                                                                                                                            };
                                                                                                                                            let path = {
                                                                                                                                                let res = ::alloc::fmt::format(
                                                                                                                                                    format_args!(
                                                                                                                                                        "{0}?{1}",
                                                                                                                                                        LoggedOutRoutes::Login,
                                                                                                                                                        serde_urlencoded::to_string([("to", to)]).unwrap(),
                                                                                                                                                    ),
                                                                                                                                                );
                                                                                                                                                res
                                                                                                                                            };
                                                                                                                                            {
                                                                                                                                                ::leptos::component_view(
                                                                                                                                                    &Redirect,
                                                                                                                                                    cx,
                                                                                                                                                    ::leptos::component_props_builder(&Redirect)
                                                                                                                                                        .path(#[allow(unused_braces)] path)
                                                                                                                                                        .build(),
                                                                                                                                                )
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                    )
                                                                                                                                    .build(),
                                                                                                                            )
                                                                                                                            .into_view(cx),
                                                                                                                    ]
                                                                                                                        .to_vec()
                                                                                                                })
                                                                                                            }
                                                                                                                .with_view_marker("<ProtectedRoute/>-children")
                                                                                                        })
                                                                                                    })
                                                                                                    .build(),
                                                                                            )
                                                                                            .into_view(cx),
                                                                                        ::leptos::component_view(
                                                                                                &ProtectedRoute,
                                                                                                cx,
                                                                                                ::leptos::component_props_builder(&ProtectedRoute)
                                                                                                    .path(#[allow(unused_braces)] AppRoute::Empty)
                                                                                                    .redirect_path(
                                                                                                        #[allow(unused_braces)]
                                                                                                        AppRoute::LoggedOutRoutes(LoggedOutRoutes::Login),
                                                                                                    )
                                                                                                    .condition(
                                                                                                        #[allow(unused_braces)]
                                                                                                        move |_| is_logged_in(cx),
                                                                                                    )
                                                                                                    .view(
                                                                                                        #[allow(unused_braces)]
                                                                                                        |cx| {
                                                                                                            ::leptos::component_view(
                                                                                                                &PageContainer,
                                                                                                                cx,
                                                                                                                ::leptos::component_props_builder(&PageContainer)
                                                                                                                    .children({
                                                                                                                        Box::new(move |cx| {
                                                                                                                            {
                                                                                                                                ::leptos::Fragment::lazy(|| {
                                                                                                                                    [
                                                                                                                                        ::leptos::component_view(
                                                                                                                                                &Outlet,
                                                                                                                                                cx,
                                                                                                                                                ::leptos::component_props_builder(&Outlet).build(),
                                                                                                                                            )
                                                                                                                                            .into_view(cx),
                                                                                                                                    ]
                                                                                                                                        .to_vec()
                                                                                                                                })
                                                                                                                            }
                                                                                                                                .with_view_marker("<PageContainer/>-children")
                                                                                                                        })
                                                                                                                    })
                                                                                                                    .build(),
                                                                                                            )
                                                                                                        },
                                                                                                    )
                                                                                                    .children({
                                                                                                        Box::new(move |cx| {
                                                                                                            {
                                                                                                                ::leptos::Fragment::lazy(|| {
                                                                                                                    [
                                                                                                                        ::leptos::component_view(
                                                                                                                                &Route,
                                                                                                                                cx,
                                                                                                                                ::leptos::component_props_builder(&Route)
                                                                                                                                    .path(#[allow(unused_braces)] LoggedInRoutes::Home)
                                                                                                                                    .view(#[allow(unused_braces)] |_| ())
                                                                                                                                    .build(),
                                                                                                                            )
                                                                                                                            .into_view(cx),
                                                                                                                        ::leptos::component_view(
                                                                                                                                &Route,
                                                                                                                                cx,
                                                                                                                                ::leptos::component_props_builder(&Route)
                                                                                                                                    .path(#[allow(unused_braces)] "*")
                                                                                                                                    .view(
                                                                                                                                        #[allow(unused_braces)]
                                                                                                                                        |cx| {
                                                                                                                                            {
                                                                                                                                                ::leptos::component_view(
                                                                                                                                                    &Redirect,
                                                                                                                                                    cx,
                                                                                                                                                    ::leptos::component_props_builder(&Redirect)
                                                                                                                                                        .path(#[allow(unused_braces)] LoggedInRoutes::Home)
                                                                                                                                                        .build(),
                                                                                                                                                )
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                    )
                                                                                                                                    .build(),
                                                                                                                            )
                                                                                                                            .into_view(cx),
                                                                                                                    ]
                                                                                                                        .to_vec()
                                                                                                                })
                                                                                                            }
                                                                                                                .with_view_marker("<ProtectedRoute/>-children")
                                                                                                        })
                                                                                                    })
                                                                                                    .build(),
                                                                                            )
                                                                                            .into_view(cx),
                                                                                    ]
                                                                                        .to_vec()
                                                                                })
                                                                            }
                                                                                .with_view_marker("<Routes/>-children")
                                                                        })
                                                                    })
                                                                    .build(),
                                                            )
                                                            .into_view(cx),
                                                    ]
                                                        .to_vec()
                                                })
                                            }
                                                .with_view_marker("<Router/>-children")
                                        })
                                    })
                                    .build(),
                            )
                        }
                    }
                    let span = ::leptos::leptos_dom::tracing::Span::current();
                    ::leptos::leptos_dom::Component::new(
                        "App",
                        move |cx| {
                            #[cfg(debug_assertions)]
                            let _guard = span.entered();
                            __App(cx)
                        },
                    )
                }
            }
        }
    }
    /// Returns a boolean if the user is logged in or not
    fn is_logged_in(cx: Scope) -> bool {
        let state = expect_context::<Signal<AppStorage>>(cx);
        state.get().is_logged_in()
    }
}
mod components {
    mod alert {
        use crate::prelude::*;
        ///Props for the [`Alert`] component.
        ///
        /// Alert component. Used to display alerts.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  scope of the component
        ///- **r#type**: [`impl Into<MaybeSignal<NotificationType>>`](MaybeSignal<NotificationType>)
        ///    -  type of the alert
        ///- **message**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  message to display
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  class name to apply to the alert
        #[builder(doc)]
        pub struct AlertProps {
            /// type of the alert
            #[builder(
                setter(
                    doc = "**r#type**: `impl`[`Into<MaybeSignal<NotificationType>>`]\n\n type of the alert"
                )
            )]
            #[builder(setter(into))]
            pub r#type: MaybeSignal<NotificationType>,
            /// message to display
            #[builder(
                setter(
                    doc = "**message**: `impl`[`Into<MaybeSignal<String>>`]\n\n message to display"
                )
            )]
            #[builder(setter(into))]
            pub message: MaybeSignal<String>,
            /// class name to apply to the alert
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n class name to apply to the alert"
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
        }
        impl AlertProps {
            /**
                Create a builder for building `AlertProps`.
                On the builder, call `.r#type(...)`, `.message(...)`, `.class(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `AlertProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> AlertPropsBuilder<((), (), ())> {
                AlertPropsBuilder {
                    fields: ((), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`AlertProps`] instances.

See [`AlertProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct AlertPropsBuilder<TypedBuilderFields = ((), (), ())> {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for AlertPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait AlertPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> AlertPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> AlertPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__message, __class> AlertPropsBuilder<((), __message, __class)> {
            #[doc = "**r#type**: `impl`[`Into<MaybeSignal<NotificationType>>`]\n\n type of the alert"]
            pub fn r#type(
                self,
                r#type: impl ::core::convert::Into<MaybeSignal<NotificationType>>,
            ) -> AlertPropsBuilder<
                ((MaybeSignal<NotificationType>,), __message, __class),
            > {
                let r#type = (r#type.into(),);
                let (_, message, class) = self.fields;
                AlertPropsBuilder {
                    fields: (r#type, message, class),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AlertPropsBuilder_Error_Repeated_field_type {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __message,
            __class,
        > AlertPropsBuilder<((MaybeSignal<NotificationType>,), __message, __class)> {
            #[deprecated(note = "Repeated field r#type")]
            pub fn r#type(
                self,
                _: AlertPropsBuilder_Error_Repeated_field_type,
            ) -> AlertPropsBuilder<
                ((MaybeSignal<NotificationType>,), __message, __class),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__type, __class> AlertPropsBuilder<(__type, (), __class)> {
            #[doc = "**message**: `impl`[`Into<MaybeSignal<String>>`]\n\n message to display"]
            pub fn message(
                self,
                message: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> AlertPropsBuilder<(__type, (MaybeSignal<String>,), __class)> {
                let message = (message.into(),);
                let (r#type, _, class) = self.fields;
                AlertPropsBuilder {
                    fields: (r#type, message, class),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AlertPropsBuilder_Error_Repeated_field_message {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __type,
            __class,
        > AlertPropsBuilder<(__type, (MaybeSignal<String>,), __class)> {
            #[deprecated(note = "Repeated field message")]
            pub fn message(
                self,
                _: AlertPropsBuilder_Error_Repeated_field_message,
            ) -> AlertPropsBuilder<(__type, (MaybeSignal<String>,), __class)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__type, __message> AlertPropsBuilder<(__type, __message, ())> {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n class name to apply to the alert"]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> AlertPropsBuilder<(__type, __message, (MaybeSignal<String>,))> {
                let class = (class.into(),);
                let (r#type, message, _) = self.fields;
                AlertPropsBuilder {
                    fields: (r#type, message, class),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AlertPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __type,
            __message,
        > AlertPropsBuilder<(__type, __message, (MaybeSignal<String>,))> {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: AlertPropsBuilder_Error_Repeated_field_class,
            ) -> AlertPropsBuilder<(__type, __message, (MaybeSignal<String>,))> {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AlertPropsBuilder_Error_Missing_required_field_type {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<__message, __class> AlertPropsBuilder<((), __message, __class)> {
            #[deprecated(note = "Missing required field r#type")]
            pub fn build(
                self,
                _: AlertPropsBuilder_Error_Missing_required_field_type,
            ) -> AlertProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AlertPropsBuilder_Error_Missing_required_field_message {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            __class,
        > AlertPropsBuilder<((MaybeSignal<NotificationType>,), (), __class)> {
            #[deprecated(note = "Missing required field message")]
            pub fn build(
                self,
                _: AlertPropsBuilder_Error_Missing_required_field_message,
            ) -> AlertProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class: AlertPropsBuilder_Optional<MaybeSignal<String>>,
        > AlertPropsBuilder<
            ((MaybeSignal<NotificationType>,), (MaybeSignal<String>,), __class),
        > {
            ///Finalise the builder and create its [`AlertProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> AlertProps {
                let (r#type, message, class) = self.fields;
                let r#type = r#type.0;
                let message = message.0;
                let class = AlertPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                AlertProps {
                    r#type,
                    message,
                    class,
                }
                    .into()
            }
        }
        impl ::leptos::Props for AlertProps {
            type Builder = AlertPropsBuilder;
            fn builder() -> Self::Builder {
                AlertProps::builder()
            }
        }
        impl ::leptos::IntoView for AlertProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Alert(cx, self).into_view(cx)
            }
        }
        /// Alert component. Used to display alerts.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  scope of the component
        ///- **r#type**: [`impl Into<MaybeSignal<NotificationType>>`](MaybeSignal<NotificationType>)
        ///    -  type of the alert
        ///- **message**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  message to display
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  class name to apply to the alert
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Alert(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: AlertProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Alert />",
                                    "frontend::components::alert",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/alert.rs"),
                                    Some(4u32),
                                    Some("frontend::components::alert"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Alert(
                            cx: Scope,
                            r#type: MaybeSignal<NotificationType>,
                            message: MaybeSignal<String>,
                            class: MaybeSignal<String>,
                        ) -> impl IntoView {
                            {
                                {
                                    let _ = ::leptos::leptos_dom::html::span;
                                    ::leptos::leptos_dom::html::span(cx)
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                move || {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("txt-white fr-fs-fs {0}", class.get()),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                        .child((
                                            cx,
                                            ::leptos::component_view(
                                                &Icon,
                                                cx,
                                                ::leptos::component_props_builder(&Icon)
                                                    .icon(
                                                        #[allow(unused_braces)]
                                                        {
                                                            r#type
                                                                .with(|r#type| {
                                                                    if match r#type {
                                                                        NotificationType::Error | NotificationType::Warning => true,
                                                                        _ => false,
                                                                    } {
                                                                        IconType::AlertCircle
                                                                    } else {
                                                                        IconType::CheckCircle
                                                                    }
                                                                })
                                                        },
                                                    )
                                                    .size(#[allow(unused_braces)] { Small })
                                                    .color(
                                                        #[allow(unused_braces)]
                                                        { r#type.with(NotificationType::as_patr_color) },
                                                    )
                                                    .build(),
                                            ),
                                        ))
                                        .child((
                                            cx,
                                            {
                                                let _ = ::leptos::leptos_dom::html::span;
                                                ::leptos::leptos_dom::html::span(cx)
                                                    .attr(
                                                        "class",
                                                        (
                                                            cx,
                                                            move || {
                                                                let res = ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "ml-xxs {0}",
                                                                        r#type.get().as_patr_color().as_text_color().as_css_color(),
                                                                    ),
                                                                );
                                                                res
                                                            },
                                                        ),
                                                    )
                                                    .child((cx, { message }))
                                            },
                                        ))
                                }
                            }
                        }
                        let AlertProps { r#type, message, class } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Alert",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "r#type",
                                        value: std::cell::Cell::new(Some(&r#type)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "message",
                                        value: std::cell::Cell::new(Some(&message)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::alert",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/alert.rs"),
                                                    Some(4u32),
                                                    Some("frontend::components::alert"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Alert(cx, r#type, message, class)
                            },
                        )
                    }
                }
            }
        }
    }
    mod avatar {
        use crate::prelude::*;
        ///Props for the [`Avatar`] component.
        ///
        /// The avatar component, used for displaying a user's avatar.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component.
        ///# Optional Props
        ///- **first_name**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The first name of the user.
        ///- **last_name**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The last name of the user.
        ///- **image**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The image of the user, if any
        ///- **size**: [`impl Into<MaybeSignal<Size>>`](MaybeSignal<Size>)
        ///    -  The size of the avatar.
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional classes to add to the avatar, if any.
        ///- **variant**: [`impl Into<MaybeSignal<Option<SecondaryColorVariant>>>`](MaybeSignal<Option<SecondaryColorVariant>>)
        ///    -  The variant of the avatar, if any.
        #[builder(doc)]
        pub struct AvatarProps {
            /// The first name of the user.
            #[builder(
                setter(
                    doc = "**first_name**: `impl`[`Into<MaybeSignal<String>>`]\n\n The first name of the user."
                )
            )]
            #[builder(default, setter(into))]
            pub first_name: MaybeSignal<String>,
            /// The last name of the user.
            #[builder(
                setter(
                    doc = "**last_name**: `impl`[`Into<MaybeSignal<String>>`]\n\n The last name of the user."
                )
            )]
            #[builder(default, setter(into))]
            pub last_name: MaybeSignal<String>,
            /// The image of the user, if any
            #[builder(
                setter(
                    doc = "**image**: `impl`[`Into<MaybeSignal<String>>`]\n\n The image of the user, if any"
                )
            )]
            #[builder(default, setter(into))]
            pub image: MaybeSignal<String>,
            /// The size of the avatar.
            #[builder(
                setter(
                    doc = "**size**: `impl`[`Into<MaybeSignal<Size>>`]\n\n The size of the avatar."
                )
            )]
            #[builder(default_code = "Small.into()", setter(into))]
            pub size: MaybeSignal<Size>,
            /// Additional classes to add to the avatar, if any.
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional classes to add to the avatar, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
            /// The variant of the avatar, if any.
            #[builder(
                setter(
                    doc = "**variant**: `impl`[`Into<MaybeSignal<Option<SecondaryColorVariant>>>`]\n\n The variant of the avatar, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub variant: MaybeSignal<Option<SecondaryColorVariant>>,
        }
        impl AvatarProps {
            /**
                Create a builder for building `AvatarProps`.
                On the builder, call `.first_name(...)`(optional), `.last_name(...)`(optional), `.image(...)`(optional), `.size(...)`(optional), `.class(...)`(optional), `.variant(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `AvatarProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> AvatarPropsBuilder<((), (), (), (), (), ())> {
                AvatarPropsBuilder {
                    fields: ((), (), (), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`AvatarProps`] instances.

See [`AvatarProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct AvatarPropsBuilder<TypedBuilderFields = ((), (), (), (), (), ())> {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for AvatarPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait AvatarPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> AvatarPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> AvatarPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __last_name,
            __image,
            __size,
            __class,
            __variant,
        > AvatarPropsBuilder<((), __last_name, __image, __size, __class, __variant)> {
            #[doc = "**first_name**: `impl`[`Into<MaybeSignal<String>>`]\n\n The first name of the user."]
            pub fn first_name(
                self,
                first_name: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> AvatarPropsBuilder<
                (
                    (MaybeSignal<String>,),
                    __last_name,
                    __image,
                    __size,
                    __class,
                    __variant,
                ),
            > {
                let first_name = (first_name.into(),);
                let (_, last_name, image, size, class, variant) = self.fields;
                AvatarPropsBuilder {
                    fields: (first_name, last_name, image, size, class, variant),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AvatarPropsBuilder_Error_Repeated_field_first_name {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __last_name,
            __image,
            __size,
            __class,
            __variant,
        > AvatarPropsBuilder<
            ((MaybeSignal<String>,), __last_name, __image, __size, __class, __variant),
        > {
            #[deprecated(note = "Repeated field first_name")]
            pub fn first_name(
                self,
                _: AvatarPropsBuilder_Error_Repeated_field_first_name,
            ) -> AvatarPropsBuilder<
                (
                    (MaybeSignal<String>,),
                    __last_name,
                    __image,
                    __size,
                    __class,
                    __variant,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __image,
            __size,
            __class,
            __variant,
        > AvatarPropsBuilder<(__first_name, (), __image, __size, __class, __variant)> {
            #[doc = "**last_name**: `impl`[`Into<MaybeSignal<String>>`]\n\n The last name of the user."]
            pub fn last_name(
                self,
                last_name: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    (MaybeSignal<String>,),
                    __image,
                    __size,
                    __class,
                    __variant,
                ),
            > {
                let last_name = (last_name.into(),);
                let (first_name, _, image, size, class, variant) = self.fields;
                AvatarPropsBuilder {
                    fields: (first_name, last_name, image, size, class, variant),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AvatarPropsBuilder_Error_Repeated_field_last_name {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __image,
            __size,
            __class,
            __variant,
        > AvatarPropsBuilder<
            (__first_name, (MaybeSignal<String>,), __image, __size, __class, __variant),
        > {
            #[deprecated(note = "Repeated field last_name")]
            pub fn last_name(
                self,
                _: AvatarPropsBuilder_Error_Repeated_field_last_name,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    (MaybeSignal<String>,),
                    __image,
                    __size,
                    __class,
                    __variant,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __size,
            __class,
            __variant,
        > AvatarPropsBuilder<
            (__first_name, __last_name, (), __size, __class, __variant),
        > {
            #[doc = "**image**: `impl`[`Into<MaybeSignal<String>>`]\n\n The image of the user, if any"]
            pub fn image(
                self,
                image: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    (MaybeSignal<String>,),
                    __size,
                    __class,
                    __variant,
                ),
            > {
                let image = (image.into(),);
                let (first_name, last_name, _, size, class, variant) = self.fields;
                AvatarPropsBuilder {
                    fields: (first_name, last_name, image, size, class, variant),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AvatarPropsBuilder_Error_Repeated_field_image {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __size,
            __class,
            __variant,
        > AvatarPropsBuilder<
            (
                __first_name,
                __last_name,
                (MaybeSignal<String>,),
                __size,
                __class,
                __variant,
            ),
        > {
            #[deprecated(note = "Repeated field image")]
            pub fn image(
                self,
                _: AvatarPropsBuilder_Error_Repeated_field_image,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    (MaybeSignal<String>,),
                    __size,
                    __class,
                    __variant,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __image,
            __class,
            __variant,
        > AvatarPropsBuilder<
            (__first_name, __last_name, __image, (), __class, __variant),
        > {
            #[doc = "**size**: `impl`[`Into<MaybeSignal<Size>>`]\n\n The size of the avatar."]
            pub fn size(
                self,
                size: impl ::core::convert::Into<MaybeSignal<Size>>,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    __image,
                    (MaybeSignal<Size>,),
                    __class,
                    __variant,
                ),
            > {
                let size = (size.into(),);
                let (first_name, last_name, image, _, class, variant) = self.fields;
                AvatarPropsBuilder {
                    fields: (first_name, last_name, image, size, class, variant),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AvatarPropsBuilder_Error_Repeated_field_size {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __image,
            __class,
            __variant,
        > AvatarPropsBuilder<
            (
                __first_name,
                __last_name,
                __image,
                (MaybeSignal<Size>,),
                __class,
                __variant,
            ),
        > {
            #[deprecated(note = "Repeated field size")]
            pub fn size(
                self,
                _: AvatarPropsBuilder_Error_Repeated_field_size,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    __image,
                    (MaybeSignal<Size>,),
                    __class,
                    __variant,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __image,
            __size,
            __variant,
        > AvatarPropsBuilder<
            (__first_name, __last_name, __image, __size, (), __variant),
        > {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional classes to add to the avatar, if any."]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    __image,
                    __size,
                    (MaybeSignal<String>,),
                    __variant,
                ),
            > {
                let class = (class.into(),);
                let (first_name, last_name, image, size, _, variant) = self.fields;
                AvatarPropsBuilder {
                    fields: (first_name, last_name, image, size, class, variant),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AvatarPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __image,
            __size,
            __variant,
        > AvatarPropsBuilder<
            (
                __first_name,
                __last_name,
                __image,
                __size,
                (MaybeSignal<String>,),
                __variant,
            ),
        > {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: AvatarPropsBuilder_Error_Repeated_field_class,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    __image,
                    __size,
                    (MaybeSignal<String>,),
                    __variant,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __image,
            __size,
            __class,
        > AvatarPropsBuilder<(__first_name, __last_name, __image, __size, __class, ())> {
            #[doc = "**variant**: `impl`[`Into<MaybeSignal<Option<SecondaryColorVariant>>>`]\n\n The variant of the avatar, if any."]
            pub fn variant(
                self,
                variant: impl ::core::convert::Into<
                    MaybeSignal<Option<SecondaryColorVariant>>,
                >,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    __image,
                    __size,
                    __class,
                    (MaybeSignal<Option<SecondaryColorVariant>>,),
                ),
            > {
                let variant = (variant.into(),);
                let (first_name, last_name, image, size, class, _) = self.fields;
                AvatarPropsBuilder {
                    fields: (first_name, last_name, image, size, class, variant),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AvatarPropsBuilder_Error_Repeated_field_variant {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name,
            __last_name,
            __image,
            __size,
            __class,
        > AvatarPropsBuilder<
            (
                __first_name,
                __last_name,
                __image,
                __size,
                __class,
                (MaybeSignal<Option<SecondaryColorVariant>>,),
            ),
        > {
            #[deprecated(note = "Repeated field variant")]
            pub fn variant(
                self,
                _: AvatarPropsBuilder_Error_Repeated_field_variant,
            ) -> AvatarPropsBuilder<
                (
                    __first_name,
                    __last_name,
                    __image,
                    __size,
                    __class,
                    (MaybeSignal<Option<SecondaryColorVariant>>,),
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __first_name: AvatarPropsBuilder_Optional<MaybeSignal<String>>,
            __last_name: AvatarPropsBuilder_Optional<MaybeSignal<String>>,
            __image: AvatarPropsBuilder_Optional<MaybeSignal<String>>,
            __size: AvatarPropsBuilder_Optional<MaybeSignal<Size>>,
            __class: AvatarPropsBuilder_Optional<MaybeSignal<String>>,
            __variant: AvatarPropsBuilder_Optional<
                    MaybeSignal<Option<SecondaryColorVariant>>,
                >,
        > AvatarPropsBuilder<
            (__first_name, __last_name, __image, __size, __class, __variant),
        > {
            ///Finalise the builder and create its [`AvatarProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> AvatarProps {
                let (first_name, last_name, image, size, class, variant) = self.fields;
                let first_name = AvatarPropsBuilder_Optional::into_value(
                    first_name,
                    || ::core::default::Default::default(),
                );
                let last_name = AvatarPropsBuilder_Optional::into_value(
                    last_name,
                    || ::core::default::Default::default(),
                );
                let image = AvatarPropsBuilder_Optional::into_value(
                    image,
                    || ::core::default::Default::default(),
                );
                let size = AvatarPropsBuilder_Optional::into_value(
                    size,
                    || Small.into(),
                );
                let class = AvatarPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                let variant = AvatarPropsBuilder_Optional::into_value(
                    variant,
                    || ::core::default::Default::default(),
                );
                AvatarProps {
                    first_name,
                    last_name,
                    image,
                    size,
                    class,
                    variant,
                }
                    .into()
            }
        }
        impl ::leptos::Props for AvatarProps {
            type Builder = AvatarPropsBuilder;
            fn builder() -> Self::Builder {
                AvatarProps::builder()
            }
        }
        impl ::leptos::IntoView for AvatarProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Avatar(cx, self).into_view(cx)
            }
        }
        /// The avatar component, used for displaying a user's avatar.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component.
        ///# Optional Props
        ///- **first_name**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The first name of the user.
        ///- **last_name**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The last name of the user.
        ///- **image**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The image of the user, if any
        ///- **size**: [`impl Into<MaybeSignal<Size>>`](MaybeSignal<Size>)
        ///    -  The size of the avatar.
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional classes to add to the avatar, if any.
        ///- **variant**: [`impl Into<MaybeSignal<Option<SecondaryColorVariant>>>`](MaybeSignal<Option<SecondaryColorVariant>>)
        ///    -  The variant of the avatar, if any.
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Avatar(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: AvatarProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Avatar />",
                                    "frontend::components::avatar",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/avatar.rs"),
                                    Some(4u32),
                                    Some("frontend::components::avatar"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Avatar(
                            cx: Scope,
                            first_name: MaybeSignal<String>,
                            last_name: MaybeSignal<String>,
                            image: MaybeSignal<String>,
                            size: MaybeSignal<Size>,
                            class: MaybeSignal<String>,
                            variant: MaybeSignal<Option<SecondaryColorVariant>>,
                        ) -> impl IntoView {
                            {
                                {
                                    let _ = ::leptos::leptos_dom::html::div;
                                    ::leptos::leptos_dom::html::div(cx)
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                move || {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!(
                                                            "avatar cursor-pointer txt-white bg-secondary fr-ct-ct of-hidden avatar-{0} {1} {2}",
                                                            size.get().as_css_name(),
                                                            if let Some(variant) = variant.get() {
                                                                {
                                                                    let res = ::alloc::fmt::format(
                                                                        format_args!("bg-secondary-{0}", variant.as_css_name()),
                                                                    );
                                                                    res
                                                                }
                                                            } else {
                                                                "bg-secondary".to_owned()
                                                            },
                                                            class.get(),
                                                        ),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                        .child((
                                            cx,
                                            {
                                                image
                                                    .get()
                                                    .some_if_not_empty()
                                                    .map(|image| {
                                                        let first_name = first_name.clone();
                                                        {
                                                            {
                                                                ::leptos::leptos_dom::html::img(cx)
                                                                    .attr("class", (cx, "img-res"))
                                                                    .attr("src", (cx, { image }))
                                                                    .attr(
                                                                        "alt",
                                                                        (
                                                                            cx,
                                                                            {
                                                                                first_name
                                                                                    .get()
                                                                                    .some_if_not_empty()
                                                                                    .unwrap_or("avatar".into())
                                                                            },
                                                                        ),
                                                                    )
                                                            }
                                                        }
                                                    })
                                            },
                                        ))
                                        .child((
                                            cx,
                                            {
                                                move || {
                                                    first_name
                                                        .get()
                                                        .some_if_not_empty()
                                                        .map(|first_name| {
                                                            {
                                                                {
                                                                    first_name
                                                                        .chars()
                                                                        .next()
                                                                        .unwrap_or_default()
                                                                        .to_ascii_uppercase()
                                                                }
                                                            }
                                                        })
                                                }
                                            },
                                        ))
                                        .child((
                                            cx,
                                            {
                                                move || {
                                                    last_name
                                                        .get()
                                                        .some_if_not_empty()
                                                        .map(|last_name| {
                                                            {
                                                                {
                                                                    last_name
                                                                        .chars()
                                                                        .next()
                                                                        .unwrap_or_default()
                                                                        .to_ascii_uppercase()
                                                                }
                                                            }
                                                        })
                                                }
                                            },
                                        ))
                                }
                            }
                        }
                        let AvatarProps {
                            first_name,
                            last_name,
                            image,
                            size,
                            class,
                            variant,
                        } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Avatar",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "first_name",
                                        value: std::cell::Cell::new(Some(&first_name)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "last_name",
                                        value: std::cell::Cell::new(Some(&last_name)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "image",
                                        value: std::cell::Cell::new(Some(&image)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "size",
                                        value: std::cell::Cell::new(Some(&size)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "variant",
                                        value: std::cell::Cell::new(Some(&variant)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::avatar",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/avatar.rs"),
                                                    Some(4u32),
                                                    Some("frontend::components::avatar"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Avatar(
                                    cx,
                                    first_name,
                                    last_name,
                                    image,
                                    size,
                                    class,
                                    variant,
                                )
                            },
                        )
                    }
                }
            }
        }
    }
    mod badge {
        use crate::prelude::*;
        ///Props for the [`Badge`] component.
        ///
        /// A badge. Used for things like unread counts, "beta" labels, etc.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  Scope of the component.
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Any additional classes to apply to the badge.
        ///- **color**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  The color of the badge.
        ///- **text**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The text in the badge.
        #[builder(doc)]
        pub struct BadgeProps {
            /// Any additional classes to apply to the badge.
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Any additional classes to apply to the badge."
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
            /// The color of the badge.
            #[builder(
                setter(
                    doc = "**color**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n The color of the badge."
                )
            )]
            #[builder(default, setter(into))]
            pub color: MaybeSignal<PatrColor>,
            /// The text in the badge.
            #[builder(
                setter(
                    doc = "**text**: `impl`[`Into<MaybeSignal<String>>`]\n\n The text in the badge."
                )
            )]
            #[builder(default, setter(into))]
            pub text: MaybeSignal<String>,
        }
        impl BadgeProps {
            /**
                Create a builder for building `BadgeProps`.
                On the builder, call `.class(...)`(optional), `.color(...)`(optional), `.text(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `BadgeProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> BadgePropsBuilder<((), (), ())> {
                BadgePropsBuilder {
                    fields: ((), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`BadgeProps`] instances.

See [`BadgeProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct BadgePropsBuilder<TypedBuilderFields = ((), (), ())> {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for BadgePropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait BadgePropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> BadgePropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> BadgePropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__color, __text> BadgePropsBuilder<((), __color, __text)> {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Any additional classes to apply to the badge."]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> BadgePropsBuilder<((MaybeSignal<String>,), __color, __text)> {
                let class = (class.into(),);
                let (_, color, text) = self.fields;
                BadgePropsBuilder {
                    fields: (class, color, text),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum BadgePropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __color,
            __text,
        > BadgePropsBuilder<((MaybeSignal<String>,), __color, __text)> {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: BadgePropsBuilder_Error_Repeated_field_class,
            ) -> BadgePropsBuilder<((MaybeSignal<String>,), __color, __text)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__class, __text> BadgePropsBuilder<(__class, (), __text)> {
            #[doc = "**color**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n The color of the badge."]
            pub fn color(
                self,
                color: impl ::core::convert::Into<MaybeSignal<PatrColor>>,
            ) -> BadgePropsBuilder<(__class, (MaybeSignal<PatrColor>,), __text)> {
                let color = (color.into(),);
                let (class, _, text) = self.fields;
                BadgePropsBuilder {
                    fields: (class, color, text),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum BadgePropsBuilder_Error_Repeated_field_color {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class,
            __text,
        > BadgePropsBuilder<(__class, (MaybeSignal<PatrColor>,), __text)> {
            #[deprecated(note = "Repeated field color")]
            pub fn color(
                self,
                _: BadgePropsBuilder_Error_Repeated_field_color,
            ) -> BadgePropsBuilder<(__class, (MaybeSignal<PatrColor>,), __text)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__class, __color> BadgePropsBuilder<(__class, __color, ())> {
            #[doc = "**text**: `impl`[`Into<MaybeSignal<String>>`]\n\n The text in the badge."]
            pub fn text(
                self,
                text: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> BadgePropsBuilder<(__class, __color, (MaybeSignal<String>,))> {
                let text = (text.into(),);
                let (class, color, _) = self.fields;
                BadgePropsBuilder {
                    fields: (class, color, text),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum BadgePropsBuilder_Error_Repeated_field_text {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class,
            __color,
        > BadgePropsBuilder<(__class, __color, (MaybeSignal<String>,))> {
            #[deprecated(note = "Repeated field text")]
            pub fn text(
                self,
                _: BadgePropsBuilder_Error_Repeated_field_text,
            ) -> BadgePropsBuilder<(__class, __color, (MaybeSignal<String>,))> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class: BadgePropsBuilder_Optional<MaybeSignal<String>>,
            __color: BadgePropsBuilder_Optional<MaybeSignal<PatrColor>>,
            __text: BadgePropsBuilder_Optional<MaybeSignal<String>>,
        > BadgePropsBuilder<(__class, __color, __text)> {
            ///Finalise the builder and create its [`BadgeProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> BadgeProps {
                let (class, color, text) = self.fields;
                let class = BadgePropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                let color = BadgePropsBuilder_Optional::into_value(
                    color,
                    || ::core::default::Default::default(),
                );
                let text = BadgePropsBuilder_Optional::into_value(
                    text,
                    || ::core::default::Default::default(),
                );
                BadgeProps { class, color, text }.into()
            }
        }
        impl ::leptos::Props for BadgeProps {
            type Builder = BadgePropsBuilder;
            fn builder() -> Self::Builder {
                BadgeProps::builder()
            }
        }
        impl ::leptos::IntoView for BadgeProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Badge(cx, self).into_view(cx)
            }
        }
        /// A badge. Used for things like unread counts, "beta" labels, etc.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  Scope of the component.
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Any additional classes to apply to the badge.
        ///- **color**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  The color of the badge.
        ///- **text**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The text in the badge.
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Badge(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: BadgeProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Badge />",
                                    "frontend::components::badge",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/badge.rs"),
                                    Some(4u32),
                                    Some("frontend::components::badge"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Badge(
                            cx: Scope,
                            class: MaybeSignal<String>,
                            color: MaybeSignal<PatrColor>,
                            text: MaybeSignal<String>,
                        ) -> impl IntoView {
                            {
                                {
                                    let _ = ::leptos::leptos_dom::html::span;
                                    ::leptos::leptos_dom::html::span(cx)
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                move || {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!(
                                                            "badge pos-abs txt-secondary txt-medium bg-{0} {1}",
                                                            color.get().as_css_name(),
                                                            class.get(),
                                                        ),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                        .child((cx, { text }))
                                }
                            }
                        }
                        let BadgeProps { class, color, text } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Badge",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "color",
                                        value: std::cell::Cell::new(Some(&color)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "text",
                                        value: std::cell::Cell::new(Some(&text)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::badge",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/badge.rs"),
                                                    Some(4u32),
                                                    Some("frontend::components::badge"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Badge(cx, class, color, text)
                            },
                        )
                    }
                }
            }
        }
    }
    mod containers {
        mod page_container {
            use crate::prelude::*;
            ///Props for the [`PageContainer`] component.
            ///
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            ///- **children**: [`Children`]
            ///    -  The children of the component
            #[builder(doc)]
            pub struct PageContainerProps {
                /// The children of the component
                #[builder(
                    setter(
                        doc = "**children**: [`Children`]\n\n The children of the component"
                    )
                )]
                #[builder()]
                #[allow(missing_docs)]
                pub children: Children,
            }
            impl PageContainerProps {
                /**
                Create a builder for building `PageContainerProps`.
                On the builder, call `.children(...)` to set the values of the fields.
                Finally, call `.build()` to create the instance of `PageContainerProps`.
                */
                #[allow(dead_code, clippy::default_trait_access)]
                pub fn builder() -> PageContainerPropsBuilder<((),)> {
                    PageContainerPropsBuilder {
                        fields: ((),),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[must_use]
            /**Builder for [`PageContainerProps`] instances.

See [`PageContainerProps::builder()`] for more info.*/
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub struct PageContainerPropsBuilder<TypedBuilderFields = ((),)> {
                fields: TypedBuilderFields,
                phantom: (),
            }
            impl<TypedBuilderFields> Clone
            for PageContainerPropsBuilder<TypedBuilderFields>
            where
                TypedBuilderFields: Clone,
            {
                #[allow(clippy::default_trait_access)]
                fn clone(&self) -> Self {
                    Self {
                        fields: self.fields.clone(),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub trait PageContainerPropsBuilder_Optional<T> {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
            }
            impl<T> PageContainerPropsBuilder_Optional<T> for () {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                    default()
                }
            }
            impl<T> PageContainerPropsBuilder_Optional<T> for (T,) {
                fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                    self.0
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl PageContainerPropsBuilder<((),)> {
                #[doc = "**children**: [`Children`]\n\n The children of the component"]
                pub fn children(
                    self,
                    children: Children,
                ) -> PageContainerPropsBuilder<((Children,),)> {
                    let children = (children,);
                    let (_,) = self.fields;
                    PageContainerPropsBuilder {
                        fields: (children,),
                        phantom: self.phantom,
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub enum PageContainerPropsBuilder_Error_Repeated_field_children {}
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl PageContainerPropsBuilder<((Children,),)> {
                #[deprecated(note = "Repeated field children")]
                pub fn children(
                    self,
                    _: PageContainerPropsBuilder_Error_Repeated_field_children,
                ) -> PageContainerPropsBuilder<((Children,),)> {
                    self
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub enum PageContainerPropsBuilder_Error_Missing_required_field_children {}
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
            impl PageContainerPropsBuilder<((),)> {
                #[deprecated(note = "Missing required field children")]
                pub fn build(
                    self,
                    _: PageContainerPropsBuilder_Error_Missing_required_field_children,
                ) -> PageContainerProps {
                    { ::std::rt::begin_panic("explicit panic") };
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl PageContainerPropsBuilder<((Children,),)> {
                ///Finalise the builder and create its [`PageContainerProps`] instance
                #[allow(clippy::default_trait_access)]
                pub fn build(self) -> PageContainerProps {
                    let (children,) = self.fields;
                    let children = children.0;
                    PageContainerProps { children }.into()
                }
            }
            impl ::leptos::Props for PageContainerProps {
                type Builder = PageContainerPropsBuilder;
                fn builder() -> Self::Builder {
                    PageContainerProps::builder()
                }
            }
            impl ::leptos::IntoView for PageContainerProps {
                fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                    PageContainer(cx, self).into_view(cx)
                }
            }
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            ///- **children**: [`Children`]
            ///    -  The children of the component
            #[allow(non_snake_case, clippy::too_many_arguments)]
            #[allow(clippy::let_with_type_underscore)]
            pub fn PageContainer(
                #[allow(unused_variables)]
                cx: ::leptos::Scope,
                props: PageContainerProps,
            ) -> impl IntoView {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "<PageContainer />",
                                        "frontend::components::containers::page_container",
                                        tracing::Level::INFO,
                                        Some(
                                            "frontend/src/components/containers/page_container.rs",
                                        ),
                                        Some(3u32),
                                        Some("frontend::components::containers::page_container"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    CALLSITE.metadata(),
                                );
                                if (match tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            span.record_all(
                                                &{ CALLSITE.metadata().fields().value_set(&[]) },
                                            );
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore
                        )]
                        if false {
                            let __tracing_attr_fake_return: _ = {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "this is just for type inference, and is unreachable code",
                                        ),
                                    ),
                                );
                            };
                            return __tracing_attr_fake_return;
                        }
                        {
                            #[allow(clippy::needless_lifetimes)]
                            pub fn __PageContainer(
                                cx: Scope,
                                children: Children,
                            ) -> impl IntoView {
                                {
                                    {
                                        let _ = ::leptos::leptos_dom::html::div;
                                        ::leptos::leptos_dom::html::div(cx)
                                            .attr(
                                                "class",
                                                (cx, "fr-fs-fs full-width full-height bg-secondary"),
                                            )
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::main;
                                                    ::leptos::leptos_dom::html::main(cx)
                                                        .attr("class", (cx, "fc-fs-ct full-width px-lg"))
                                                        .child((
                                                            cx,
                                                            ::leptos::component_view(
                                                                &TopNav,
                                                                cx,
                                                                ::leptos::component_props_builder(&TopNav).build(),
                                                            ),
                                                        ))
                                                        .child((cx, { children(cx) }))
                                                },
                                            ))
                                    }
                                }
                            }
                            let PageContainerProps { children } = props;
                            let span = ::leptos::leptos_dom::tracing::Span::current();
                            ::leptos::leptos_dom::Component::new(
                                "PageContainer",
                                move |cx| {
                                    #[cfg(debug_assertions)]
                                    let _guard = span.entered();
                                    {
                                        use ::leptos::leptos_dom::tracing_property::{
                                            Match, SerializeMatch, DefaultMatch,
                                        };
                                        let mut props = String::from('[');
                                        let prop = (&&Match {
                                            name: "children",
                                            value: std::cell::Cell::new(Some(&children)),
                                        })
                                            .spez();
                                        props
                                            .push_str(
                                                &{
                                                    let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                    res
                                                },
                                            );
                                        props.pop();
                                        props.push(']');
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "leptos_dom::tracing_props",
                                                        "frontend::components::containers::page_container",
                                                        ::leptos::leptos_dom::tracing::Level::TRACE,
                                                        Some(
                                                            "frontend/src/components/containers/page_container.rs",
                                                        ),
                                                        Some(3u32),
                                                        Some("frontend::components::containers::page_container"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["props"],
                                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::SPAN,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let mut interest = ::tracing::subscriber::Interest::never();
                                            if ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::leptos::leptos_dom::tracing::Level::TRACE
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    interest = CALLSITE.interest();
                                                    !interest.is_never()
                                                }
                                                && ::tracing::__macro_support::__is_enabled(
                                                    CALLSITE.metadata(),
                                                    interest,
                                                )
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(
                                                    meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = meta.fields().iter();
                                                        meta.fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                        Some(&props as &dyn Value),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            } else {
                                                let span = ::tracing::__macro_support::__disabled_span(
                                                    CALLSITE.metadata(),
                                                );
                                                if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            span.record_all(
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = CALLSITE.metadata().fields().iter();
                                                                    CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                    Some(&props as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            );
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                                span
                                            }
                                        };
                                    };
                                    __PageContainer(cx, children)
                                },
                            )
                        }
                    }
                }
            }
        }
        pub use self::page_container::*;
    }
    mod icon {
        use std::{fmt::Display, rc::Rc};
        use crate::prelude::*;
        /// The kind of icon to display. This is taken directly from the Feather icon
        /// set.
        pub enum IconType {
            /// https://feathericons.com/?query=activity
            Activity,
            /// https://feathericons.com/?query=airplay
            Airplay,
            /// https://feathericons.com/?query=alert-circle
            AlertCircle,
            /// https://feathericons.com/?query=alert-octagon
            AlertOctagon,
            /// https://feathericons.com/?query=alert-triangle
            AlertTriangle,
            /// https://feathericons.com/?query=align-center
            AlignCenter,
            /// https://feathericons.com/?query=align-justify
            AlignJustify,
            /// https://feathericons.com/?query=align-left
            AlignLeft,
            /// https://feathericons.com/?query=align-right
            AlignRight,
            /// https://feathericons.com/?query=anchor
            Anchor,
            /// https://feathericons.com/?query=aperture
            Aperture,
            /// https://feathericons.com/?query=archive
            Archive,
            /// https://feathericons.com/?query=arrow-down-circle
            ArrowDownCircle,
            /// https://feathericons.com/?query=arrow-down-left
            ArrowDownLeft,
            /// https://feathericons.com/?query=arrow-down-right
            ArrowDownRight,
            /// https://feathericons.com/?query=arrow-down
            ArrowDown,
            /// https://feathericons.com/?query=arrow-left-circle
            ArrowLeftCircle,
            /// https://feathericons.com/?query=arrow-left
            ArrowLeft,
            /// https://feathericons.com/?query=arrow-right-circle
            ArrowRightCircle,
            /// https://feathericons.com/?query=arrow-right
            ArrowRight,
            /// https://feathericons.com/?query=arrow-up-circle
            ArrowUpCircle,
            /// https://feathericons.com/?query=arrow-up-left
            ArrowUpLeft,
            /// https://feathericons.com/?query=arrow-up-right
            ArrowUpRight,
            /// https://feathericons.com/?query=arrow-up
            ArrowUp,
            /// https://feathericons.com/?query=at-sign
            AtSign,
            /// https://feathericons.com/?query=award
            Award,
            /// https://feathericons.com/?query=bar-chart2
            BarChart2,
            /// https://feathericons.com/?query=bar-chart
            BarChart,
            /// https://feathericons.com/?query=battery-charging
            BatteryCharging,
            /// https://feathericons.com/?query=battery
            Battery,
            /// https://feathericons.com/?query=bell-off
            BellOff,
            /// https://feathericons.com/?query=bell
            Bell,
            /// https://feathericons.com/?query=bluetooth
            Bluetooth,
            /// https://feathericons.com/?query=bold
            Bold,
            /// https://feathericons.com/?query=book-open
            BookOpen,
            /// https://feathericons.com/?query=book
            Book,
            /// https://feathericons.com/?query=bookmark
            Bookmark,
            /// https://feathericons.com/?query=box
            Box,
            /// https://feathericons.com/?query=briefcase
            Briefcase,
            /// https://feathericons.com/?query=calendar
            Calendar,
            /// https://feathericons.com/?query=camera-off
            CameraOff,
            /// https://feathericons.com/?query=camera
            Camera,
            /// https://feathericons.com/?query=cast
            Cast,
            /// https://feathericons.com/?query=check-circle
            CheckCircle,
            /// https://feathericons.com/?query=check-square
            CheckSquare,
            /// https://feathericons.com/?query=check
            Check,
            /// https://feathericons.com/?query=chevron-down
            ChevronDown,
            /// https://feathericons.com/?query=chevron-left
            ChevronLeft,
            /// https://feathericons.com/?query=chevron-right
            ChevronRight,
            /// https://feathericons.com/?query=chevron-up
            ChevronUp,
            /// https://feathericons.com/?query=chevrons-down
            ChevronsDown,
            /// https://feathericons.com/?query=chevrons-left
            ChevronsLeft,
            /// https://feathericons.com/?query=chevrons-right
            ChevronsRight,
            /// https://feathericons.com/?query=chevrons-up
            ChevronsUp,
            /// https://feathericons.com/?query=chrome
            Chrome,
            /// https://feathericons.com/?query=circle
            Circle,
            /// https://feathericons.com/?query=clipboard
            Clipboard,
            /// https://feathericons.com/?query=clock
            Clock,
            /// https://feathericons.com/?query=cloud-drizzle
            CloudDrizzle,
            /// https://feathericons.com/?query=cloud-lightning
            CloudLightning,
            /// https://feathericons.com/?query=cloud-off
            CloudOff,
            /// https://feathericons.com/?query=cloud-rain
            CloudRain,
            /// https://feathericons.com/?query=cloud-snow
            CloudSnow,
            /// https://feathericons.com/?query=cloud
            Cloud,
            /// https://feathericons.com/?query=code
            Code,
            /// https://feathericons.com/?query=codepen
            Codepen,
            /// https://feathericons.com/?query=codesandbox
            Codesandbox,
            /// https://feathericons.com/?query=coffee
            Coffee,
            /// https://feathericons.com/?query=columns
            Columns,
            /// https://feathericons.com/?query=command
            Command,
            /// https://feathericons.com/?query=compass
            Compass,
            /// https://feathericons.com/?query=copy
            Copy,
            /// https://feathericons.com/?query=corner-down-left
            CornerDownLeft,
            /// https://feathericons.com/?query=corner-down-right
            CornerDownRight,
            /// https://feathericons.com/?query=corner-left-down
            CornerLeftDown,
            /// https://feathericons.com/?query=corner-left-up
            CornerLeftUp,
            /// https://feathericons.com/?query=corner-right-down
            CornerRightDown,
            /// https://feathericons.com/?query=corner-right-up
            CornerRightUp,
            /// https://feathericons.com/?query=corner-up-left
            CornerUpLeft,
            /// https://feathericons.com/?query=corner-up-right
            CornerUpRight,
            /// https://feathericons.com/?query=cpu
            Cpu,
            /// https://feathericons.com/?query=credit-card
            CreditCard,
            /// https://feathericons.com/?query=crop
            Crop,
            /// https://feathericons.com/?query=crosshair
            Crosshair,
            /// https://feathericons.com/?query=database
            Database,
            /// https://feathericons.com/?query=delete
            Delete,
            /// https://feathericons.com/?query=disc
            Disc,
            /// https://feathericons.com/?query=divide-circle
            DivideCircle,
            /// https://feathericons.com/?query=divide-square
            DivideSquare,
            /// https://feathericons.com/?query=divide
            Divide,
            /// https://feathericons.com/?query=dollar-sign
            DollarSign,
            /// https://feathericons.com/?query=download-cloud
            DownloadCloud,
            /// https://feathericons.com/?query=download
            Download,
            /// https://feathericons.com/?query=dribbble
            Dribbble,
            /// https://feathericons.com/?query=droplet
            Droplet,
            /// https://feathericons.com/?query=edit2
            Edit2,
            /// https://feathericons.com/?query=edit3
            Edit3,
            /// https://feathericons.com/?query=edit
            Edit,
            /// https://feathericons.com/?query=external-link
            ExternalLink,
            /// https://feathericons.com/?query=eye-off
            EyeOff,
            /// https://feathericons.com/?query=eye
            Eye,
            /// https://feathericons.com/?query=facebook
            Facebook,
            /// https://feathericons.com/?query=fast-forward
            FastForward,
            /// https://feathericons.com/?query=feather
            Feather,
            /// https://feathericons.com/?query=figma
            Figma,
            /// https://feathericons.com/?query=file-minus
            FileMinus,
            /// https://feathericons.com/?query=file-plus
            FilePlus,
            /// https://feathericons.com/?query=file-text
            FileText,
            /// https://feathericons.com/?query=file
            File,
            /// https://feathericons.com/?query=film
            Film,
            /// https://feathericons.com/?query=filter
            Filter,
            /// https://feathericons.com/?query=flag
            Flag,
            /// https://feathericons.com/?query=folder-minus
            FolderMinus,
            /// https://feathericons.com/?query=folder-plus
            FolderPlus,
            /// https://feathericons.com/?query=folder
            Folder,
            /// https://feathericons.com/?query=framer
            Framer,
            /// https://feathericons.com/?query=frown
            Frown,
            /// https://feathericons.com/?query=gift
            Gift,
            /// https://feathericons.com/?query=git-branch
            GitBranch,
            /// https://feathericons.com/?query=git-commit
            GitCommit,
            /// https://feathericons.com/?query=git-merge
            GitMerge,
            /// https://feathericons.com/?query=git-pull-request
            GitPullRequest,
            /// https://feathericons.com/?query=github
            Github,
            /// https://feathericons.com/?query=gitlab
            Gitlab,
            /// https://feathericons.com/?query=globe
            Globe,
            /// https://feathericons.com/?query=grid
            Grid,
            /// https://feathericons.com/?query=hard-drive
            HardDrive,
            /// https://feathericons.com/?query=hash
            Hash,
            /// https://feathericons.com/?query=headphones
            Headphones,
            /// https://feathericons.com/?query=heart
            Heart,
            /// https://feathericons.com/?query=help-circle
            HelpCircle,
            /// https://feathericons.com/?query=hexagon
            Hexagon,
            /// https://feathericons.com/?query=home
            Home,
            /// https://feathericons.com/?query=image
            Image,
            /// https://feathericons.com/?query=inbox
            Inbox,
            /// https://feathericons.com/?query=info
            Info,
            /// https://feathericons.com/?query=instagram
            Instagram,
            /// https://feathericons.com/?query=italic
            Italic,
            /// https://feathericons.com/?query=key
            Key,
            /// https://feathericons.com/?query=layers
            Layers,
            /// https://feathericons.com/?query=layout
            Layout,
            /// https://feathericons.com/?query=life-buoy
            LifeBuoy,
            /// https://feathericons.com/?query=link2
            Link2,
            /// https://feathericons.com/?query=link
            Link,
            /// https://feathericons.com/?query=linkedin
            Linkedin,
            /// https://feathericons.com/?query=list
            List,
            /// https://feathericons.com/?query=loader
            Loader,
            /// https://feathericons.com/?query=lock
            Lock,
            /// https://feathericons.com/?query=log-in
            LogIn,
            /// https://feathericons.com/?query=log-out
            LogOut,
            /// https://feathericons.com/?query=mail
            Mail,
            /// https://feathericons.com/?query=map-pin
            MapPin,
            /// https://feathericons.com/?query=map
            Map,
            /// https://feathericons.com/?query=maximize2
            Maximize2,
            /// https://feathericons.com/?query=maximize
            Maximize,
            /// https://feathericons.com/?query=meh
            Meh,
            /// https://feathericons.com/?query=menu
            Menu,
            /// https://feathericons.com/?query=message-circle
            MessageCircle,
            /// https://feathericons.com/?query=message-square
            MessageSquare,
            /// https://feathericons.com/?query=mic-off
            MicOff,
            /// https://feathericons.com/?query=mic
            Mic,
            /// https://feathericons.com/?query=minimize2
            Minimize2,
            /// https://feathericons.com/?query=minimize
            Minimize,
            /// https://feathericons.com/?query=minus-circle
            MinusCircle,
            /// https://feathericons.com/?query=minus-square
            MinusSquare,
            /// https://feathericons.com/?query=minus
            Minus,
            /// https://feathericons.com/?query=monitor
            Monitor,
            /// https://feathericons.com/?query=moon
            Moon,
            /// https://feathericons.com/?query=more-horizontal
            MoreHorizontal,
            /// https://feathericons.com/?query=more-vertical
            MoreVertical,
            /// https://feathericons.com/?query=mouse-pointer
            MousePointer,
            /// https://feathericons.com/?query=move
            Move,
            /// https://feathericons.com/?query=music
            Music,
            /// https://feathericons.com/?query=navigation2
            Navigation2,
            /// https://feathericons.com/?query=navigation
            Navigation,
            /// https://feathericons.com/?query=octagon
            Octagon,
            /// https://feathericons.com/?query=package
            Package,
            /// https://feathericons.com/?query=paperclip
            Paperclip,
            /// https://feathericons.com/?query=pause-circle
            PauseCircle,
            /// https://feathericons.com/?query=pause
            Pause,
            /// https://feathericons.com/?query=pen-tool
            PenTool,
            /// https://feathericons.com/?query=percent
            Percent,
            /// https://feathericons.com/?query=phone-call
            PhoneCall,
            /// https://feathericons.com/?query=phone-forwarded
            PhoneForwarded,
            /// https://feathericons.com/?query=phone-incoming
            PhoneIncoming,
            /// https://feathericons.com/?query=phone-missed
            PhoneMissed,
            /// https://feathericons.com/?query=phone-off
            PhoneOff,
            /// https://feathericons.com/?query=phone-outgoing
            PhoneOutgoing,
            /// https://feathericons.com/?query=phone
            Phone,
            /// https://feathericons.com/?query=pie-chart
            PieChart,
            /// https://feathericons.com/?query=play-circle
            PlayCircle,
            /// https://feathericons.com/?query=play
            Play,
            /// https://feathericons.com/?query=plus-circle
            PlusCircle,
            /// https://feathericons.com/?query=plus-square
            PlusSquare,
            /// https://feathericons.com/?query=plus
            Plus,
            /// https://feathericons.com/?query=pocket
            Pocket,
            /// https://feathericons.com/?query=power
            Power,
            /// https://feathericons.com/?query=printer
            Printer,
            /// https://feathericons.com/?query=radio
            Radio,
            /// https://feathericons.com/?query=refresh-ccw
            RefreshCcw,
            /// https://feathericons.com/?query=refresh-cw
            RefreshCw,
            /// https://feathericons.com/?query=repeat
            Repeat,
            /// https://feathericons.com/?query=rewind
            Rewind,
            /// https://feathericons.com/?query=rotate-ccw
            RotateCcw,
            /// https://feathericons.com/?query=rotate-cw
            RotateCw,
            /// https://feathericons.com/?query=rss
            Rss,
            /// https://feathericons.com/?query=save
            Save,
            /// https://feathericons.com/?query=scissors
            Scissors,
            /// https://feathericons.com/?query=search
            Search,
            /// https://feathericons.com/?query=send
            Send,
            /// https://feathericons.com/?query=server
            Server,
            /// https://feathericons.com/?query=settings
            Settings,
            /// https://feathericons.com/?query=share2
            Share2,
            /// https://feathericons.com/?query=share
            Share,
            /// https://feathericons.com/?query=shield-off
            ShieldOff,
            /// https://feathericons.com/?query=shield
            Shield,
            /// https://feathericons.com/?query=shopping-bag
            ShoppingBag,
            /// https://feathericons.com/?query=shopping-cart
            ShoppingCart,
            /// https://feathericons.com/?query=shuffle
            Shuffle,
            /// https://feathericons.com/?query=sidebar
            Sidebar,
            /// https://feathericons.com/?query=skip-back
            SkipBack,
            /// https://feathericons.com/?query=skip-forward
            SkipForward,
            /// https://feathericons.com/?query=slack
            Slack,
            /// https://feathericons.com/?query=slash
            Slash,
            /// https://feathericons.com/?query=sliders
            Sliders,
            /// https://feathericons.com/?query=smartphone
            Smartphone,
            /// https://feathericons.com/?query=smile
            Smile,
            /// https://feathericons.com/?query=speaker
            Speaker,
            /// https://feathericons.com/?query=square
            Square,
            /// https://feathericons.com/?query=star
            Star,
            /// https://feathericons.com/?query=stop-circle
            StopCircle,
            /// https://feathericons.com/?query=sun
            Sun,
            /// https://feathericons.com/?query=sunrise
            Sunrise,
            /// https://feathericons.com/?query=sunset
            Sunset,
            /// https://feathericons.com/?query=table
            Table,
            /// https://feathericons.com/?query=tablet
            Tablet,
            /// https://feathericons.com/?query=tag
            Tag,
            /// https://feathericons.com/?query=target
            Target,
            /// https://feathericons.com/?query=terminal
            Terminal,
            /// https://feathericons.com/?query=thermometer
            Thermometer,
            /// https://feathericons.com/?query=thumbs-down
            ThumbsDown,
            /// https://feathericons.com/?query=thumbs-up
            ThumbsUp,
            /// https://feathericons.com/?query=toggle-left
            ToggleLeft,
            /// https://feathericons.com/?query=toggle-right
            ToggleRight,
            /// https://feathericons.com/?query=tool
            Tool,
            /// https://feathericons.com/?query=trash2
            Trash2,
            /// https://feathericons.com/?query=trash
            Trash,
            /// https://feathericons.com/?query=trello
            Trello,
            /// https://feathericons.com/?query=trending-down
            TrendingDown,
            /// https://feathericons.com/?query=trending-up
            TrendingUp,
            /// https://feathericons.com/?query=triangle
            Triangle,
            /// https://feathericons.com/?query=truck
            Truck,
            /// https://feathericons.com/?query=tv
            Tv,
            /// https://feathericons.com/?query=twitch
            Twitch,
            /// https://feathericons.com/?query=twitter
            Twitter,
            /// https://feathericons.com/?query=type
            Type,
            /// https://feathericons.com/?query=umbrella
            Umbrella,
            /// https://feathericons.com/?query=underline
            Underline,
            /// https://feathericons.com/?query=unlock
            Unlock,
            /// https://feathericons.com/?query=upload-cloud
            UploadCloud,
            /// https://feathericons.com/?query=upload
            Upload,
            /// https://feathericons.com/?query=user-check
            UserCheck,
            /// https://feathericons.com/?query=user-minus
            UserMinus,
            /// https://feathericons.com/?query=user-plus
            UserPlus,
            /// https://feathericons.com/?query=user-x
            UserX,
            /// https://feathericons.com/?query=user
            User,
            /// https://feathericons.com/?query=users
            Users,
            /// https://feathericons.com/?query=video-off
            VideoOff,
            /// https://feathericons.com/?query=video
            Video,
            /// https://feathericons.com/?query=voicemail
            Voicemail,
            /// https://feathericons.com/?query=volume1
            Volume1,
            /// https://feathericons.com/?query=volume2
            Volume2,
            /// https://feathericons.com/?query=volume-x
            VolumeX,
            /// https://feathericons.com/?query=volume
            Volume,
            /// https://feathericons.com/?query=watch
            Watch,
            /// https://feathericons.com/?query=wifi-off
            WifiOff,
            /// https://feathericons.com/?query=wifi
            Wifi,
            /// https://feathericons.com/?query=wind
            Wind,
            /// https://feathericons.com/?query=x-circle
            XCircle,
            /// https://feathericons.com/?query=x-octagon
            XOctagon,
            /// https://feathericons.com/?query=x-square
            XSquare,
            /// https://feathericons.com/?query=x
            X,
            /// https://feathericons.com/?query=youtube
            Youtube,
            /// https://feathericons.com/?query=zap-off
            ZapOff,
            /// https://feathericons.com/?query=zap
            Zap,
            /// https://feathericons.com/?query=zoom-in
            ZoomIn,
            /// https://feathericons.com/?query=zoom-out
            ZoomOut,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IconType {
            #[inline]
            fn clone(&self) -> IconType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for IconType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IconType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        IconType::Activity => "Activity",
                        IconType::Airplay => "Airplay",
                        IconType::AlertCircle => "AlertCircle",
                        IconType::AlertOctagon => "AlertOctagon",
                        IconType::AlertTriangle => "AlertTriangle",
                        IconType::AlignCenter => "AlignCenter",
                        IconType::AlignJustify => "AlignJustify",
                        IconType::AlignLeft => "AlignLeft",
                        IconType::AlignRight => "AlignRight",
                        IconType::Anchor => "Anchor",
                        IconType::Aperture => "Aperture",
                        IconType::Archive => "Archive",
                        IconType::ArrowDownCircle => "ArrowDownCircle",
                        IconType::ArrowDownLeft => "ArrowDownLeft",
                        IconType::ArrowDownRight => "ArrowDownRight",
                        IconType::ArrowDown => "ArrowDown",
                        IconType::ArrowLeftCircle => "ArrowLeftCircle",
                        IconType::ArrowLeft => "ArrowLeft",
                        IconType::ArrowRightCircle => "ArrowRightCircle",
                        IconType::ArrowRight => "ArrowRight",
                        IconType::ArrowUpCircle => "ArrowUpCircle",
                        IconType::ArrowUpLeft => "ArrowUpLeft",
                        IconType::ArrowUpRight => "ArrowUpRight",
                        IconType::ArrowUp => "ArrowUp",
                        IconType::AtSign => "AtSign",
                        IconType::Award => "Award",
                        IconType::BarChart2 => "BarChart2",
                        IconType::BarChart => "BarChart",
                        IconType::BatteryCharging => "BatteryCharging",
                        IconType::Battery => "Battery",
                        IconType::BellOff => "BellOff",
                        IconType::Bell => "Bell",
                        IconType::Bluetooth => "Bluetooth",
                        IconType::Bold => "Bold",
                        IconType::BookOpen => "BookOpen",
                        IconType::Book => "Book",
                        IconType::Bookmark => "Bookmark",
                        IconType::Box => "Box",
                        IconType::Briefcase => "Briefcase",
                        IconType::Calendar => "Calendar",
                        IconType::CameraOff => "CameraOff",
                        IconType::Camera => "Camera",
                        IconType::Cast => "Cast",
                        IconType::CheckCircle => "CheckCircle",
                        IconType::CheckSquare => "CheckSquare",
                        IconType::Check => "Check",
                        IconType::ChevronDown => "ChevronDown",
                        IconType::ChevronLeft => "ChevronLeft",
                        IconType::ChevronRight => "ChevronRight",
                        IconType::ChevronUp => "ChevronUp",
                        IconType::ChevronsDown => "ChevronsDown",
                        IconType::ChevronsLeft => "ChevronsLeft",
                        IconType::ChevronsRight => "ChevronsRight",
                        IconType::ChevronsUp => "ChevronsUp",
                        IconType::Chrome => "Chrome",
                        IconType::Circle => "Circle",
                        IconType::Clipboard => "Clipboard",
                        IconType::Clock => "Clock",
                        IconType::CloudDrizzle => "CloudDrizzle",
                        IconType::CloudLightning => "CloudLightning",
                        IconType::CloudOff => "CloudOff",
                        IconType::CloudRain => "CloudRain",
                        IconType::CloudSnow => "CloudSnow",
                        IconType::Cloud => "Cloud",
                        IconType::Code => "Code",
                        IconType::Codepen => "Codepen",
                        IconType::Codesandbox => "Codesandbox",
                        IconType::Coffee => "Coffee",
                        IconType::Columns => "Columns",
                        IconType::Command => "Command",
                        IconType::Compass => "Compass",
                        IconType::Copy => "Copy",
                        IconType::CornerDownLeft => "CornerDownLeft",
                        IconType::CornerDownRight => "CornerDownRight",
                        IconType::CornerLeftDown => "CornerLeftDown",
                        IconType::CornerLeftUp => "CornerLeftUp",
                        IconType::CornerRightDown => "CornerRightDown",
                        IconType::CornerRightUp => "CornerRightUp",
                        IconType::CornerUpLeft => "CornerUpLeft",
                        IconType::CornerUpRight => "CornerUpRight",
                        IconType::Cpu => "Cpu",
                        IconType::CreditCard => "CreditCard",
                        IconType::Crop => "Crop",
                        IconType::Crosshair => "Crosshair",
                        IconType::Database => "Database",
                        IconType::Delete => "Delete",
                        IconType::Disc => "Disc",
                        IconType::DivideCircle => "DivideCircle",
                        IconType::DivideSquare => "DivideSquare",
                        IconType::Divide => "Divide",
                        IconType::DollarSign => "DollarSign",
                        IconType::DownloadCloud => "DownloadCloud",
                        IconType::Download => "Download",
                        IconType::Dribbble => "Dribbble",
                        IconType::Droplet => "Droplet",
                        IconType::Edit2 => "Edit2",
                        IconType::Edit3 => "Edit3",
                        IconType::Edit => "Edit",
                        IconType::ExternalLink => "ExternalLink",
                        IconType::EyeOff => "EyeOff",
                        IconType::Eye => "Eye",
                        IconType::Facebook => "Facebook",
                        IconType::FastForward => "FastForward",
                        IconType::Feather => "Feather",
                        IconType::Figma => "Figma",
                        IconType::FileMinus => "FileMinus",
                        IconType::FilePlus => "FilePlus",
                        IconType::FileText => "FileText",
                        IconType::File => "File",
                        IconType::Film => "Film",
                        IconType::Filter => "Filter",
                        IconType::Flag => "Flag",
                        IconType::FolderMinus => "FolderMinus",
                        IconType::FolderPlus => "FolderPlus",
                        IconType::Folder => "Folder",
                        IconType::Framer => "Framer",
                        IconType::Frown => "Frown",
                        IconType::Gift => "Gift",
                        IconType::GitBranch => "GitBranch",
                        IconType::GitCommit => "GitCommit",
                        IconType::GitMerge => "GitMerge",
                        IconType::GitPullRequest => "GitPullRequest",
                        IconType::Github => "Github",
                        IconType::Gitlab => "Gitlab",
                        IconType::Globe => "Globe",
                        IconType::Grid => "Grid",
                        IconType::HardDrive => "HardDrive",
                        IconType::Hash => "Hash",
                        IconType::Headphones => "Headphones",
                        IconType::Heart => "Heart",
                        IconType::HelpCircle => "HelpCircle",
                        IconType::Hexagon => "Hexagon",
                        IconType::Home => "Home",
                        IconType::Image => "Image",
                        IconType::Inbox => "Inbox",
                        IconType::Info => "Info",
                        IconType::Instagram => "Instagram",
                        IconType::Italic => "Italic",
                        IconType::Key => "Key",
                        IconType::Layers => "Layers",
                        IconType::Layout => "Layout",
                        IconType::LifeBuoy => "LifeBuoy",
                        IconType::Link2 => "Link2",
                        IconType::Link => "Link",
                        IconType::Linkedin => "Linkedin",
                        IconType::List => "List",
                        IconType::Loader => "Loader",
                        IconType::Lock => "Lock",
                        IconType::LogIn => "LogIn",
                        IconType::LogOut => "LogOut",
                        IconType::Mail => "Mail",
                        IconType::MapPin => "MapPin",
                        IconType::Map => "Map",
                        IconType::Maximize2 => "Maximize2",
                        IconType::Maximize => "Maximize",
                        IconType::Meh => "Meh",
                        IconType::Menu => "Menu",
                        IconType::MessageCircle => "MessageCircle",
                        IconType::MessageSquare => "MessageSquare",
                        IconType::MicOff => "MicOff",
                        IconType::Mic => "Mic",
                        IconType::Minimize2 => "Minimize2",
                        IconType::Minimize => "Minimize",
                        IconType::MinusCircle => "MinusCircle",
                        IconType::MinusSquare => "MinusSquare",
                        IconType::Minus => "Minus",
                        IconType::Monitor => "Monitor",
                        IconType::Moon => "Moon",
                        IconType::MoreHorizontal => "MoreHorizontal",
                        IconType::MoreVertical => "MoreVertical",
                        IconType::MousePointer => "MousePointer",
                        IconType::Move => "Move",
                        IconType::Music => "Music",
                        IconType::Navigation2 => "Navigation2",
                        IconType::Navigation => "Navigation",
                        IconType::Octagon => "Octagon",
                        IconType::Package => "Package",
                        IconType::Paperclip => "Paperclip",
                        IconType::PauseCircle => "PauseCircle",
                        IconType::Pause => "Pause",
                        IconType::PenTool => "PenTool",
                        IconType::Percent => "Percent",
                        IconType::PhoneCall => "PhoneCall",
                        IconType::PhoneForwarded => "PhoneForwarded",
                        IconType::PhoneIncoming => "PhoneIncoming",
                        IconType::PhoneMissed => "PhoneMissed",
                        IconType::PhoneOff => "PhoneOff",
                        IconType::PhoneOutgoing => "PhoneOutgoing",
                        IconType::Phone => "Phone",
                        IconType::PieChart => "PieChart",
                        IconType::PlayCircle => "PlayCircle",
                        IconType::Play => "Play",
                        IconType::PlusCircle => "PlusCircle",
                        IconType::PlusSquare => "PlusSquare",
                        IconType::Plus => "Plus",
                        IconType::Pocket => "Pocket",
                        IconType::Power => "Power",
                        IconType::Printer => "Printer",
                        IconType::Radio => "Radio",
                        IconType::RefreshCcw => "RefreshCcw",
                        IconType::RefreshCw => "RefreshCw",
                        IconType::Repeat => "Repeat",
                        IconType::Rewind => "Rewind",
                        IconType::RotateCcw => "RotateCcw",
                        IconType::RotateCw => "RotateCw",
                        IconType::Rss => "Rss",
                        IconType::Save => "Save",
                        IconType::Scissors => "Scissors",
                        IconType::Search => "Search",
                        IconType::Send => "Send",
                        IconType::Server => "Server",
                        IconType::Settings => "Settings",
                        IconType::Share2 => "Share2",
                        IconType::Share => "Share",
                        IconType::ShieldOff => "ShieldOff",
                        IconType::Shield => "Shield",
                        IconType::ShoppingBag => "ShoppingBag",
                        IconType::ShoppingCart => "ShoppingCart",
                        IconType::Shuffle => "Shuffle",
                        IconType::Sidebar => "Sidebar",
                        IconType::SkipBack => "SkipBack",
                        IconType::SkipForward => "SkipForward",
                        IconType::Slack => "Slack",
                        IconType::Slash => "Slash",
                        IconType::Sliders => "Sliders",
                        IconType::Smartphone => "Smartphone",
                        IconType::Smile => "Smile",
                        IconType::Speaker => "Speaker",
                        IconType::Square => "Square",
                        IconType::Star => "Star",
                        IconType::StopCircle => "StopCircle",
                        IconType::Sun => "Sun",
                        IconType::Sunrise => "Sunrise",
                        IconType::Sunset => "Sunset",
                        IconType::Table => "Table",
                        IconType::Tablet => "Tablet",
                        IconType::Tag => "Tag",
                        IconType::Target => "Target",
                        IconType::Terminal => "Terminal",
                        IconType::Thermometer => "Thermometer",
                        IconType::ThumbsDown => "ThumbsDown",
                        IconType::ThumbsUp => "ThumbsUp",
                        IconType::ToggleLeft => "ToggleLeft",
                        IconType::ToggleRight => "ToggleRight",
                        IconType::Tool => "Tool",
                        IconType::Trash2 => "Trash2",
                        IconType::Trash => "Trash",
                        IconType::Trello => "Trello",
                        IconType::TrendingDown => "TrendingDown",
                        IconType::TrendingUp => "TrendingUp",
                        IconType::Triangle => "Triangle",
                        IconType::Truck => "Truck",
                        IconType::Tv => "Tv",
                        IconType::Twitch => "Twitch",
                        IconType::Twitter => "Twitter",
                        IconType::Type => "Type",
                        IconType::Umbrella => "Umbrella",
                        IconType::Underline => "Underline",
                        IconType::Unlock => "Unlock",
                        IconType::UploadCloud => "UploadCloud",
                        IconType::Upload => "Upload",
                        IconType::UserCheck => "UserCheck",
                        IconType::UserMinus => "UserMinus",
                        IconType::UserPlus => "UserPlus",
                        IconType::UserX => "UserX",
                        IconType::User => "User",
                        IconType::Users => "Users",
                        IconType::VideoOff => "VideoOff",
                        IconType::Video => "Video",
                        IconType::Voicemail => "Voicemail",
                        IconType::Volume1 => "Volume1",
                        IconType::Volume2 => "Volume2",
                        IconType::VolumeX => "VolumeX",
                        IconType::Volume => "Volume",
                        IconType::Watch => "Watch",
                        IconType::WifiOff => "WifiOff",
                        IconType::Wifi => "Wifi",
                        IconType::Wind => "Wind",
                        IconType::XCircle => "XCircle",
                        IconType::XOctagon => "XOctagon",
                        IconType::XSquare => "XSquare",
                        IconType::X => "X",
                        IconType::Youtube => "Youtube",
                        IconType::ZapOff => "ZapOff",
                        IconType::Zap => "Zap",
                        IconType::ZoomIn => "ZoomIn",
                        IconType::ZoomOut => "ZoomOut",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for IconType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for IconType {
            #[inline]
            fn eq(&self, other: &IconType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for IconType {}
        #[automatically_derived]
        impl ::core::cmp::Eq for IconType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for IconType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl Display for IconType {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(
                    format_args!(
                        "{0}",
                        match self {
                            Self::Activity => "activity",
                            Self::Airplay => "airplay",
                            Self::AlertCircle => "alert-circle",
                            Self::AlertOctagon => "alert-octagon",
                            Self::AlertTriangle => "alert-triangle",
                            Self::AlignCenter => "align-center",
                            Self::AlignJustify => "align-justify",
                            Self::AlignLeft => "align-left",
                            Self::AlignRight => "align-right",
                            Self::Anchor => "anchor",
                            Self::Aperture => "aperture",
                            Self::Archive => "archive",
                            Self::ArrowDownCircle => "arrow-down-circle",
                            Self::ArrowDownLeft => "arrow-down-left",
                            Self::ArrowDownRight => "arrow-down-right",
                            Self::ArrowDown => "arrow-down",
                            Self::ArrowLeftCircle => "arrow-left-circle",
                            Self::ArrowLeft => "arrow-left",
                            Self::ArrowRightCircle => "arrow-right-circle",
                            Self::ArrowRight => "arrow-right",
                            Self::ArrowUpCircle => "arrow-up-circle",
                            Self::ArrowUpLeft => "arrow-up-left",
                            Self::ArrowUpRight => "arrow-up-right",
                            Self::ArrowUp => "arrow-up",
                            Self::AtSign => "at-sign",
                            Self::Award => "award",
                            Self::BarChart2 => "bar-chart-2",
                            Self::BarChart => "bar-chart",
                            Self::BatteryCharging => "battery-charging",
                            Self::Battery => "battery",
                            Self::BellOff => "bell-off",
                            Self::Bell => "bell",
                            Self::Bluetooth => "bluetooth",
                            Self::Bold => "bold",
                            Self::BookOpen => "book-open",
                            Self::Book => "book",
                            Self::Bookmark => "bookmark",
                            Self::Box => "box",
                            Self::Briefcase => "briefcase",
                            Self::Calendar => "calendar",
                            Self::CameraOff => "camera-off",
                            Self::Camera => "camera",
                            Self::Cast => "cast",
                            Self::CheckCircle => "check-circle",
                            Self::CheckSquare => "check-square",
                            Self::Check => "check",
                            Self::ChevronDown => "chevron-down",
                            Self::ChevronLeft => "chevron-left",
                            Self::ChevronRight => "chevron-right",
                            Self::ChevronUp => "chevron-up",
                            Self::ChevronsDown => "chevrons-down",
                            Self::ChevronsLeft => "chevrons-left",
                            Self::ChevronsRight => "chevrons-right",
                            Self::ChevronsUp => "chevrons-up",
                            Self::Chrome => "chrome",
                            Self::Circle => "circle",
                            Self::Clipboard => "clipboard",
                            Self::Clock => "clock",
                            Self::CloudDrizzle => "cloud-drizzle",
                            Self::CloudLightning => "cloud-lightning",
                            Self::CloudOff => "cloud-off",
                            Self::CloudRain => "cloud-rain",
                            Self::CloudSnow => "cloud-snow",
                            Self::Cloud => "cloud",
                            Self::Code => "code",
                            Self::Codepen => "codepen",
                            Self::Codesandbox => "codesandbox",
                            Self::Coffee => "coffee",
                            Self::Columns => "columns",
                            Self::Command => "command",
                            Self::Compass => "compass",
                            Self::Copy => "copy",
                            Self::CornerDownLeft => "corner-down-left",
                            Self::CornerDownRight => "corner-down-right",
                            Self::CornerLeftDown => "corner-left-down",
                            Self::CornerLeftUp => "corner-left-up",
                            Self::CornerRightDown => "corner-right-down",
                            Self::CornerRightUp => "corner-right-up",
                            Self::CornerUpLeft => "corner-up-left",
                            Self::CornerUpRight => "corner-up-right",
                            Self::Cpu => "cpu",
                            Self::CreditCard => "credit-card",
                            Self::Crop => "crop",
                            Self::Crosshair => "crosshair",
                            Self::Database => "database",
                            Self::Delete => "delete",
                            Self::Disc => "disc",
                            Self::DivideCircle => "divide-circle",
                            Self::DivideSquare => "divide-square",
                            Self::Divide => "divide",
                            Self::DollarSign => "dollar-sign",
                            Self::DownloadCloud => "download-cloud",
                            Self::Download => "download",
                            Self::Dribbble => "dribbble",
                            Self::Droplet => "droplet",
                            Self::Edit2 => "edit-2",
                            Self::Edit3 => "edit-3",
                            Self::Edit => "edit",
                            Self::ExternalLink => "external-link",
                            Self::EyeOff => "eye-off",
                            Self::Eye => "eye",
                            Self::Facebook => "facebook",
                            Self::FastForward => "fast-forward",
                            Self::Feather => "feather",
                            Self::Figma => "figma",
                            Self::FileMinus => "file-minus",
                            Self::FilePlus => "file-plus",
                            Self::FileText => "file-text",
                            Self::File => "file",
                            Self::Film => "film",
                            Self::Filter => "filter",
                            Self::Flag => "flag",
                            Self::FolderMinus => "folder-minus",
                            Self::FolderPlus => "folder-plus",
                            Self::Folder => "folder",
                            Self::Framer => "framer",
                            Self::Frown => "frown",
                            Self::Gift => "gift",
                            Self::GitBranch => "git-branch",
                            Self::GitCommit => "git-commit",
                            Self::GitMerge => "git-merge",
                            Self::GitPullRequest => "git-pull-request",
                            Self::Github => "github",
                            Self::Gitlab => "gitlab",
                            Self::Globe => "globe",
                            Self::Grid => "grid",
                            Self::HardDrive => "hard-drive",
                            Self::Hash => "hash",
                            Self::Headphones => "headphones",
                            Self::Heart => "heart",
                            Self::HelpCircle => "help-circle",
                            Self::Hexagon => "hexagon",
                            Self::Home => "home",
                            Self::Image => "image",
                            Self::Inbox => "inbox",
                            Self::Info => "info",
                            Self::Instagram => "instagram",
                            Self::Italic => "italic",
                            Self::Key => "key",
                            Self::Layers => "layers",
                            Self::Layout => "layout",
                            Self::LifeBuoy => "life-buoy",
                            Self::Link2 => "link-2",
                            Self::Link => "link",
                            Self::Linkedin => "linkedin",
                            Self::List => "list",
                            Self::Loader => "loader",
                            Self::Lock => "lock",
                            Self::LogIn => "log-in",
                            Self::LogOut => "log-out",
                            Self::Mail => "mail",
                            Self::MapPin => "map-pin",
                            Self::Map => "map",
                            Self::Maximize2 => "maximize-2",
                            Self::Maximize => "maximize",
                            Self::Meh => "meh",
                            Self::Menu => "menu",
                            Self::MessageCircle => "message-circle",
                            Self::MessageSquare => "message-square",
                            Self::MicOff => "mic-off",
                            Self::Mic => "mic",
                            Self::Minimize2 => "minimize-2",
                            Self::Minimize => "minimize",
                            Self::MinusCircle => "minus-circle",
                            Self::MinusSquare => "minus-square",
                            Self::Minus => "minus",
                            Self::Monitor => "monitor",
                            Self::Moon => "moon",
                            Self::MoreHorizontal => "more-horizontal",
                            Self::MoreVertical => "more-vertical",
                            Self::MousePointer => "mouse-pointer",
                            Self::Move => "move",
                            Self::Music => "music",
                            Self::Navigation2 => "navigation-2",
                            Self::Navigation => "navigation",
                            Self::Octagon => "octagon",
                            Self::Package => "package",
                            Self::Paperclip => "paperclip",
                            Self::PauseCircle => "pause-circle",
                            Self::Pause => "pause",
                            Self::PenTool => "pen-tool",
                            Self::Percent => "percent",
                            Self::PhoneCall => "phone-call",
                            Self::PhoneForwarded => "phone-forwarded",
                            Self::PhoneIncoming => "phone-incoming",
                            Self::PhoneMissed => "phone-missed",
                            Self::PhoneOff => "phone-off",
                            Self::PhoneOutgoing => "phone-outgoing",
                            Self::Phone => "phone",
                            Self::PieChart => "pie-chart",
                            Self::PlayCircle => "play-circle",
                            Self::Play => "play",
                            Self::PlusCircle => "plus-circle",
                            Self::PlusSquare => "plus-square",
                            Self::Plus => "plus",
                            Self::Pocket => "pocket",
                            Self::Power => "power",
                            Self::Printer => "printer",
                            Self::Radio => "radio",
                            Self::RefreshCcw => "refresh-ccw",
                            Self::RefreshCw => "refresh-cw",
                            Self::Repeat => "repeat",
                            Self::Rewind => "rewind",
                            Self::RotateCcw => "rotate-ccw",
                            Self::RotateCw => "rotate-cw",
                            Self::Rss => "rss",
                            Self::Save => "save",
                            Self::Scissors => "scissors",
                            Self::Search => "search",
                            Self::Send => "send",
                            Self::Server => "server",
                            Self::Settings => "settings",
                            Self::Share2 => "share-2",
                            Self::Share => "share",
                            Self::ShieldOff => "shield-off",
                            Self::Shield => "shield",
                            Self::ShoppingBag => "shopping-bag",
                            Self::ShoppingCart => "shopping-cart",
                            Self::Shuffle => "shuffle",
                            Self::Sidebar => "sidebar",
                            Self::SkipBack => "skip-back",
                            Self::SkipForward => "skip-forward",
                            Self::Slack => "slack",
                            Self::Slash => "slash",
                            Self::Sliders => "sliders",
                            Self::Smartphone => "smartphone",
                            Self::Smile => "smile",
                            Self::Speaker => "speaker",
                            Self::Square => "square",
                            Self::Star => "star",
                            Self::StopCircle => "stop-circle",
                            Self::Sun => "sun",
                            Self::Sunrise => "sunrise",
                            Self::Sunset => "sunset",
                            Self::Table => "table",
                            Self::Tablet => "tablet",
                            Self::Tag => "tag",
                            Self::Target => "target",
                            Self::Terminal => "terminal",
                            Self::Thermometer => "thermometer",
                            Self::ThumbsDown => "thumbs-down",
                            Self::ThumbsUp => "thumbs-up",
                            Self::ToggleLeft => "toggle-left",
                            Self::ToggleRight => "toggle-right",
                            Self::Tool => "tool",
                            Self::Trash2 => "trash-2",
                            Self::Trash => "trash",
                            Self::Trello => "trello",
                            Self::TrendingDown => "trending-down",
                            Self::TrendingUp => "trending-up",
                            Self::Triangle => "triangle",
                            Self::Truck => "truck",
                            Self::Tv => "tv",
                            Self::Twitch => "twitch",
                            Self::Twitter => "twitter",
                            Self::Type => "type",
                            Self::Umbrella => "umbrella",
                            Self::Underline => "underline",
                            Self::Unlock => "unlock",
                            Self::UploadCloud => "upload-cloud",
                            Self::Upload => "upload",
                            Self::UserCheck => "user-check",
                            Self::UserMinus => "user-minus",
                            Self::UserPlus => "user-plus",
                            Self::UserX => "user-x",
                            Self::User => "user",
                            Self::Users => "users",
                            Self::VideoOff => "video-off",
                            Self::Video => "video",
                            Self::Voicemail => "voicemail",
                            Self::Volume1 => "volume-1",
                            Self::Volume2 => "volume-2",
                            Self::VolumeX => "volume-x",
                            Self::Volume => "volume",
                            Self::Watch => "watch",
                            Self::WifiOff => "wifi-off",
                            Self::Wifi => "wifi",
                            Self::Wind => "wind",
                            Self::XCircle => "x-circle",
                            Self::XOctagon => "x-octagon",
                            Self::XSquare => "x-square",
                            Self::X => "x",
                            Self::Youtube => "youtube",
                            Self::ZapOff => "zap-off",
                            Self::Zap => "zap",
                            Self::ZoomIn => "zoom-in",
                            Self::ZoomOut => "zoom-out",
                        },
                    ),
                )
            }
        }
        ///Props for the [`Icon`] component.
        ///
        /// Icon component. Used to display icons from the Feather icon set.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  scope of the component
        ///- **icon**: [`impl Into<MaybeSignal<IconType>>`](MaybeSignal<IconType>)
        ///    -  name of the icon to display
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  class name to apply to the icon
        ///- **color**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  text color of the icon
        ///- **fill**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  fill color of the icon
        ///- **size**: [`impl Into<MaybeSignal<Size>>`](MaybeSignal<Size>)
        ///    -  size of the icon
        ///- **enable_pulse**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether to enable the pulse animation
        ///- **on_click**: [`Rc<dyn Fn(&ev::MouseEvent)>`]
        ///    -  click handler
        #[builder(doc)]
        pub struct IconProps {
            /// name of the icon to display
            #[builder(
                setter(
                    doc = "**icon**: `impl`[`Into<MaybeSignal<IconType>>`]\n\n name of the icon to display"
                )
            )]
            #[builder(setter(into))]
            pub icon: MaybeSignal<IconType>,
            /// class name to apply to the icon
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n class name to apply to the icon"
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
            /// text color of the icon
            #[builder(
                setter(
                    doc = "**color**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n text color of the icon"
                )
            )]
            #[builder(default_code = "White.into()", setter(into))]
            pub color: MaybeSignal<PatrColor>,
            /// fill color of the icon
            #[builder(
                setter(
                    doc = "**fill**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n fill color of the icon"
                )
            )]
            #[builder(default, setter(into))]
            pub fill: MaybeSignal<PatrColor>,
            /// size of the icon
            #[builder(
                setter(
                    doc = "**size**: `impl`[`Into<MaybeSignal<Size>>`]\n\n size of the icon"
                )
            )]
            #[builder(default, setter(into))]
            pub size: MaybeSignal<Size>,
            /// Whether to enable the pulse animation
            #[builder(
                setter(
                    doc = "**enable_pulse**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether to enable the pulse animation"
                )
            )]
            #[builder(default, setter(into))]
            pub enable_pulse: MaybeSignal<bool>,
            /// click handler
            #[builder(
                setter(
                    doc = "**on_click**: [`Rc<dyn Fn(&ev::MouseEvent)>`]\n\n click handler"
                )
            )]
            #[builder(default, setter(strip_option))]
            pub on_click: Option<Rc<dyn Fn(&ev::MouseEvent)>>,
        }
        impl IconProps {
            /**
                Create a builder for building `IconProps`.
                On the builder, call `.icon(...)`, `.class(...)`(optional), `.color(...)`(optional), `.fill(...)`(optional), `.size(...)`(optional), `.enable_pulse(...)`(optional), `.on_click(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `IconProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> IconPropsBuilder<((), (), (), (), (), (), ())> {
                IconPropsBuilder {
                    fields: ((), (), (), (), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`IconProps`] instances.

See [`IconProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct IconPropsBuilder<TypedBuilderFields = ((), (), (), (), (), (), ())> {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for IconPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait IconPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> IconPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> IconPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class,
            __color,
            __fill,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            ((), __class, __color, __fill, __size, __enable_pulse, __on_click),
        > {
            #[doc = "**icon**: `impl`[`Into<MaybeSignal<IconType>>`]\n\n name of the icon to display"]
            pub fn icon(
                self,
                icon: impl ::core::convert::Into<MaybeSignal<IconType>>,
            ) -> IconPropsBuilder<
                (
                    (MaybeSignal<IconType>,),
                    __class,
                    __color,
                    __fill,
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                let icon = (icon.into(),);
                let (_, class, color, fill, size, enable_pulse, on_click) = self.fields;
                IconPropsBuilder {
                    fields: (icon, class, color, fill, size, enable_pulse, on_click),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Repeated_field_icon {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class,
            __color,
            __fill,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (
                (MaybeSignal<IconType>,),
                __class,
                __color,
                __fill,
                __size,
                __enable_pulse,
                __on_click,
            ),
        > {
            #[deprecated(note = "Repeated field icon")]
            pub fn icon(
                self,
                _: IconPropsBuilder_Error_Repeated_field_icon,
            ) -> IconPropsBuilder<
                (
                    (MaybeSignal<IconType>,),
                    __class,
                    __color,
                    __fill,
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __color,
            __fill,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (__icon, (), __color, __fill, __size, __enable_pulse, __on_click),
        > {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n class name to apply to the icon"]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    (MaybeSignal<String>,),
                    __color,
                    __fill,
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                let class = (class.into(),);
                let (icon, _, color, fill, size, enable_pulse, on_click) = self.fields;
                IconPropsBuilder {
                    fields: (icon, class, color, fill, size, enable_pulse, on_click),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __color,
            __fill,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (
                __icon,
                (MaybeSignal<String>,),
                __color,
                __fill,
                __size,
                __enable_pulse,
                __on_click,
            ),
        > {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: IconPropsBuilder_Error_Repeated_field_class,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    (MaybeSignal<String>,),
                    __color,
                    __fill,
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __fill,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (__icon, __class, (), __fill, __size, __enable_pulse, __on_click),
        > {
            #[doc = "**color**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n text color of the icon"]
            pub fn color(
                self,
                color: impl ::core::convert::Into<MaybeSignal<PatrColor>>,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    (MaybeSignal<PatrColor>,),
                    __fill,
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                let color = (color.into(),);
                let (icon, class, _, fill, size, enable_pulse, on_click) = self.fields;
                IconPropsBuilder {
                    fields: (icon, class, color, fill, size, enable_pulse, on_click),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Repeated_field_color {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __fill,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (
                __icon,
                __class,
                (MaybeSignal<PatrColor>,),
                __fill,
                __size,
                __enable_pulse,
                __on_click,
            ),
        > {
            #[deprecated(note = "Repeated field color")]
            pub fn color(
                self,
                _: IconPropsBuilder_Error_Repeated_field_color,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    (MaybeSignal<PatrColor>,),
                    __fill,
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (__icon, __class, __color, (), __size, __enable_pulse, __on_click),
        > {
            #[doc = "**fill**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n fill color of the icon"]
            pub fn fill(
                self,
                fill: impl ::core::convert::Into<MaybeSignal<PatrColor>>,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    (MaybeSignal<PatrColor>,),
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                let fill = (fill.into(),);
                let (icon, class, color, _, size, enable_pulse, on_click) = self.fields;
                IconPropsBuilder {
                    fields: (icon, class, color, fill, size, enable_pulse, on_click),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Repeated_field_fill {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (
                __icon,
                __class,
                __color,
                (MaybeSignal<PatrColor>,),
                __size,
                __enable_pulse,
                __on_click,
            ),
        > {
            #[deprecated(note = "Repeated field fill")]
            pub fn fill(
                self,
                _: IconPropsBuilder_Error_Repeated_field_fill,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    (MaybeSignal<PatrColor>,),
                    __size,
                    __enable_pulse,
                    __on_click,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __fill,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (__icon, __class, __color, __fill, (), __enable_pulse, __on_click),
        > {
            #[doc = "**size**: `impl`[`Into<MaybeSignal<Size>>`]\n\n size of the icon"]
            pub fn size(
                self,
                size: impl ::core::convert::Into<MaybeSignal<Size>>,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    __fill,
                    (MaybeSignal<Size>,),
                    __enable_pulse,
                    __on_click,
                ),
            > {
                let size = (size.into(),);
                let (icon, class, color, fill, _, enable_pulse, on_click) = self.fields;
                IconPropsBuilder {
                    fields: (icon, class, color, fill, size, enable_pulse, on_click),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Repeated_field_size {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __fill,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            (
                __icon,
                __class,
                __color,
                __fill,
                (MaybeSignal<Size>,),
                __enable_pulse,
                __on_click,
            ),
        > {
            #[deprecated(note = "Repeated field size")]
            pub fn size(
                self,
                _: IconPropsBuilder_Error_Repeated_field_size,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    __fill,
                    (MaybeSignal<Size>,),
                    __enable_pulse,
                    __on_click,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __fill,
            __size,
            __on_click,
        > IconPropsBuilder<(__icon, __class, __color, __fill, __size, (), __on_click)> {
            #[doc = "**enable_pulse**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether to enable the pulse animation"]
            pub fn enable_pulse(
                self,
                enable_pulse: impl ::core::convert::Into<MaybeSignal<bool>>,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    __fill,
                    __size,
                    (MaybeSignal<bool>,),
                    __on_click,
                ),
            > {
                let enable_pulse = (enable_pulse.into(),);
                let (icon, class, color, fill, size, _, on_click) = self.fields;
                IconPropsBuilder {
                    fields: (icon, class, color, fill, size, enable_pulse, on_click),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Repeated_field_enable_pulse {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __fill,
            __size,
            __on_click,
        > IconPropsBuilder<
            (__icon, __class, __color, __fill, __size, (MaybeSignal<bool>,), __on_click),
        > {
            #[deprecated(note = "Repeated field enable_pulse")]
            pub fn enable_pulse(
                self,
                _: IconPropsBuilder_Error_Repeated_field_enable_pulse,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    __fill,
                    __size,
                    (MaybeSignal<bool>,),
                    __on_click,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __fill,
            __size,
            __enable_pulse,
        > IconPropsBuilder<
            (__icon, __class, __color, __fill, __size, __enable_pulse, ()),
        > {
            #[doc = "**on_click**: [`Rc<dyn Fn(&ev::MouseEvent)>`]\n\n click handler"]
            pub fn on_click(
                self,
                on_click: Rc<dyn Fn(&ev::MouseEvent)>,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    __fill,
                    __size,
                    __enable_pulse,
                    (Option<Rc<dyn Fn(&ev::MouseEvent)>>,),
                ),
            > {
                let on_click = (Some(on_click),);
                let (icon, class, color, fill, size, enable_pulse, _) = self.fields;
                IconPropsBuilder {
                    fields: (icon, class, color, fill, size, enable_pulse, on_click),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Repeated_field_on_click {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __icon,
            __class,
            __color,
            __fill,
            __size,
            __enable_pulse,
        > IconPropsBuilder<
            (
                __icon,
                __class,
                __color,
                __fill,
                __size,
                __enable_pulse,
                (Option<Rc<dyn Fn(&ev::MouseEvent)>>,),
            ),
        > {
            #[deprecated(note = "Repeated field on_click")]
            pub fn on_click(
                self,
                _: IconPropsBuilder_Error_Repeated_field_on_click,
            ) -> IconPropsBuilder<
                (
                    __icon,
                    __class,
                    __color,
                    __fill,
                    __size,
                    __enable_pulse,
                    (Option<Rc<dyn Fn(&ev::MouseEvent)>>,),
                ),
            > {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum IconPropsBuilder_Error_Missing_required_field_icon {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            __class,
            __color,
            __fill,
            __size,
            __enable_pulse,
            __on_click,
        > IconPropsBuilder<
            ((), __class, __color, __fill, __size, __enable_pulse, __on_click),
        > {
            #[deprecated(note = "Missing required field icon")]
            pub fn build(
                self,
                _: IconPropsBuilder_Error_Missing_required_field_icon,
            ) -> IconProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class: IconPropsBuilder_Optional<MaybeSignal<String>>,
            __color: IconPropsBuilder_Optional<MaybeSignal<PatrColor>>,
            __fill: IconPropsBuilder_Optional<MaybeSignal<PatrColor>>,
            __size: IconPropsBuilder_Optional<MaybeSignal<Size>>,
            __enable_pulse: IconPropsBuilder_Optional<MaybeSignal<bool>>,
            __on_click: IconPropsBuilder_Optional<Option<Rc<dyn Fn(&ev::MouseEvent)>>>,
        > IconPropsBuilder<
            (
                (MaybeSignal<IconType>,),
                __class,
                __color,
                __fill,
                __size,
                __enable_pulse,
                __on_click,
            ),
        > {
            ///Finalise the builder and create its [`IconProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> IconProps {
                let (icon, class, color, fill, size, enable_pulse, on_click) = self
                    .fields;
                let icon = icon.0;
                let class = IconPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                let color = IconPropsBuilder_Optional::into_value(
                    color,
                    || White.into(),
                );
                let fill = IconPropsBuilder_Optional::into_value(
                    fill,
                    || ::core::default::Default::default(),
                );
                let size = IconPropsBuilder_Optional::into_value(
                    size,
                    || ::core::default::Default::default(),
                );
                let enable_pulse = IconPropsBuilder_Optional::into_value(
                    enable_pulse,
                    || ::core::default::Default::default(),
                );
                let on_click = IconPropsBuilder_Optional::into_value(
                    on_click,
                    || ::core::default::Default::default(),
                );
                IconProps {
                    icon,
                    class,
                    color,
                    fill,
                    size,
                    enable_pulse,
                    on_click,
                }
                    .into()
            }
        }
        impl ::leptos::Props for IconProps {
            type Builder = IconPropsBuilder;
            fn builder() -> Self::Builder {
                IconProps::builder()
            }
        }
        impl ::leptos::IntoView for IconProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Icon(cx, self).into_view(cx)
            }
        }
        /// Icon component. Used to display icons from the Feather icon set.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  scope of the component
        ///- **icon**: [`impl Into<MaybeSignal<IconType>>`](MaybeSignal<IconType>)
        ///    -  name of the icon to display
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  class name to apply to the icon
        ///- **color**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  text color of the icon
        ///- **fill**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  fill color of the icon
        ///- **size**: [`impl Into<MaybeSignal<Size>>`](MaybeSignal<Size>)
        ///    -  size of the icon
        ///- **enable_pulse**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether to enable the pulse animation
        ///- **on_click**: [`Rc<dyn Fn(&ev::MouseEvent)>`]
        ///    -  click handler
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Icon(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: IconProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Icon />",
                                    "frontend::components::icon",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/icon.rs"),
                                    Some(884u32),
                                    Some("frontend::components::icon"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Icon(
                            cx: Scope,
                            icon: MaybeSignal<IconType>,
                            class: MaybeSignal<String>,
                            color: MaybeSignal<PatrColor>,
                            fill: MaybeSignal<PatrColor>,
                            size: MaybeSignal<Size>,
                            enable_pulse: MaybeSignal<bool>,
                            on_click: Option<Rc<dyn Fn(&ev::MouseEvent)>>,
                        ) -> impl IntoView {
                            let is_clickable = on_click.is_some();
                            {
                                {
                                    let _ = ::leptos::leptos_dom::svg::svg;
                                    ::leptos::leptos_dom::svg::svg(cx)
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                move || {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!(
                                                            "icon {0} {1} icon-fill-{2} icon-{3} {4} {5}",
                                                            if enable_pulse.get() { "pulse" } else { "" },
                                                            color.get().as_text_color().as_css_color(),
                                                            fill.get().as_css_name(),
                                                            size.get().as_css_name(),
                                                            if is_clickable { "cursor-pointer" } else { "" },
                                                            class.get(),
                                                        ),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                        .on(
                                            ::leptos::ev::click,
                                            move |ev| {
                                                if let Some(click) = on_click.clone() {
                                                    click(&ev)
                                                }
                                            },
                                        )
                                        .child((
                                            cx,
                                            {
                                                ::leptos::leptos_dom::svg::use_(cx)
                                                    .attr(
                                                        "href",
                                                        (
                                                            cx,
                                                            {
                                                                move || {
                                                                    let res = ::alloc::fmt::format(
                                                                        format_args!("{0}#{1}", constants::FEATHER_IMG, icon.get()),
                                                                    );
                                                                    res
                                                                }
                                                            },
                                                        ),
                                                    )
                                            },
                                        ))
                                }
                            }
                        }
                        let IconProps {
                            icon,
                            class,
                            color,
                            fill,
                            size,
                            enable_pulse,
                            on_click,
                        } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Icon",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "icon",
                                        value: std::cell::Cell::new(Some(&icon)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "color",
                                        value: std::cell::Cell::new(Some(&color)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "fill",
                                        value: std::cell::Cell::new(Some(&fill)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "size",
                                        value: std::cell::Cell::new(Some(&size)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "enable_pulse",
                                        value: std::cell::Cell::new(Some(&enable_pulse)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "on_click",
                                        value: std::cell::Cell::new(Some(&on_click)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::icon",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/icon.rs"),
                                                    Some(884u32),
                                                    Some("frontend::components::icon"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Icon(
                                    cx,
                                    icon,
                                    class,
                                    color,
                                    fill,
                                    size,
                                    enable_pulse,
                                    on_click,
                                )
                            },
                        )
                    }
                }
            }
        }
    }
    mod input {
        use wasm_bindgen::JsValue;
        use crate::prelude::*;
        ///Props for the [`Input`] component.
        ///
        /// An input field, with optional start and end icons, and an optional info
        /// tooltip.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component.
        ///- **r#type**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The type of input
        ///- **disabled**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether the input is disabled.
        ///# Optional Props
        ///- **id**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The ID of the input.
        ///- **placeholder**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Placeholder text for the input.
        ///- **r#ref**: [`impl Into<NodeRef<html::Input>>`](NodeRef<html::Input>)
        ///    -  The ref to forward to the input
        ///- **start_icon**: [`impl Into<MaybeSignal<Option<IconProps>>>`](MaybeSignal<Option<IconProps>>)
        ///    -  The start icon, if any.
        ///- **start_text**: [`impl Into<MaybeSignal<Option<String>>>`](MaybeSignal<Option<String>>)
        ///    -  The start text, if any.
        ///- **end_icon**: [`impl Into<MaybeSignal<Option<IconProps>>>`](MaybeSignal<Option<IconProps>>)
        ///    -  The end icon, if any.
        ///- **end_text**: [`impl Into<MaybeSignal<Option<String>>>`](MaybeSignal<Option<String>>)
        ///    -  The end text, if any.
        ///- **loading**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  A loading spinner, if any.
        ///- **info_tooltip**: [`impl Into<MaybeSignal<Option<String>>>`](MaybeSignal<Option<String>>)
        ///    -  The tooltip for the input.
        ///- **variant**: [`impl Into<MaybeSignal<SecondaryColorVariant>>`](MaybeSignal<SecondaryColorVariant>)
        ///    -  Color variant of the input.
        ///- **on_input**: [`Box<dyn FnMut(ev::Event)>`]
        ///    -  Input event handler, if any
        ///- **value**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The initial value of the input.
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the input, if any.
        #[builder(doc)]
        pub struct InputProps {
            /// The ID of the input.
            #[builder(
                setter(
                    doc = "**id**: `impl`[`Into<MaybeSignal<String>>`]\n\n The ID of the input."
                )
            )]
            #[builder(default, setter(into))]
            pub id: MaybeSignal<String>,
            /// Placeholder text for the input.
            #[builder(
                setter(
                    doc = "**placeholder**: `impl`[`Into<MaybeSignal<String>>`]\n\n Placeholder text for the input."
                )
            )]
            #[builder(default, setter(into))]
            pub placeholder: MaybeSignal<String>,
            /// The type of input
            #[builder(
                setter(
                    doc = "**r#type**: `impl`[`Into<MaybeSignal<String>>`]\n\n The type of input"
                )
            )]
            #[builder(default_code = "\"text\".into()", setter(into))]
            pub r#type: MaybeSignal<String>,
            /// Whether the input is disabled.
            #[builder(
                setter(
                    doc = "**disabled**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether the input is disabled."
                )
            )]
            #[builder(default_code = "false.into()", setter(into))]
            pub disabled: MaybeSignal<bool>,
            /// The ref to forward to the input
            #[builder(
                setter(
                    doc = "**r#ref**: `impl`[`Into<NodeRef<html::Input>>`]\n\n The ref to forward to the input"
                )
            )]
            #[builder(default, setter(strip_option, into))]
            pub r#ref: Option<NodeRef<html::Input>>,
            /// The start icon, if any.
            #[builder(
                setter(
                    doc = "**start_icon**: `impl`[`Into<MaybeSignal<Option<IconProps>>>`]\n\n The start icon, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub start_icon: MaybeSignal<Option<IconProps>>,
            /// The start text, if any.
            #[builder(
                setter(
                    doc = "**start_text**: `impl`[`Into<MaybeSignal<Option<String>>>`]\n\n The start text, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub start_text: MaybeSignal<Option<String>>,
            /// The end icon, if any.
            #[builder(
                setter(
                    doc = "**end_icon**: `impl`[`Into<MaybeSignal<Option<IconProps>>>`]\n\n The end icon, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub end_icon: MaybeSignal<Option<IconProps>>,
            /// The end text, if any.
            #[builder(
                setter(
                    doc = "**end_text**: `impl`[`Into<MaybeSignal<Option<String>>>`]\n\n The end text, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub end_text: MaybeSignal<Option<String>>,
            /// A loading spinner, if any.
            #[builder(
                setter(
                    doc = "**loading**: `impl`[`Into<MaybeSignal<bool>>`]\n\n A loading spinner, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub loading: MaybeSignal<bool>,
            /// The tooltip for the input.
            #[builder(
                setter(
                    doc = "**info_tooltip**: `impl`[`Into<MaybeSignal<Option<String>>>`]\n\n The tooltip for the input."
                )
            )]
            #[builder(default, setter(into))]
            pub info_tooltip: MaybeSignal<Option<String>>,
            /// Color variant of the input.
            #[builder(
                setter(
                    doc = "**variant**: `impl`[`Into<MaybeSignal<SecondaryColorVariant>>`]\n\n Color variant of the input."
                )
            )]
            #[builder(default, setter(into))]
            pub variant: MaybeSignal<SecondaryColorVariant>,
            /// Input event handler, if any
            #[builder(
                setter(
                    doc = "**on_input**: [`Box<dyn FnMut(ev::Event)>`]\n\n Input event handler, if any"
                )
            )]
            #[builder(default_code = "Box :: new(| _ | ())")]
            pub on_input: Box<dyn FnMut(ev::Event)>,
            /// The initial value of the input.
            #[builder(
                setter(
                    doc = "**value**: `impl`[`Into<MaybeSignal<String>>`]\n\n The initial value of the input."
                )
            )]
            #[builder(default, setter(into))]
            pub value: MaybeSignal<String>,
            /// Additional class names to apply to the input, if any.
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the input, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
        }
        impl InputProps {
            /**
                Create a builder for building `InputProps`.
                On the builder, call `.id(...)`(optional), `.placeholder(...)`(optional), `.r#type(...)`(optional), `.disabled(...)`(optional), `.r#ref(...)`(optional), `.start_icon(...)`(optional), `.start_text(...)`(optional), `.end_icon(...)`(optional), `.end_text(...)`(optional), `.loading(...)`(optional), `.info_tooltip(...)`(optional), `.variant(...)`(optional), `.on_input(...)`(optional), `.value(...)`(optional), `.class(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `InputProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> InputPropsBuilder<
                ((), (), (), (), (), (), (), (), (), (), (), (), (), (), ()),
            > {
                InputPropsBuilder {
                    fields: ((), (), (), (), (), (), (), (), (), (), (), (), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`InputProps`] instances.

See [`InputProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct InputPropsBuilder<
            TypedBuilderFields
                = ((), (), (), (), (), (), (), (), (), (), (), (), (), (), ()),
        > {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for InputPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait InputPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> InputPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> InputPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                (),
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**id**: `impl`[`Into<MaybeSignal<String>>`]\n\n The ID of the input."]
            pub fn id(
                self,
                id: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> InputPropsBuilder<
                (
                    (MaybeSignal<String>,),
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let id = (id.into(),);
                let (
                    _,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_id {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                (MaybeSignal<String>,),
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field id")]
            pub fn id(
                self,
                _: InputPropsBuilder_Error_Repeated_field_id,
            ) -> InputPropsBuilder<
                (
                    (MaybeSignal<String>,),
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                (),
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**placeholder**: `impl`[`Into<MaybeSignal<String>>`]\n\n Placeholder text for the input."]
            pub fn placeholder(
                self,
                placeholder: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    (MaybeSignal<String>,),
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let placeholder = (placeholder.into(),);
                let (
                    id,
                    _,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_placeholder {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                (MaybeSignal<String>,),
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field placeholder")]
            pub fn placeholder(
                self,
                _: InputPropsBuilder_Error_Repeated_field_placeholder,
            ) -> InputPropsBuilder<
                (
                    __id,
                    (MaybeSignal<String>,),
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                (),
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**r#type**: `impl`[`Into<MaybeSignal<String>>`]\n\n The type of input"]
            pub fn r#type(
                self,
                r#type: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    (MaybeSignal<String>,),
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let r#type = (r#type.into(),);
                let (
                    id,
                    placeholder,
                    _,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_type {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                (MaybeSignal<String>,),
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field r#type")]
            pub fn r#type(
                self,
                _: InputPropsBuilder_Error_Repeated_field_type,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    (MaybeSignal<String>,),
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                (),
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**disabled**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether the input is disabled."]
            pub fn disabled(
                self,
                disabled: impl ::core::convert::Into<MaybeSignal<bool>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    (MaybeSignal<bool>,),
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let disabled = (disabled.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    _,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_disabled {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                (MaybeSignal<bool>,),
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field disabled")]
            pub fn disabled(
                self,
                _: InputPropsBuilder_Error_Repeated_field_disabled,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    (MaybeSignal<bool>,),
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                (),
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**r#ref**: `impl`[`Into<NodeRef<html::Input>>`]\n\n The ref to forward to the input"]
            pub fn r#ref(
                self,
                r#ref: impl ::core::convert::Into<NodeRef<html::Input>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    (Option<NodeRef<html::Input>>,),
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let r#ref = (Some(r#ref.into()),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    _,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                (Option<NodeRef<html::Input>>,),
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field r#ref")]
            pub fn r#ref(
                self,
                _: InputPropsBuilder_Error_Repeated_field_ref,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    (Option<NodeRef<html::Input>>,),
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                (),
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**start_icon**: `impl`[`Into<MaybeSignal<Option<IconProps>>>`]\n\n The start icon, if any."]
            pub fn start_icon(
                self,
                start_icon: impl ::core::convert::Into<MaybeSignal<Option<IconProps>>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    (MaybeSignal<Option<IconProps>>,),
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let start_icon = (start_icon.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    _,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_start_icon {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                (MaybeSignal<Option<IconProps>>,),
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field start_icon")]
            pub fn start_icon(
                self,
                _: InputPropsBuilder_Error_Repeated_field_start_icon,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    (MaybeSignal<Option<IconProps>>,),
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                (),
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**start_text**: `impl`[`Into<MaybeSignal<Option<String>>>`]\n\n The start text, if any."]
            pub fn start_text(
                self,
                start_text: impl ::core::convert::Into<MaybeSignal<Option<String>>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    (MaybeSignal<Option<String>>,),
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let start_text = (start_text.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    _,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_start_text {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                (MaybeSignal<Option<String>>,),
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field start_text")]
            pub fn start_text(
                self,
                _: InputPropsBuilder_Error_Repeated_field_start_text,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    (MaybeSignal<Option<String>>,),
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                (),
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**end_icon**: `impl`[`Into<MaybeSignal<Option<IconProps>>>`]\n\n The end icon, if any."]
            pub fn end_icon(
                self,
                end_icon: impl ::core::convert::Into<MaybeSignal<Option<IconProps>>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    (MaybeSignal<Option<IconProps>>,),
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let end_icon = (end_icon.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    _,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_end_icon {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                (MaybeSignal<Option<IconProps>>,),
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field end_icon")]
            pub fn end_icon(
                self,
                _: InputPropsBuilder_Error_Repeated_field_end_icon,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    (MaybeSignal<Option<IconProps>>,),
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                (),
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**end_text**: `impl`[`Into<MaybeSignal<Option<String>>>`]\n\n The end text, if any."]
            pub fn end_text(
                self,
                end_text: impl ::core::convert::Into<MaybeSignal<Option<String>>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    (MaybeSignal<Option<String>>,),
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let end_text = (end_text.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    _,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_end_text {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                (MaybeSignal<Option<String>>,),
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field end_text")]
            pub fn end_text(
                self,
                _: InputPropsBuilder_Error_Repeated_field_end_text,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    (MaybeSignal<Option<String>>,),
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                (),
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**loading**: `impl`[`Into<MaybeSignal<bool>>`]\n\n A loading spinner, if any."]
            pub fn loading(
                self,
                loading: impl ::core::convert::Into<MaybeSignal<bool>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    (MaybeSignal<bool>,),
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let loading = (loading.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    _,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_loading {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                (MaybeSignal<bool>,),
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field loading")]
            pub fn loading(
                self,
                _: InputPropsBuilder_Error_Repeated_field_loading,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    (MaybeSignal<bool>,),
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                (),
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**info_tooltip**: `impl`[`Into<MaybeSignal<Option<String>>>`]\n\n The tooltip for the input."]
            pub fn info_tooltip(
                self,
                info_tooltip: impl ::core::convert::Into<MaybeSignal<Option<String>>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    (MaybeSignal<Option<String>>,),
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let info_tooltip = (info_tooltip.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    _,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_info_tooltip {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __variant,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                (MaybeSignal<Option<String>>,),
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field info_tooltip")]
            pub fn info_tooltip(
                self,
                _: InputPropsBuilder_Error_Repeated_field_info_tooltip,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    (MaybeSignal<Option<String>>,),
                    __variant,
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                (),
                __on_input,
                __value,
                __class,
            ),
        > {
            #[doc = "**variant**: `impl`[`Into<MaybeSignal<SecondaryColorVariant>>`]\n\n Color variant of the input."]
            pub fn variant(
                self,
                variant: impl ::core::convert::Into<MaybeSignal<SecondaryColorVariant>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    (MaybeSignal<SecondaryColorVariant>,),
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                let variant = (variant.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    _,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_variant {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __on_input,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                (MaybeSignal<SecondaryColorVariant>,),
                __on_input,
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field variant")]
            pub fn variant(
                self,
                _: InputPropsBuilder_Error_Repeated_field_variant,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    (MaybeSignal<SecondaryColorVariant>,),
                    __on_input,
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                (),
                __value,
                __class,
            ),
        > {
            #[doc = "**on_input**: [`Box<dyn FnMut(ev::Event)>`]\n\n Input event handler, if any"]
            pub fn on_input(
                self,
                on_input: Box<dyn FnMut(ev::Event)>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    (Box<dyn FnMut(ev::Event)>,),
                    __value,
                    __class,
                ),
            > {
                let on_input = (on_input,);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    _,
                    value,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_on_input {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __value,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                (Box<dyn FnMut(ev::Event)>,),
                __value,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field on_input")]
            pub fn on_input(
                self,
                _: InputPropsBuilder_Error_Repeated_field_on_input,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    (Box<dyn FnMut(ev::Event)>,),
                    __value,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                (),
                __class,
            ),
        > {
            #[doc = "**value**: `impl`[`Into<MaybeSignal<String>>`]\n\n The initial value of the input."]
            pub fn value(
                self,
                value: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    (MaybeSignal<String>,),
                    __class,
                ),
            > {
                let value = (value.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    _,
                    class,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_value {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __class,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                (MaybeSignal<String>,),
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field value")]
            pub fn value(
                self,
                _: InputPropsBuilder_Error_Repeated_field_value,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    (MaybeSignal<String>,),
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                (),
            ),
        > {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the input, if any."]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    (MaybeSignal<String>,),
                ),
            > {
                let class = (class.into(),);
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    _,
                ) = self.fields;
                InputPropsBuilder {
                    fields: (
                        id,
                        placeholder,
                        r#type,
                        disabled,
                        r#ref,
                        start_icon,
                        start_text,
                        end_icon,
                        end_text,
                        loading,
                        info_tooltip,
                        variant,
                        on_input,
                        value,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum InputPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __placeholder,
            __type,
            __disabled,
            __ref,
            __start_icon,
            __start_text,
            __end_icon,
            __end_text,
            __loading,
            __info_tooltip,
            __variant,
            __on_input,
            __value,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                (MaybeSignal<String>,),
            ),
        > {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: InputPropsBuilder_Error_Repeated_field_class,
            ) -> InputPropsBuilder<
                (
                    __id,
                    __placeholder,
                    __type,
                    __disabled,
                    __ref,
                    __start_icon,
                    __start_text,
                    __end_icon,
                    __end_text,
                    __loading,
                    __info_tooltip,
                    __variant,
                    __on_input,
                    __value,
                    (MaybeSignal<String>,),
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id: InputPropsBuilder_Optional<MaybeSignal<String>>,
            __placeholder: InputPropsBuilder_Optional<MaybeSignal<String>>,
            __type: InputPropsBuilder_Optional<MaybeSignal<String>>,
            __disabled: InputPropsBuilder_Optional<MaybeSignal<bool>>,
            __ref: InputPropsBuilder_Optional<Option<NodeRef<html::Input>>>,
            __start_icon: InputPropsBuilder_Optional<MaybeSignal<Option<IconProps>>>,
            __start_text: InputPropsBuilder_Optional<MaybeSignal<Option<String>>>,
            __end_icon: InputPropsBuilder_Optional<MaybeSignal<Option<IconProps>>>,
            __end_text: InputPropsBuilder_Optional<MaybeSignal<Option<String>>>,
            __loading: InputPropsBuilder_Optional<MaybeSignal<bool>>,
            __info_tooltip: InputPropsBuilder_Optional<MaybeSignal<Option<String>>>,
            __variant: InputPropsBuilder_Optional<MaybeSignal<SecondaryColorVariant>>,
            __on_input: InputPropsBuilder_Optional<Box<dyn FnMut(ev::Event)>>,
            __value: InputPropsBuilder_Optional<MaybeSignal<String>>,
            __class: InputPropsBuilder_Optional<MaybeSignal<String>>,
        > InputPropsBuilder<
            (
                __id,
                __placeholder,
                __type,
                __disabled,
                __ref,
                __start_icon,
                __start_text,
                __end_icon,
                __end_text,
                __loading,
                __info_tooltip,
                __variant,
                __on_input,
                __value,
                __class,
            ),
        > {
            ///Finalise the builder and create its [`InputProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> InputProps {
                let (
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                ) = self.fields;
                let id = InputPropsBuilder_Optional::into_value(
                    id,
                    || ::core::default::Default::default(),
                );
                let placeholder = InputPropsBuilder_Optional::into_value(
                    placeholder,
                    || ::core::default::Default::default(),
                );
                let r#type = InputPropsBuilder_Optional::into_value(
                    r#type,
                    || "text".into(),
                );
                let disabled = InputPropsBuilder_Optional::into_value(
                    disabled,
                    || false.into(),
                );
                let r#ref = InputPropsBuilder_Optional::into_value(
                    r#ref,
                    || ::core::default::Default::default(),
                );
                let start_icon = InputPropsBuilder_Optional::into_value(
                    start_icon,
                    || ::core::default::Default::default(),
                );
                let start_text = InputPropsBuilder_Optional::into_value(
                    start_text,
                    || ::core::default::Default::default(),
                );
                let end_icon = InputPropsBuilder_Optional::into_value(
                    end_icon,
                    || ::core::default::Default::default(),
                );
                let end_text = InputPropsBuilder_Optional::into_value(
                    end_text,
                    || ::core::default::Default::default(),
                );
                let loading = InputPropsBuilder_Optional::into_value(
                    loading,
                    || ::core::default::Default::default(),
                );
                let info_tooltip = InputPropsBuilder_Optional::into_value(
                    info_tooltip,
                    || ::core::default::Default::default(),
                );
                let variant = InputPropsBuilder_Optional::into_value(
                    variant,
                    || ::core::default::Default::default(),
                );
                let on_input = InputPropsBuilder_Optional::into_value(
                    on_input,
                    || Box::new(|_| ()),
                );
                let value = InputPropsBuilder_Optional::into_value(
                    value,
                    || ::core::default::Default::default(),
                );
                let class = InputPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                InputProps {
                    id,
                    placeholder,
                    r#type,
                    disabled,
                    r#ref,
                    start_icon,
                    start_text,
                    end_icon,
                    end_text,
                    loading,
                    info_tooltip,
                    variant,
                    on_input,
                    value,
                    class,
                }
                    .into()
            }
        }
        impl ::leptos::Props for InputProps {
            type Builder = InputPropsBuilder;
            fn builder() -> Self::Builder {
                InputProps::builder()
            }
        }
        impl ::leptos::IntoView for InputProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Input(cx, self).into_view(cx)
            }
        }
        /// An input field, with optional start and end icons, and an optional info
        /// tooltip.
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component.
        ///- **r#type**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The type of input
        ///- **disabled**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether the input is disabled.
        ///# Optional Props
        ///- **id**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The ID of the input.
        ///- **placeholder**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Placeholder text for the input.
        ///- **r#ref**: [`impl Into<NodeRef<html::Input>>`](NodeRef<html::Input>)
        ///    -  The ref to forward to the input
        ///- **start_icon**: [`impl Into<MaybeSignal<Option<IconProps>>>`](MaybeSignal<Option<IconProps>>)
        ///    -  The start icon, if any.
        ///- **start_text**: [`impl Into<MaybeSignal<Option<String>>>`](MaybeSignal<Option<String>>)
        ///    -  The start text, if any.
        ///- **end_icon**: [`impl Into<MaybeSignal<Option<IconProps>>>`](MaybeSignal<Option<IconProps>>)
        ///    -  The end icon, if any.
        ///- **end_text**: [`impl Into<MaybeSignal<Option<String>>>`](MaybeSignal<Option<String>>)
        ///    -  The end text, if any.
        ///- **loading**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  A loading spinner, if any.
        ///- **info_tooltip**: [`impl Into<MaybeSignal<Option<String>>>`](MaybeSignal<Option<String>>)
        ///    -  The tooltip for the input.
        ///- **variant**: [`impl Into<MaybeSignal<SecondaryColorVariant>>`](MaybeSignal<SecondaryColorVariant>)
        ///    -  Color variant of the input.
        ///- **on_input**: [`Box<dyn FnMut(ev::Event)>`]
        ///    -  Input event handler, if any
        ///- **value**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The initial value of the input.
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the input, if any.
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Input(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: InputProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Input />",
                                    "frontend::components::input",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/input.rs"),
                                    Some(7u32),
                                    Some("frontend::components::input"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Input(
                            cx: Scope,
                            id: MaybeSignal<String>,
                            placeholder: MaybeSignal<String>,
                            r#type: MaybeSignal<String>,
                            disabled: MaybeSignal<bool>,
                            r#ref: Option<NodeRef<html::Input>>,
                            start_icon: MaybeSignal<Option<IconProps>>,
                            start_text: MaybeSignal<Option<String>>,
                            end_icon: MaybeSignal<Option<IconProps>>,
                            end_text: MaybeSignal<Option<String>>,
                            loading: MaybeSignal<bool>,
                            info_tooltip: MaybeSignal<Option<String>>,
                            variant: MaybeSignal<SecondaryColorVariant>,
                            on_input: Box<dyn FnMut(ev::Event)>,
                            value: MaybeSignal<String>,
                            class: MaybeSignal<String>,
                        ) -> impl IntoView {
                            let node_ref = r#ref
                                .unwrap_or_else(|| create_node_ref::<html::Input>(cx));
                            {
                                {
                                    let _ = ::leptos::leptos_dom::html::div;
                                    ::leptos::leptos_dom::html::div(cx)
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                move || {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!(
                                                            "input fr-fs-ct row-card bg-secondary-{0} {1}",
                                                            variant.get().as_css_name(),
                                                            class.get(),
                                                        ),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                        .child((
                                            cx,
                                            {
                                                move || {
                                                    info_tooltip
                                                        .get()
                                                        .map(move |content| {
                                                            TooltipContainer(
                                                                cx,
                                                                TooltipContainerProps {
                                                                    content: String::new(),
                                                                    label: None,
                                                                    disable_focus: false,
                                                                    icon_color: PatrColor::default(),
                                                                    variant: variant.get(),
                                                                    class: String::new(),
                                                                    children: Box::new(move |cx| {
                                                                        content.clone().into_view(cx).into()
                                                                    }),
                                                                },
                                                            )
                                                        })
                                                }
                                            },
                                        ))
                                        .child((
                                            cx,
                                            {
                                                start_icon
                                                    .with(|props| {
                                                        props
                                                            .as_ref()
                                                            .map(|props| IconProps {
                                                                icon: props.icon,
                                                                size: props.size,
                                                                color: props.color,
                                                                class: props.class.clone(),
                                                                on_click: props.on_click.clone(),
                                                                enable_pulse: props.enable_pulse,
                                                                fill: props.fill,
                                                            })
                                                    })
                                                    .into_view(cx)
                                            },
                                        ))
                                        .child((cx, { move || start_text.get() }))
                                        .child((
                                            cx,
                                            {
                                                match value {
                                                    MaybeSignal::Static(value) => {
                                                        ::leptos::leptos_dom::html::input(cx)
                                                            .attr("id", (cx, { move || id.get() }))
                                                            .node_ref(node_ref)
                                                            .attr("class", (cx, "mx-md of-hidden txt-of-ellipsis"))
                                                            .attr("disabled", (cx, { move || disabled.get() }))
                                                            .attr("placeholder", (cx, { move || placeholder.get() }))
                                                            .on(::leptos::ev::input, on_input)
                                                            .attr("value", (cx, move || value.clone()))
                                                            .attr("type", (cx, move || r#type.get()))
                                                    }
                                                    MaybeSignal::Dynamic(value) => {
                                                        ::leptos::leptos_dom::html::input(cx)
                                                            .attr("id", (cx, { move || id.get() }))
                                                            .node_ref(node_ref)
                                                            .attr("class", (cx, "mx-md of-hidden txt-of-ellipsis"))
                                                            .attr("disabled", (cx, { move || disabled.get() }))
                                                            .attr("placeholder", (cx, { move || placeholder.get() }))
                                                            .on(::leptos::ev::input, on_input)
                                                            .prop(
                                                                "value",
                                                                (
                                                                    cx,
                                                                    #[allow(unused_braces)]
                                                                    { move || { JsValue::from_str(value.get().as_str()) } },
                                                                ),
                                                            )
                                                            .attr("type", (cx, move || r#type.get()))
                                                    }
                                                }
                                            },
                                        ))
                                        .child((cx, { move || end_text.get() }))
                                        .child((
                                            cx,
                                            {
                                                end_icon
                                                    .with(|props| {
                                                        props
                                                            .as_ref()
                                                            .map(|props| IconProps {
                                                                icon: props.icon,
                                                                size: props.size,
                                                                color: props.color,
                                                                class: props.class.clone(),
                                                                on_click: props.on_click.clone(),
                                                                enable_pulse: props.enable_pulse,
                                                                fill: props.fill,
                                                            })
                                                    })
                                                    .into_view(cx)
                                            },
                                        ))
                                        .child((
                                            cx,
                                            {
                                                move || {
                                                    loading
                                                        .get()
                                                        .then(|| Spinner(
                                                            cx,
                                                            SpinnerProps {
                                                                class: String::from("spinner-xs").into(),
                                                            },
                                                        ))
                                                }
                                            },
                                        ))
                                }
                            }
                        }
                        let InputProps {
                            id,
                            placeholder,
                            r#type,
                            disabled,
                            r#ref,
                            start_icon,
                            start_text,
                            end_icon,
                            end_text,
                            loading,
                            info_tooltip,
                            variant,
                            on_input,
                            value,
                            class,
                        } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Input",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "id",
                                        value: std::cell::Cell::new(Some(&id)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "placeholder",
                                        value: std::cell::Cell::new(Some(&placeholder)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "r#type",
                                        value: std::cell::Cell::new(Some(&r#type)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "disabled",
                                        value: std::cell::Cell::new(Some(&disabled)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "r#ref",
                                        value: std::cell::Cell::new(Some(&r#ref)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "start_icon",
                                        value: std::cell::Cell::new(Some(&start_icon)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "start_text",
                                        value: std::cell::Cell::new(Some(&start_text)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "end_icon",
                                        value: std::cell::Cell::new(Some(&end_icon)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "end_text",
                                        value: std::cell::Cell::new(Some(&end_text)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "loading",
                                        value: std::cell::Cell::new(Some(&loading)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "info_tooltip",
                                        value: std::cell::Cell::new(Some(&info_tooltip)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "variant",
                                        value: std::cell::Cell::new(Some(&variant)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "on_input",
                                        value: std::cell::Cell::new(Some(&on_input)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "value",
                                        value: std::cell::Cell::new(Some(&value)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::input",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/input.rs"),
                                                    Some(7u32),
                                                    Some("frontend::components::input"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Input(
                                    cx,
                                    id,
                                    placeholder,
                                    r#type,
                                    disabled,
                                    r#ref,
                                    start_icon,
                                    start_text,
                                    end_icon,
                                    end_text,
                                    loading,
                                    info_tooltip,
                                    variant,
                                    on_input,
                                    value,
                                    class,
                                )
                            },
                        )
                    }
                }
            }
        }
    }
    mod link {
        use leptos_router::{use_navigate, NavigateOptions};
        use crate::prelude::*;
        /// The type of link to use. A contained link is a button with a background,
        /// while a plain link looks like an anchor tag.
        pub enum LinkVariant {
            /// A contained link. This is a button with a background.
            Contained,
            /// A plain link. This looks like an anchor tag.
            #[default]
            Plain,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LinkVariant {
            #[inline]
            fn clone(&self) -> LinkVariant {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LinkVariant {}
        #[automatically_derived]
        impl ::core::fmt::Debug for LinkVariant {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        LinkVariant::Contained => "Contained",
                        LinkVariant::Plain => "Plain",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LinkVariant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LinkVariant {
            #[inline]
            fn eq(&self, other: &LinkVariant) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for LinkVariant {}
        #[automatically_derived]
        impl ::core::cmp::Eq for LinkVariant {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::default::Default for LinkVariant {
            #[inline]
            fn default() -> LinkVariant {
                Self::Plain
            }
        }
        ///Props for the [`Link`] component.
        ///
        /// Link component to navigate to other pages
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **children**: [`Children`]
        ///    -  The children of the link, if any
        ///# Optional Props
        ///- **to**: [`impl Into<MaybeSignal<AppRoute>>`](MaybeSignal<AppRoute>)
        ///    -  The target of the link.
        ///- **color**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  The color of the link
        ///- **variant**: [`impl Into<MaybeSignal<LinkVariant>>`](MaybeSignal<LinkVariant>)
        ///    -  The variant of the link
        ///- **disabled**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether the link is disabled
        ///- **r#type**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The type of the button. This is directly passed to the `type` attribute
        ///       of the button.
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the link, if any
        ///- **on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]
        ///    -  click handler
        #[builder(doc)]
        pub struct LinkProps {
            /// The target of the link.
            #[builder(
                setter(
                    doc = "**to**: `impl`[`Into<MaybeSignal<AppRoute>>`]\n\n The target of the link."
                )
            )]
            #[builder(default, setter(into))]
            pub to: MaybeSignal<AppRoute>,
            /// The color of the link
            #[builder(
                setter(
                    doc = "**color**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n The color of the link"
                )
            )]
            #[builder(default, setter(into))]
            pub color: MaybeSignal<PatrColor>,
            /// The variant of the link
            #[builder(
                setter(
                    doc = "**variant**: `impl`[`Into<MaybeSignal<LinkVariant>>`]\n\n The variant of the link"
                )
            )]
            #[builder(default, setter(into))]
            pub variant: MaybeSignal<LinkVariant>,
            /// Whether the link is disabled
            #[builder(
                setter(
                    doc = "**disabled**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether the link is disabled"
                )
            )]
            #[builder(default, setter(into))]
            pub disabled: MaybeSignal<bool>,
            /// The type of the button. This is directly passed to the `type` attribute
            /// of the button.
            #[builder(
                setter(
                    doc = "**r#type**: `impl`[`Into<MaybeSignal<String>>`]\n\n The type of the button. This is directly passed to the `type` attribute\n of the button."
                )
            )]
            #[builder(default_code = "\"button\".into()", setter(into))]
            pub r#type: MaybeSignal<String>,
            /// Additional class names to apply to the link, if any
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the link, if any"
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
            /// click handler
            #[builder(
                setter(
                    doc = "**on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]\n\n click handler"
                )
            )]
            #[builder(default, setter(strip_option))]
            pub on_click: Option<Box<dyn Fn(&ev::MouseEvent)>>,
            /// The children of the link, if any
            #[builder(
                setter(
                    doc = "**children**: [`Children`]\n\n The children of the link, if any"
                )
            )]
            #[builder()]
            #[allow(missing_docs)]
            pub children: Children,
        }
        impl LinkProps {
            /**
                Create a builder for building `LinkProps`.
                On the builder, call `.to(...)`(optional), `.color(...)`(optional), `.variant(...)`(optional), `.disabled(...)`(optional), `.r#type(...)`(optional), `.class(...)`(optional), `.on_click(...)`(optional), `.children(...)` to set the values of the fields.
                Finally, call `.build()` to create the instance of `LinkProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> LinkPropsBuilder<((), (), (), (), (), (), (), ())> {
                LinkPropsBuilder {
                    fields: ((), (), (), (), (), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`LinkProps`] instances.

See [`LinkProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct LinkPropsBuilder<
            TypedBuilderFields = ((), (), (), (), (), (), (), ()),
        > {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for LinkPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait LinkPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> LinkPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> LinkPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __color,
            __variant,
            __disabled,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            ((), __color, __variant, __disabled, __type, __class, __on_click, __children),
        > {
            #[doc = "**to**: `impl`[`Into<MaybeSignal<AppRoute>>`]\n\n The target of the link."]
            pub fn to(
                self,
                to: impl ::core::convert::Into<MaybeSignal<AppRoute>>,
            ) -> LinkPropsBuilder<
                (
                    (MaybeSignal<AppRoute>,),
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                let to = (to.into(),);
                let (_, color, variant, disabled, r#type, class, on_click, children) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_to {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __color,
            __variant,
            __disabled,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (
                (MaybeSignal<AppRoute>,),
                __color,
                __variant,
                __disabled,
                __type,
                __class,
                __on_click,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field to")]
            pub fn to(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_to,
            ) -> LinkPropsBuilder<
                (
                    (MaybeSignal<AppRoute>,),
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __variant,
            __disabled,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (__to, (), __variant, __disabled, __type, __class, __on_click, __children),
        > {
            #[doc = "**color**: `impl`[`Into<MaybeSignal<PatrColor>>`]\n\n The color of the link"]
            pub fn color(
                self,
                color: impl ::core::convert::Into<MaybeSignal<PatrColor>>,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    (MaybeSignal<PatrColor>,),
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                let color = (color.into(),);
                let (to, _, variant, disabled, r#type, class, on_click, children) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_color {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __variant,
            __disabled,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (
                __to,
                (MaybeSignal<PatrColor>,),
                __variant,
                __disabled,
                __type,
                __class,
                __on_click,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field color")]
            pub fn color(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_color,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    (MaybeSignal<PatrColor>,),
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __disabled,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (__to, __color, (), __disabled, __type, __class, __on_click, __children),
        > {
            #[doc = "**variant**: `impl`[`Into<MaybeSignal<LinkVariant>>`]\n\n The variant of the link"]
            pub fn variant(
                self,
                variant: impl ::core::convert::Into<MaybeSignal<LinkVariant>>,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    (MaybeSignal<LinkVariant>,),
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                let variant = (variant.into(),);
                let (to, color, _, disabled, r#type, class, on_click, children) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_variant {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __disabled,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (
                __to,
                __color,
                (MaybeSignal<LinkVariant>,),
                __disabled,
                __type,
                __class,
                __on_click,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field variant")]
            pub fn variant(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_variant,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    (MaybeSignal<LinkVariant>,),
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (__to, __color, __variant, (), __type, __class, __on_click, __children),
        > {
            #[doc = "**disabled**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether the link is disabled"]
            pub fn disabled(
                self,
                disabled: impl ::core::convert::Into<MaybeSignal<bool>>,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    (MaybeSignal<bool>,),
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                let disabled = (disabled.into(),);
                let (to, color, variant, _, r#type, class, on_click, children) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_disabled {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __type,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (
                __to,
                __color,
                __variant,
                (MaybeSignal<bool>,),
                __type,
                __class,
                __on_click,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field disabled")]
            pub fn disabled(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_disabled,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    (MaybeSignal<bool>,),
                    __type,
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (__to, __color, __variant, __disabled, (), __class, __on_click, __children),
        > {
            #[doc = "**r#type**: `impl`[`Into<MaybeSignal<String>>`]\n\n The type of the button. This is directly passed to the `type` attribute\n of the button."]
            pub fn r#type(
                self,
                r#type: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    (MaybeSignal<String>,),
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                let r#type = (r#type.into(),);
                let (to, color, variant, disabled, _, class, on_click, children) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_type {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __class,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (
                __to,
                __color,
                __variant,
                __disabled,
                (MaybeSignal<String>,),
                __class,
                __on_click,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field r#type")]
            pub fn r#type(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_type,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    (MaybeSignal<String>,),
                    __class,
                    __on_click,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __type,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (__to, __color, __variant, __disabled, __type, (), __on_click, __children),
        > {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the link, if any"]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    (MaybeSignal<String>,),
                    __on_click,
                    __children,
                ),
            > {
                let class = (class.into(),);
                let (to, color, variant, disabled, r#type, _, on_click, children) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __type,
            __on_click,
            __children,
        > LinkPropsBuilder<
            (
                __to,
                __color,
                __variant,
                __disabled,
                __type,
                (MaybeSignal<String>,),
                __on_click,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_class,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    (MaybeSignal<String>,),
                    __on_click,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __type,
            __class,
            __children,
        > LinkPropsBuilder<
            (__to, __color, __variant, __disabled, __type, __class, (), __children),
        > {
            #[doc = "**on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]\n\n click handler"]
            pub fn on_click(
                self,
                on_click: Box<dyn Fn(&ev::MouseEvent)>,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    (Option<Box<dyn Fn(&ev::MouseEvent)>>,),
                    __children,
                ),
            > {
                let on_click = (Some(on_click),);
                let (to, color, variant, disabled, r#type, class, _, children) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_on_click {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __type,
            __class,
            __children,
        > LinkPropsBuilder<
            (
                __to,
                __color,
                __variant,
                __disabled,
                __type,
                __class,
                (Option<Box<dyn Fn(&ev::MouseEvent)>>,),
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field on_click")]
            pub fn on_click(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_on_click,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    (Option<Box<dyn Fn(&ev::MouseEvent)>>,),
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __type,
            __class,
            __on_click,
        > LinkPropsBuilder<
            (__to, __color, __variant, __disabled, __type, __class, __on_click, ()),
        > {
            #[doc = "**children**: [`Children`]\n\n The children of the link, if any"]
            pub fn children(
                self,
                children: Children,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    (Children,),
                ),
            > {
                let children = (children,);
                let (to, color, variant, disabled, r#type, class, on_click, _) = self
                    .fields;
                LinkPropsBuilder {
                    fields: (
                        to,
                        color,
                        variant,
                        disabled,
                        r#type,
                        class,
                        on_click,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Repeated_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __type,
            __class,
            __on_click,
        > LinkPropsBuilder<
            (
                __to,
                __color,
                __variant,
                __disabled,
                __type,
                __class,
                __on_click,
                (Children,),
            ),
        > {
            #[deprecated(note = "Repeated field children")]
            pub fn children(
                self,
                _: LinkPropsBuilder_Error_Repeated_field_children,
            ) -> LinkPropsBuilder<
                (
                    __to,
                    __color,
                    __variant,
                    __disabled,
                    __type,
                    __class,
                    __on_click,
                    (Children,),
                ),
            > {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum LinkPropsBuilder_Error_Missing_required_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            __to,
            __color,
            __variant,
            __disabled,
            __type,
            __class,
            __on_click,
        > LinkPropsBuilder<
            (__to, __color, __variant, __disabled, __type, __class, __on_click, ()),
        > {
            #[deprecated(note = "Missing required field children")]
            pub fn build(
                self,
                _: LinkPropsBuilder_Error_Missing_required_field_children,
            ) -> LinkProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __to: LinkPropsBuilder_Optional<MaybeSignal<AppRoute>>,
            __color: LinkPropsBuilder_Optional<MaybeSignal<PatrColor>>,
            __variant: LinkPropsBuilder_Optional<MaybeSignal<LinkVariant>>,
            __disabled: LinkPropsBuilder_Optional<MaybeSignal<bool>>,
            __type: LinkPropsBuilder_Optional<MaybeSignal<String>>,
            __class: LinkPropsBuilder_Optional<MaybeSignal<String>>,
            __on_click: LinkPropsBuilder_Optional<Option<Box<dyn Fn(&ev::MouseEvent)>>>,
        > LinkPropsBuilder<
            (
                __to,
                __color,
                __variant,
                __disabled,
                __type,
                __class,
                __on_click,
                (Children,),
            ),
        > {
            ///Finalise the builder and create its [`LinkProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> LinkProps {
                let (to, color, variant, disabled, r#type, class, on_click, children) = self
                    .fields;
                let to = LinkPropsBuilder_Optional::into_value(
                    to,
                    || ::core::default::Default::default(),
                );
                let color = LinkPropsBuilder_Optional::into_value(
                    color,
                    || ::core::default::Default::default(),
                );
                let variant = LinkPropsBuilder_Optional::into_value(
                    variant,
                    || ::core::default::Default::default(),
                );
                let disabled = LinkPropsBuilder_Optional::into_value(
                    disabled,
                    || ::core::default::Default::default(),
                );
                let r#type = LinkPropsBuilder_Optional::into_value(
                    r#type,
                    || "button".into(),
                );
                let class = LinkPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                let on_click = LinkPropsBuilder_Optional::into_value(
                    on_click,
                    || ::core::default::Default::default(),
                );
                let children = children.0;
                LinkProps {
                    to,
                    color,
                    variant,
                    disabled,
                    r#type,
                    class,
                    on_click,
                    children,
                }
                    .into()
            }
        }
        impl ::leptos::Props for LinkProps {
            type Builder = LinkPropsBuilder;
            fn builder() -> Self::Builder {
                LinkProps::builder()
            }
        }
        impl ::leptos::IntoView for LinkProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Link(cx, self).into_view(cx)
            }
        }
        /// Link component to navigate to other pages
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **children**: [`Children`]
        ///    -  The children of the link, if any
        ///# Optional Props
        ///- **to**: [`impl Into<MaybeSignal<AppRoute>>`](MaybeSignal<AppRoute>)
        ///    -  The target of the link.
        ///- **color**: [`impl Into<MaybeSignal<PatrColor>>`](MaybeSignal<PatrColor>)
        ///    -  The color of the link
        ///- **variant**: [`impl Into<MaybeSignal<LinkVariant>>`](MaybeSignal<LinkVariant>)
        ///    -  The variant of the link
        ///- **disabled**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether the link is disabled
        ///- **r#type**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  The type of the button. This is directly passed to the `type` attribute
        ///       of the button.
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the link, if any
        ///- **on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]
        ///    -  click handler
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Link(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: LinkProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Link />",
                                    "frontend::components::link",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/link.rs"),
                                    Some(17u32),
                                    Some("frontend::components::link"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Link(
                            cx: Scope,
                            to: MaybeSignal<AppRoute>,
                            color: MaybeSignal<PatrColor>,
                            variant: MaybeSignal<LinkVariant>,
                            disabled: MaybeSignal<bool>,
                            r#type: MaybeSignal<String>,
                            class: MaybeSignal<String>,
                            on_click: Option<Box<dyn Fn(&ev::MouseEvent)>>,
                            children: Children,
                        ) -> impl IntoView {
                            let navigate = use_navigate(cx);
                            {
                                {
                                    let _ = ::leptos::leptos_dom::html::button;
                                    ::leptos::leptos_dom::html::button(cx)
                                        .attr("type", (cx, { move || r#type.get() }))
                                        .on(
                                            ::leptos::ev::click,
                                            {
                                                move |e| {
                                                    let mut navigate_page = true;
                                                    if let Some(click) = &on_click {
                                                        click(&e);
                                                        navigate_page = !e.default_prevented();
                                                    }
                                                    if navigate_page {
                                                        if !to.get().is_empty() {
                                                            _ = navigate(
                                                                to.get().to_string().as_str(),
                                                                NavigateOptions::default(),
                                                            );
                                                        }
                                                    }
                                                }
                                            },
                                        )
                                        .attr("disabled", (cx, { move || disabled.get() }))
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                {
                                                    move || {
                                                        let res = ::alloc::fmt::format(
                                                            format_args!(
                                                                "fr-ct-ct {0} {1}",
                                                                if variant.get() == LinkVariant::Contained {
                                                                    {
                                                                        let res = ::alloc::fmt::format(
                                                                            format_args!("btn btn-{0}", color.get()),
                                                                        );
                                                                        res
                                                                    }
                                                                } else {
                                                                    {
                                                                        let res = ::alloc::fmt::format(
                                                                            format_args!("btn-plain txt-{0}", color.get()),
                                                                        );
                                                                        res
                                                                    }
                                                                },
                                                                class.get(),
                                                            ),
                                                        );
                                                        res
                                                    }
                                                },
                                            ),
                                        )
                                        .child((cx, { children(cx) }))
                                }
                            }
                        }
                        let LinkProps {
                            to,
                            color,
                            variant,
                            disabled,
                            r#type,
                            class,
                            on_click,
                            children,
                        } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Link",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "to",
                                        value: std::cell::Cell::new(Some(&to)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "color",
                                        value: std::cell::Cell::new(Some(&color)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "variant",
                                        value: std::cell::Cell::new(Some(&variant)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "disabled",
                                        value: std::cell::Cell::new(Some(&disabled)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "r#type",
                                        value: std::cell::Cell::new(Some(&r#type)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "on_click",
                                        value: std::cell::Cell::new(Some(&on_click)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "children",
                                        value: std::cell::Cell::new(Some(&children)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::link",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/link.rs"),
                                                    Some(17u32),
                                                    Some("frontend::components::link"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Link(
                                    cx,
                                    to,
                                    color,
                                    variant,
                                    disabled,
                                    r#type,
                                    class,
                                    on_click,
                                    children,
                                )
                            },
                        )
                    }
                }
            }
        }
    }
    mod otp_input {
        use std::rc::Rc;
        use wasm_bindgen::JsCast;
        use crate::prelude::*;
        ///Props for the [`OtpInput`] component.
        ///
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///# Optional Props
        ///- **id**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  ID of the input
        ///- **r#ref**: [`NodeRef<html::Input>`]
        ///    -  The ref of the input
        ///- **otp**: [`impl Into<String>`](String)
        ///    -  The default value of the OTP
        ///- **length**: [`impl Into<usize>`](usize)
        ///    -  The number of digits in the OTP input
        ///- **disabled**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether the input is disabled.
        ///- **variant**: [`impl Into<MaybeSignal<SecondaryColorVariant>>`](MaybeSignal<SecondaryColorVariant>)
        ///    -  The color of the input
        ///- **auto_submit**: [`impl Into<bool>`](bool)
        ///    -  If the component should automatically call the `on_submit` function
        ///       when the last digit is typed
        ///- **on_submit**: [`Rc<dyn Fn(String)>`]
        ///    -  The submit handler for the input
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the input, if any
        #[builder(doc)]
        pub struct OtpInputProps {
            /// ID of the input
            #[builder(
                setter(
                    doc = "**id**: `impl`[`Into<MaybeSignal<String>>`]\n\n ID of the input"
                )
            )]
            #[builder(default, setter(into))]
            pub id: MaybeSignal<String>,
            /// The ref of the input
            #[builder(
                setter(
                    doc = "**r#ref**: [`NodeRef<html::Input>`]\n\n The ref of the input"
                )
            )]
            #[builder(default, setter(strip_option))]
            pub r#ref: Option<NodeRef<html::Input>>,
            /// The default value of the OTP
            #[builder(
                setter(
                    doc = "**otp**: `impl`[`Into<String>`]\n\n The default value of the OTP"
                )
            )]
            #[builder(default, setter(into))]
            pub otp: String,
            /// The number of digits in the OTP input
            #[builder(
                setter(
                    doc = "**length**: `impl`[`Into<usize>`]\n\n The number of digits in the OTP input"
                )
            )]
            #[builder(default_code = "6", setter(into))]
            pub length: usize,
            /// Whether the input is disabled.
            #[builder(
                setter(
                    doc = "**disabled**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether the input is disabled."
                )
            )]
            #[builder(default, setter(into))]
            pub disabled: MaybeSignal<bool>,
            /// The color of the input
            #[builder(
                setter(
                    doc = "**variant**: `impl`[`Into<MaybeSignal<SecondaryColorVariant>>`]\n\n The color of the input"
                )
            )]
            #[builder(default, setter(into))]
            pub variant: MaybeSignal<SecondaryColorVariant>,
            /// If the component should automatically call the `on_submit` function
            /// when the last digit is typed
            #[builder(
                setter(
                    doc = "**auto_submit**: `impl`[`Into<bool>`]\n\n If the component should automatically call the `on_submit` function\n when the last digit is typed"
                )
            )]
            #[builder(default_code = "false", setter(into))]
            pub auto_submit: bool,
            /// The submit handler for the input
            #[builder(
                setter(
                    doc = "**on_submit**: [`Rc<dyn Fn(String)>`]\n\n The submit handler for the input"
                )
            )]
            #[builder(default, setter(strip_option))]
            pub on_submit: Option<Rc<dyn Fn(String)>>,
            /// Additional class names to apply to the input, if any
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the input, if any"
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
        }
        impl OtpInputProps {
            /**
                Create a builder for building `OtpInputProps`.
                On the builder, call `.id(...)`(optional), `.r#ref(...)`(optional), `.otp(...)`(optional), `.length(...)`(optional), `.disabled(...)`(optional), `.variant(...)`(optional), `.auto_submit(...)`(optional), `.on_submit(...)`(optional), `.class(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `OtpInputProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> OtpInputPropsBuilder<
                ((), (), (), (), (), (), (), (), ()),
            > {
                OtpInputPropsBuilder {
                    fields: ((), (), (), (), (), (), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`OtpInputProps`] instances.

See [`OtpInputProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct OtpInputPropsBuilder<
            TypedBuilderFields = ((), (), (), (), (), (), (), (), ()),
        > {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for OtpInputPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait OtpInputPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> OtpInputPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> OtpInputPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                (),
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[doc = "**id**: `impl`[`Into<MaybeSignal<String>>`]\n\n ID of the input"]
            pub fn id(
                self,
                id: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> OtpInputPropsBuilder<
                (
                    (MaybeSignal<String>,),
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                let id = (id.into(),);
                let (
                    _,
                    r#ref,
                    otp,
                    length,
                    disabled,
                    variant,
                    auto_submit,
                    on_submit,
                    class,
                ) = self.fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_id {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                (MaybeSignal<String>,),
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field id")]
            pub fn id(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_id,
            ) -> OtpInputPropsBuilder<
                (
                    (MaybeSignal<String>,),
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                (),
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[doc = "**r#ref**: [`NodeRef<html::Input>`]\n\n The ref of the input"]
            pub fn r#ref(
                self,
                r#ref: NodeRef<html::Input>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    (Option<NodeRef<html::Input>>,),
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                let r#ref = (Some(r#ref),);
                let (
                    id,
                    _,
                    otp,
                    length,
                    disabled,
                    variant,
                    auto_submit,
                    on_submit,
                    class,
                ) = self.fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                (Option<NodeRef<html::Input>>,),
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field r#ref")]
            pub fn r#ref(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_ref,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    (Option<NodeRef<html::Input>>,),
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                (),
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[doc = "**otp**: `impl`[`Into<String>`]\n\n The default value of the OTP"]
            pub fn otp(
                self,
                otp: impl ::core::convert::Into<String>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    (String,),
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                let otp = (otp.into(),);
                let (
                    id,
                    r#ref,
                    _,
                    length,
                    disabled,
                    variant,
                    auto_submit,
                    on_submit,
                    class,
                ) = self.fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_otp {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                (String,),
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field otp")]
            pub fn otp(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_otp,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    (String,),
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                (),
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[doc = "**length**: `impl`[`Into<usize>`]\n\n The number of digits in the OTP input"]
            pub fn length(
                self,
                length: impl ::core::convert::Into<usize>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    (usize,),
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                let length = (length.into(),);
                let (
                    id,
                    r#ref,
                    otp,
                    _,
                    disabled,
                    variant,
                    auto_submit,
                    on_submit,
                    class,
                ) = self.fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_length {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                (usize,),
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field length")]
            pub fn length(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_length,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    (usize,),
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                (),
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[doc = "**disabled**: `impl`[`Into<MaybeSignal<bool>>`]\n\n Whether the input is disabled."]
            pub fn disabled(
                self,
                disabled: impl ::core::convert::Into<MaybeSignal<bool>>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    (MaybeSignal<bool>,),
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                let disabled = (disabled.into(),);
                let (
                    id,
                    r#ref,
                    otp,
                    length,
                    _,
                    variant,
                    auto_submit,
                    on_submit,
                    class,
                ) = self.fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_disabled {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __variant,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                (MaybeSignal<bool>,),
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field disabled")]
            pub fn disabled(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_disabled,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    (MaybeSignal<bool>,),
                    __variant,
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                (),
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[doc = "**variant**: `impl`[`Into<MaybeSignal<SecondaryColorVariant>>`]\n\n The color of the input"]
            pub fn variant(
                self,
                variant: impl ::core::convert::Into<MaybeSignal<SecondaryColorVariant>>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    (MaybeSignal<SecondaryColorVariant>,),
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                let variant = (variant.into(),);
                let (
                    id,
                    r#ref,
                    otp,
                    length,
                    disabled,
                    _,
                    auto_submit,
                    on_submit,
                    class,
                ) = self.fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_variant {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __auto_submit,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                (MaybeSignal<SecondaryColorVariant>,),
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field variant")]
            pub fn variant(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_variant,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    (MaybeSignal<SecondaryColorVariant>,),
                    __auto_submit,
                    __on_submit,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                (),
                __on_submit,
                __class,
            ),
        > {
            #[doc = "**auto_submit**: `impl`[`Into<bool>`]\n\n If the component should automatically call the `on_submit` function\n when the last digit is typed"]
            pub fn auto_submit(
                self,
                auto_submit: impl ::core::convert::Into<bool>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    (bool,),
                    __on_submit,
                    __class,
                ),
            > {
                let auto_submit = (auto_submit.into(),);
                let (id, r#ref, otp, length, disabled, variant, _, on_submit, class) = self
                    .fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_auto_submit {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __on_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                (bool,),
                __on_submit,
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field auto_submit")]
            pub fn auto_submit(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_auto_submit,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    (bool,),
                    __on_submit,
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                (),
                __class,
            ),
        > {
            #[doc = "**on_submit**: [`Rc<dyn Fn(String)>`]\n\n The submit handler for the input"]
            pub fn on_submit(
                self,
                on_submit: Rc<dyn Fn(String)>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    (Option<Rc<dyn Fn(String)>>,),
                    __class,
                ),
            > {
                let on_submit = (Some(on_submit),);
                let (id, r#ref, otp, length, disabled, variant, auto_submit, _, class) = self
                    .fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_on_submit {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __class,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                (Option<Rc<dyn Fn(String)>>,),
                __class,
            ),
        > {
            #[deprecated(note = "Repeated field on_submit")]
            pub fn on_submit(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_on_submit,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    (Option<Rc<dyn Fn(String)>>,),
                    __class,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                (),
            ),
        > {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the input, if any"]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    (MaybeSignal<String>,),
                ),
            > {
                let class = (class.into(),);
                let (
                    id,
                    r#ref,
                    otp,
                    length,
                    disabled,
                    variant,
                    auto_submit,
                    on_submit,
                    _,
                ) = self.fields;
                OtpInputPropsBuilder {
                    fields: (
                        id,
                        r#ref,
                        otp,
                        length,
                        disabled,
                        variant,
                        auto_submit,
                        on_submit,
                        class,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum OtpInputPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id,
            __ref,
            __otp,
            __length,
            __disabled,
            __variant,
            __auto_submit,
            __on_submit,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                (MaybeSignal<String>,),
            ),
        > {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: OtpInputPropsBuilder_Error_Repeated_field_class,
            ) -> OtpInputPropsBuilder<
                (
                    __id,
                    __ref,
                    __otp,
                    __length,
                    __disabled,
                    __variant,
                    __auto_submit,
                    __on_submit,
                    (MaybeSignal<String>,),
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __id: OtpInputPropsBuilder_Optional<MaybeSignal<String>>,
            __ref: OtpInputPropsBuilder_Optional<Option<NodeRef<html::Input>>>,
            __otp: OtpInputPropsBuilder_Optional<String>,
            __length: OtpInputPropsBuilder_Optional<usize>,
            __disabled: OtpInputPropsBuilder_Optional<MaybeSignal<bool>>,
            __variant: OtpInputPropsBuilder_Optional<MaybeSignal<SecondaryColorVariant>>,
            __auto_submit: OtpInputPropsBuilder_Optional<bool>,
            __on_submit: OtpInputPropsBuilder_Optional<Option<Rc<dyn Fn(String)>>>,
            __class: OtpInputPropsBuilder_Optional<MaybeSignal<String>>,
        > OtpInputPropsBuilder<
            (
                __id,
                __ref,
                __otp,
                __length,
                __disabled,
                __variant,
                __auto_submit,
                __on_submit,
                __class,
            ),
        > {
            ///Finalise the builder and create its [`OtpInputProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> OtpInputProps {
                let (
                    id,
                    r#ref,
                    otp,
                    length,
                    disabled,
                    variant,
                    auto_submit,
                    on_submit,
                    class,
                ) = self.fields;
                let id = OtpInputPropsBuilder_Optional::into_value(
                    id,
                    || ::core::default::Default::default(),
                );
                let r#ref = OtpInputPropsBuilder_Optional::into_value(
                    r#ref,
                    || ::core::default::Default::default(),
                );
                let otp = OtpInputPropsBuilder_Optional::into_value(
                    otp,
                    || ::core::default::Default::default(),
                );
                let length = OtpInputPropsBuilder_Optional::into_value(length, || 6);
                let disabled = OtpInputPropsBuilder_Optional::into_value(
                    disabled,
                    || ::core::default::Default::default(),
                );
                let variant = OtpInputPropsBuilder_Optional::into_value(
                    variant,
                    || ::core::default::Default::default(),
                );
                let auto_submit = OtpInputPropsBuilder_Optional::into_value(
                    auto_submit,
                    || false,
                );
                let on_submit = OtpInputPropsBuilder_Optional::into_value(
                    on_submit,
                    || ::core::default::Default::default(),
                );
                let class = OtpInputPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                OtpInputProps {
                    id,
                    r#ref,
                    otp,
                    length,
                    disabled,
                    variant,
                    auto_submit,
                    on_submit,
                    class,
                }
                    .into()
            }
        }
        impl ::leptos::Props for OtpInputProps {
            type Builder = OtpInputPropsBuilder;
            fn builder() -> Self::Builder {
                OtpInputProps::builder()
            }
        }
        impl ::leptos::IntoView for OtpInputProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                OtpInput(cx, self).into_view(cx)
            }
        }
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///# Optional Props
        ///- **id**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  ID of the input
        ///- **r#ref**: [`NodeRef<html::Input>`]
        ///    -  The ref of the input
        ///- **otp**: [`impl Into<String>`](String)
        ///    -  The default value of the OTP
        ///- **length**: [`impl Into<usize>`](usize)
        ///    -  The number of digits in the OTP input
        ///- **disabled**: [`impl Into<MaybeSignal<bool>>`](MaybeSignal<bool>)
        ///    -  Whether the input is disabled.
        ///- **variant**: [`impl Into<MaybeSignal<SecondaryColorVariant>>`](MaybeSignal<SecondaryColorVariant>)
        ///    -  The color of the input
        ///- **auto_submit**: [`impl Into<bool>`](bool)
        ///    -  If the component should automatically call the `on_submit` function
        ///       when the last digit is typed
        ///- **on_submit**: [`Rc<dyn Fn(String)>`]
        ///    -  The submit handler for the input
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the input, if any
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn OtpInput(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: OtpInputProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<OtpInput />",
                                    "frontend::components::otp_input",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/otp_input.rs"),
                                    Some(7u32),
                                    Some("frontend::components::otp_input"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __OtpInput(
                            cx: Scope,
                            id: MaybeSignal<String>,
                            r#ref: Option<NodeRef<html::Input>>,
                            otp: String,
                            length: usize,
                            disabled: MaybeSignal<bool>,
                            variant: MaybeSignal<SecondaryColorVariant>,
                            auto_submit: bool,
                            on_submit: Option<Rc<dyn Fn(String)>>,
                            class: MaybeSignal<String>,
                        ) -> impl IntoView {
                            let node_ref = r#ref.unwrap_or_else(|| create_node_ref(cx));
                            let refs = store_value(
                                cx,
                                (0..length)
                                    .map(|index| {
                                        (
                                            index,
                                            create_node_ref::<html::Input>(cx),
                                            create_rw_signal(cx, None),
                                        )
                                    })
                                    .collect::<Vec<_>>(),
                            );
                            let mut last_index = 0;
                            otp.chars()
                                .filter_map(|c| c.to_digit(10))
                                .map(|n| n as u8)
                                .take(length)
                                .enumerate()
                                .for_each(|(index, digit)| {
                                    refs.with_value(|refs| {
                                        refs[index].2.set(Some(digit));
                                        last_index = index;
                                    });
                                });
                            refs.with_value(|refs| {
                                refs[last_index]
                                    .1
                                    .on_load(
                                        cx,
                                        |node| {
                                            _ = node.focus();
                                        },
                                    );
                            });
                            let value = MaybeSignal::derive(
                                cx,
                                move || {
                                    refs.with_value(|refs| {
                                            refs.iter()
                                                .try_fold(
                                                    String::new(),
                                                    |mut acc, (_, _, signal)| {
                                                        acc.push_str(&signal.get()?.to_string());
                                                        Some(acc)
                                                    },
                                                )
                                        })
                                        .unwrap_or_default()
                                },
                            );
                            let handle_key_down = move |
                                index: usize,
                                signal: RwSignal<Option<u8>>,
                                on_submit: Option<Rc<dyn Fn(String)>>,
                                e: ev::KeyboardEvent|
                            match e.code().as_str() {
                                "Backspace" | "Delete" => {
                                    e.prevent_default();
                                    signal.set(None);
                                    refs.with_value(|refs| {
                                        prev_input(index, refs);
                                    });
                                }
                                "ArrowLeft" => {
                                    e.prevent_default();
                                    refs.with_value(|refs| {
                                        prev_input(index, refs);
                                    });
                                }
                                "ArrowRight" => {
                                    e.prevent_default();
                                    refs.with_value(|refs| {
                                        next_input(index, refs);
                                    });
                                }
                                "Enter" | "NumpadEnter" => {
                                    e.prevent_default();
                                    let value = refs
                                        .with_value(|refs| {
                                            refs.iter()
                                                .try_fold(
                                                    String::new(),
                                                    |mut acc, (_, _, signal)| {
                                                        acc.push_str(&signal.get()?.to_string());
                                                        Some(acc)
                                                    },
                                                )
                                        });
                                    if let Some((value, on_submit)) = value.zip(on_submit) {
                                        on_submit(value);
                                    }
                                }
                                digit if digit.starts_with("Digit")
                                    || digit.starts_with("Numpad") => {
                                    e.prevent_default();
                                    let number = digit
                                        .chars()
                                        .last()
                                        .and_then(|c| c.to_digit(10))
                                        .map(|n| n as u8);
                                    signal.set(number);
                                    let value = refs
                                        .with_value(|refs| {
                                            next_input(index, refs);
                                            refs.iter()
                                                .try_fold(
                                                    String::new(),
                                                    |mut acc, (_, _, signal)| {
                                                        acc.push_str(&signal.get()?.to_string());
                                                        Some(acc)
                                                    },
                                                )
                                        });
                                    if auto_submit {
                                        if let Some((value, on_submit)) = value.zip(on_submit) {
                                            on_submit(value);
                                        }
                                    }
                                }
                                _ => {}
                            };
                            let handle_on_paste = move |e: ev::Event| {
                                e.prevent_default();
                                let Some(data) = e
                                    .unchecked_into::<web_sys::ClipboardEvent>()
                                    .clipboard_data()
                                    .and_then(|data| data.get_data("Text").ok()) else {
                                    return;
                                };
                                let mut last_index = 0;
                                data.chars()
                                    .filter_map(|c| c.to_digit(10))
                                    .map(|n| n as u8)
                                    .take(length)
                                    .enumerate()
                                    .for_each(|(index, digit)| {
                                        refs.with_value(|refs| {
                                            refs[index].2.set(Some(digit));
                                            last_index = index;
                                        });
                                    });
                                refs.with_value(|refs| {
                                    _ = refs[last_index].1.get().unwrap().focus();
                                });
                            };
                            {
                                {
                                    let _ = ::leptos::leptos_dom::html::div;
                                    ::leptos::leptos_dom::html::div(cx)
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                move || {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("full-width fr-ct-ct gap-xs {0}", class.get()),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                        .child((
                                            cx,
                                            {
                                                ::leptos::leptos_dom::html::input(cx)
                                                    .attr("id", (cx, move || id.get()))
                                                    .node_ref(node_ref)
                                                    .prop("value", (cx, #[allow(unused_braces)] value.get()))
                                                    .attr("type", (cx, "text"))
                                                    .attr("style", (cx, "display: none;"))
                                                    .attr("disabled", (cx, true))
                                            },
                                        ))
                                        .child((
                                            cx,
                                            {
                                                refs.with_value(|items| {
                                                    items
                                                        .iter()
                                                        .copied()
                                                        .map(|(index, node_ref, signal)| {
                                                            let on_submit = on_submit.clone();
                                                            {
                                                                {
                                                                    ::leptos::leptos_dom::html::input(cx)
                                                                        .node_ref(node_ref)
                                                                        .attr("type", (cx, "number"))
                                                                        .on(
                                                                            ::leptos::ev::keydown,
                                                                            move |e| {
                                                                                handle_key_down(index, signal, on_submit.clone(), e);
                                                                            },
                                                                        )
                                                                        .on(::leptos::ev::paste, handle_on_paste)
                                                                        .prop(
                                                                            "value",
                                                                            (cx, #[allow(unused_braces)] move || signal.get()),
                                                                        )
                                                                        .attr("placeholder", (cx, "0"))
                                                                        .attr(
                                                                            "disabled",
                                                                            (
                                                                                cx,
                                                                                move || {
                                                                                    disabled.get()
                                                                                        || { refs.with_value(|refs| { is_disabled(index, refs) }) }
                                                                                },
                                                                            ),
                                                                        )
                                                                        .attr("inputmode", (cx, "numeric"))
                                                                        .attr(
                                                                            "style",
                                                                            (cx, "color: transparent; text-shadow: 0 0 0 white;"),
                                                                        )
                                                                        .attr(
                                                                            "class",
                                                                            (
                                                                                cx,
                                                                                move || {
                                                                                    let res = ::alloc::fmt::format(
                                                                                        format_args!(
                                                                                            "full-width px-xxs txt-center row-card br-sm txt-white txt-lg outline-primary-focus bg-secondary-{0}",
                                                                                            variant.get(),
                                                                                        ),
                                                                                    );
                                                                                    res
                                                                                },
                                                                            ),
                                                                        )
                                                                }
                                                            }
                                                        })
                                                        .collect::<Vec<_>>()
                                                })
                                            },
                                        ))
                                }
                            }
                        }
                        let OtpInputProps {
                            id,
                            r#ref,
                            otp,
                            length,
                            disabled,
                            variant,
                            auto_submit,
                            on_submit,
                            class,
                        } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "OtpInput",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "id",
                                        value: std::cell::Cell::new(Some(&id)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "r#ref",
                                        value: std::cell::Cell::new(Some(&r#ref)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "otp",
                                        value: std::cell::Cell::new(Some(&otp)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "length",
                                        value: std::cell::Cell::new(Some(&length)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "disabled",
                                        value: std::cell::Cell::new(Some(&disabled)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "variant",
                                        value: std::cell::Cell::new(Some(&variant)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "auto_submit",
                                        value: std::cell::Cell::new(Some(&auto_submit)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "on_submit",
                                        value: std::cell::Cell::new(Some(&on_submit)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::otp_input",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/otp_input.rs"),
                                                    Some(7u32),
                                                    Some("frontend::components::otp_input"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __OtpInput(
                                    cx,
                                    id,
                                    r#ref,
                                    otp,
                                    length,
                                    disabled,
                                    variant,
                                    auto_submit,
                                    on_submit,
                                    class,
                                )
                            },
                        )
                    }
                }
            }
        }
        type RefsValue = (usize, NodeRef<html::Input>, RwSignal<Option<u8>>);
        fn next_input(index: usize, refs: &[RefsValue]) {
            if index < refs.len() - 1 {
                _ = refs[index + 1].1.get().unwrap().focus();
            }
        }
        fn prev_input(index: usize, refs: &[RefsValue]) {
            if index > 0 {
                _ = refs[index - 1].1.get().unwrap().focus();
            }
        }
        fn is_disabled(index: usize, refs: &[RefsValue]) -> bool {
            if let Some(rposition) = refs
                .iter()
                .rposition(|(_, _, signal)| signal.get().is_some())
            {
                index > rposition + 1
            } else {
                index != 0
            }
        }
    }
    mod portal {
        use leptos_declarative::prelude::*;
        use crate::prelude::*;
        ///Props for the [`Portal`] component.
        ///
        /// The portal with a wrapper around creating easy portals
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **children**: [`ChildrenFn`]
        ///    -  The children to put into the portal
        #[builder(doc)]
        pub struct PortalProps {
            /// The children to put into the portal
            #[builder(
                setter(
                    doc = "**children**: [`ChildrenFn`]\n\n The children to put into the portal"
                )
            )]
            #[builder()]
            #[allow(missing_docs)]
            pub children: ChildrenFn,
        }
        impl PortalProps {
            /**
                Create a builder for building `PortalProps`.
                On the builder, call `.children(...)` to set the values of the fields.
                Finally, call `.build()` to create the instance of `PortalProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> PortalPropsBuilder<((),)> {
                PortalPropsBuilder {
                    fields: ((),),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`PortalProps`] instances.

See [`PortalProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct PortalPropsBuilder<TypedBuilderFields = ((),)> {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for PortalPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait PortalPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> PortalPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> PortalPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl PortalPropsBuilder<((),)> {
            #[doc = "**children**: [`ChildrenFn`]\n\n The children to put into the portal"]
            pub fn children(
                self,
                children: ChildrenFn,
            ) -> PortalPropsBuilder<((ChildrenFn,),)> {
                let children = (children,);
                let (_,) = self.fields;
                PortalPropsBuilder {
                    fields: (children,),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PortalPropsBuilder_Error_Repeated_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl PortalPropsBuilder<((ChildrenFn,),)> {
            #[deprecated(note = "Repeated field children")]
            pub fn children(
                self,
                _: PortalPropsBuilder_Error_Repeated_field_children,
            ) -> PortalPropsBuilder<((ChildrenFn,),)> {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum PortalPropsBuilder_Error_Missing_required_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl PortalPropsBuilder<((),)> {
            #[deprecated(note = "Missing required field children")]
            pub fn build(
                self,
                _: PortalPropsBuilder_Error_Missing_required_field_children,
            ) -> PortalProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl PortalPropsBuilder<((ChildrenFn,),)> {
            ///Finalise the builder and create its [`PortalProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> PortalProps {
                let (children,) = self.fields;
                let children = children.0;
                PortalProps { children }.into()
            }
        }
        impl ::leptos::Props for PortalProps {
            type Builder = PortalPropsBuilder;
            fn builder() -> Self::Builder {
                PortalProps::builder()
            }
        }
        impl ::leptos::IntoView for PortalProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Portal(cx, self).into_view(cx)
            }
        }
        /// The portal with a wrapper around creating easy portals
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **children**: [`ChildrenFn`]
        ///    -  The children to put into the portal
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Portal(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: PortalProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Portal />",
                                    "frontend::components::portal",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/portal.rs"),
                                    Some(6u32),
                                    Some("frontend::components::portal"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Portal(
                            cx: Scope,
                            children: ChildrenFn,
                        ) -> impl IntoView {
                            {
                                ::leptos::component_view(
                                    &PortalInput,
                                    cx,
                                    ::leptos::component_props_builder(&PortalInput)
                                        .id(#[allow(unused_braces)] { PortalId })
                                        .children({
                                            Box::new(move |cx| {
                                                {
                                                    ::leptos::Fragment::lazy(|| {
                                                        [{ children(cx) }.into_view(cx)].to_vec()
                                                    })
                                                }
                                                    .with_view_marker("<PortalInput/>-children")
                                            })
                                        })
                                        .build(),
                                )
                            }
                        }
                        let PortalProps { children } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Portal",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "children",
                                        value: std::cell::Cell::new(Some(&children)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::portal",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/portal.rs"),
                                                    Some(6u32),
                                                    Some("frontend::components::portal"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Portal(cx, children)
                            },
                        )
                    }
                }
            }
        }
    }
    mod spinner {
        use crate::prelude::*;
        ///Props for the [`Spinner`] component.
        ///
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component.
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the spinner, if any.
        #[builder(doc)]
        pub struct SpinnerProps {
            /// Additional class names to apply to the spinner, if any.
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the spinner, if any."
                )
            )]
            #[builder(default, setter(into))]
            pub class: MaybeSignal<String>,
        }
        impl SpinnerProps {
            /**
                Create a builder for building `SpinnerProps`.
                On the builder, call `.class(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `SpinnerProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> SpinnerPropsBuilder<((),)> {
                SpinnerPropsBuilder {
                    fields: ((),),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`SpinnerProps`] instances.

See [`SpinnerProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct SpinnerPropsBuilder<TypedBuilderFields = ((),)> {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for SpinnerPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait SpinnerPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> SpinnerPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> SpinnerPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl SpinnerPropsBuilder<((),)> {
            #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the spinner, if any."]
            pub fn class(
                self,
                class: impl ::core::convert::Into<MaybeSignal<String>>,
            ) -> SpinnerPropsBuilder<((MaybeSignal<String>,),)> {
                let class = (class.into(),);
                let (_,) = self.fields;
                SpinnerPropsBuilder {
                    fields: (class,),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum SpinnerPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl SpinnerPropsBuilder<((MaybeSignal<String>,),)> {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: SpinnerPropsBuilder_Error_Repeated_field_class,
            ) -> SpinnerPropsBuilder<((MaybeSignal<String>,),)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __class: SpinnerPropsBuilder_Optional<MaybeSignal<String>>,
        > SpinnerPropsBuilder<(__class,)> {
            ///Finalise the builder and create its [`SpinnerProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> SpinnerProps {
                let (class,) = self.fields;
                let class = SpinnerPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                SpinnerProps { class }.into()
            }
        }
        impl ::leptos::Props for SpinnerProps {
            type Builder = SpinnerPropsBuilder;
            fn builder() -> Self::Builder {
                SpinnerProps::builder()
            }
        }
        impl ::leptos::IntoView for SpinnerProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Spinner(cx, self).into_view(cx)
            }
        }
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component.
        ///# Optional Props
        ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
        ///    -  Additional class names to apply to the spinner, if any.
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Spinner(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: SpinnerProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Spinner />",
                                    "frontend::components::spinner",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/spinner.rs"),
                                    Some(3u32),
                                    Some("frontend::components::spinner"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Spinner(
                            cx: Scope,
                            class: MaybeSignal<String>,
                        ) -> impl IntoView {
                            {
                                {
                                    ::leptos::leptos_dom::html::span(cx)
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                move || {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("spinner {0}", class.get()),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                }
                            }
                        }
                        let SpinnerProps { class } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Spinner",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::spinner",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/spinner.rs"),
                                                    Some(3u32),
                                                    Some("frontend::components::spinner"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Spinner(cx, class)
                            },
                        )
                    }
                }
            }
        }
    }
    mod tooltip {
        use leptos_use::use_event_listener;
        use crate::prelude::*;
        ///Props for the [`Tooltip`] component.
        ///
        /// Tooltip for displaying additional information when hovering over an element
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **parent_ref**: [`impl Into<NodeRef<html::Span>>`](NodeRef<html::Span>)
        ///    -  The parent ref to use for positioning the tooltip
        ///- **children**: [`impl Into<ChildrenFn>`](ChildrenFn)
        ///    -  The children of the tooltip, if any
        ///# Optional Props
        ///- **content**: [`impl Into<String>`](String)
        ///    -  The content of the tooltip
        ///- **variant**: [`impl Into<SecondaryColorVariant>`](SecondaryColorVariant)
        ///    -  The color variant of the tooltip
        #[builder(doc)]
        pub struct TooltipProps {
            /// The content of the tooltip
            #[builder(
                setter(
                    doc = "**content**: `impl`[`Into<String>`]\n\n The content of the tooltip"
                )
            )]
            #[builder(default, setter(into))]
            pub content: String,
            /// The color variant of the tooltip
            #[builder(
                setter(
                    doc = "**variant**: `impl`[`Into<SecondaryColorVariant>`]\n\n The color variant of the tooltip"
                )
            )]
            #[builder(default, setter(into))]
            pub variant: SecondaryColorVariant,
            /// The parent ref to use for positioning the tooltip
            #[builder(
                setter(
                    doc = "**parent_ref**: `impl`[`Into<NodeRef<html::Span>>`]\n\n The parent ref to use for positioning the tooltip"
                )
            )]
            #[builder(setter(into))]
            pub parent_ref: NodeRef<html::Span>,
            /// The children of the tooltip, if any
            #[builder(
                setter(
                    doc = "**children**: `impl`[`Into<ChildrenFn>`]\n\n The children of the tooltip, if any"
                )
            )]
            #[builder(setter(into))]
            #[allow(missing_docs)]
            pub children: ChildrenFn,
        }
        impl TooltipProps {
            /**
                Create a builder for building `TooltipProps`.
                On the builder, call `.content(...)`(optional), `.variant(...)`(optional), `.parent_ref(...)`, `.children(...)` to set the values of the fields.
                Finally, call `.build()` to create the instance of `TooltipProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> TooltipPropsBuilder<((), (), (), ())> {
                TooltipPropsBuilder {
                    fields: ((), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`TooltipProps`] instances.

See [`TooltipProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct TooltipPropsBuilder<TypedBuilderFields = ((), (), (), ())> {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone for TooltipPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait TooltipPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> TooltipPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> TooltipPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __variant,
            __parent_ref,
            __children,
        > TooltipPropsBuilder<((), __variant, __parent_ref, __children)> {
            #[doc = "**content**: `impl`[`Into<String>`]\n\n The content of the tooltip"]
            pub fn content(
                self,
                content: impl ::core::convert::Into<String>,
            ) -> TooltipPropsBuilder<((String,), __variant, __parent_ref, __children)> {
                let content = (content.into(),);
                let (_, variant, parent_ref, children) = self.fields;
                TooltipPropsBuilder {
                    fields: (content, variant, parent_ref, children),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipPropsBuilder_Error_Repeated_field_content {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __variant,
            __parent_ref,
            __children,
        > TooltipPropsBuilder<((String,), __variant, __parent_ref, __children)> {
            #[deprecated(note = "Repeated field content")]
            pub fn content(
                self,
                _: TooltipPropsBuilder_Error_Repeated_field_content,
            ) -> TooltipPropsBuilder<((String,), __variant, __parent_ref, __children)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __parent_ref,
            __children,
        > TooltipPropsBuilder<(__content, (), __parent_ref, __children)> {
            #[doc = "**variant**: `impl`[`Into<SecondaryColorVariant>`]\n\n The color variant of the tooltip"]
            pub fn variant(
                self,
                variant: impl ::core::convert::Into<SecondaryColorVariant>,
            ) -> TooltipPropsBuilder<
                (__content, (SecondaryColorVariant,), __parent_ref, __children),
            > {
                let variant = (variant.into(),);
                let (content, _, parent_ref, children) = self.fields;
                TooltipPropsBuilder {
                    fields: (content, variant, parent_ref, children),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipPropsBuilder_Error_Repeated_field_variant {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __parent_ref,
            __children,
        > TooltipPropsBuilder<
            (__content, (SecondaryColorVariant,), __parent_ref, __children),
        > {
            #[deprecated(note = "Repeated field variant")]
            pub fn variant(
                self,
                _: TooltipPropsBuilder_Error_Repeated_field_variant,
            ) -> TooltipPropsBuilder<
                (__content, (SecondaryColorVariant,), __parent_ref, __children),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __variant,
            __children,
        > TooltipPropsBuilder<(__content, __variant, (), __children)> {
            #[doc = "**parent_ref**: `impl`[`Into<NodeRef<html::Span>>`]\n\n The parent ref to use for positioning the tooltip"]
            pub fn parent_ref(
                self,
                parent_ref: impl ::core::convert::Into<NodeRef<html::Span>>,
            ) -> TooltipPropsBuilder<
                (__content, __variant, (NodeRef<html::Span>,), __children),
            > {
                let parent_ref = (parent_ref.into(),);
                let (content, variant, _, children) = self.fields;
                TooltipPropsBuilder {
                    fields: (content, variant, parent_ref, children),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipPropsBuilder_Error_Repeated_field_parent_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __variant,
            __children,
        > TooltipPropsBuilder<
            (__content, __variant, (NodeRef<html::Span>,), __children),
        > {
            #[deprecated(note = "Repeated field parent_ref")]
            pub fn parent_ref(
                self,
                _: TooltipPropsBuilder_Error_Repeated_field_parent_ref,
            ) -> TooltipPropsBuilder<
                (__content, __variant, (NodeRef<html::Span>,), __children),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __variant,
            __parent_ref,
        > TooltipPropsBuilder<(__content, __variant, __parent_ref, ())> {
            #[doc = "**children**: `impl`[`Into<ChildrenFn>`]\n\n The children of the tooltip, if any"]
            pub fn children(
                self,
                children: impl ::core::convert::Into<ChildrenFn>,
            ) -> TooltipPropsBuilder<
                (__content, __variant, __parent_ref, (ChildrenFn,)),
            > {
                let children = (children.into(),);
                let (content, variant, parent_ref, _) = self.fields;
                TooltipPropsBuilder {
                    fields: (content, variant, parent_ref, children),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipPropsBuilder_Error_Repeated_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __variant,
            __parent_ref,
        > TooltipPropsBuilder<(__content, __variant, __parent_ref, (ChildrenFn,))> {
            #[deprecated(note = "Repeated field children")]
            pub fn children(
                self,
                _: TooltipPropsBuilder_Error_Repeated_field_children,
            ) -> TooltipPropsBuilder<
                (__content, __variant, __parent_ref, (ChildrenFn,)),
            > {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipPropsBuilder_Error_Missing_required_field_parent_ref {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            __content,
            __variant,
            __children,
        > TooltipPropsBuilder<(__content, __variant, (), __children)> {
            #[deprecated(note = "Missing required field parent_ref")]
            pub fn build(
                self,
                _: TooltipPropsBuilder_Error_Missing_required_field_parent_ref,
            ) -> TooltipProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipPropsBuilder_Error_Missing_required_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            __content,
            __variant,
        > TooltipPropsBuilder<(__content, __variant, (NodeRef<html::Span>,), ())> {
            #[deprecated(note = "Missing required field children")]
            pub fn build(
                self,
                _: TooltipPropsBuilder_Error_Missing_required_field_children,
            ) -> TooltipProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content: TooltipPropsBuilder_Optional<String>,
            __variant: TooltipPropsBuilder_Optional<SecondaryColorVariant>,
        > TooltipPropsBuilder<
            (__content, __variant, (NodeRef<html::Span>,), (ChildrenFn,)),
        > {
            ///Finalise the builder and create its [`TooltipProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> TooltipProps {
                let (content, variant, parent_ref, children) = self.fields;
                let content = TooltipPropsBuilder_Optional::into_value(
                    content,
                    || ::core::default::Default::default(),
                );
                let variant = TooltipPropsBuilder_Optional::into_value(
                    variant,
                    || ::core::default::Default::default(),
                );
                let parent_ref = parent_ref.0;
                let children = children.0;
                TooltipProps {
                    content,
                    variant,
                    parent_ref,
                    children,
                }
                    .into()
            }
        }
        impl ::leptos::Props for TooltipProps {
            type Builder = TooltipPropsBuilder;
            fn builder() -> Self::Builder {
                TooltipProps::builder()
            }
        }
        impl ::leptos::IntoView for TooltipProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                Tooltip(cx, self).into_view(cx)
            }
        }
        /// Tooltip for displaying additional information when hovering over an element
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **parent_ref**: [`impl Into<NodeRef<html::Span>>`](NodeRef<html::Span>)
        ///    -  The parent ref to use for positioning the tooltip
        ///- **children**: [`impl Into<ChildrenFn>`](ChildrenFn)
        ///    -  The children of the tooltip, if any
        ///# Optional Props
        ///- **content**: [`impl Into<String>`](String)
        ///    -  The content of the tooltip
        ///- **variant**: [`impl Into<SecondaryColorVariant>`](SecondaryColorVariant)
        ///    -  The color variant of the tooltip
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn Tooltip(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: TooltipProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<Tooltip />",
                                    "frontend::components::tooltip",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/tooltip.rs"),
                                    Some(6u32),
                                    Some("frontend::components::tooltip"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __Tooltip(
                            cx: Scope,
                            content: String,
                            variant: SecondaryColorVariant,
                            parent_ref: NodeRef<html::Span>,
                            children: ChildrenFn,
                        ) -> impl IntoView {
                            let tooltip_ref = create_node_ref::<html::Span>(cx);
                            let is_visible = create_rw_signal(cx, false);
                            create_effect(
                                cx,
                                move |_| {
                                    let show_tooltip = move || {
                                        is_visible.set(true);
                                    };
                                    let hide_tooltip = move || {
                                        is_visible.set(false);
                                    };
                                    let handle_mouse_move = move |e: ev::MouseEvent| {
                                        if let Some((tooltip_ref, parent_ref)) = tooltip_ref
                                            .get()
                                            .zip(parent_ref.get())
                                        {
                                            if is_visible.get() {
                                                let root_font_size_in_px = window()
                                                    .get_computed_style(&document().body().unwrap())
                                                    .unwrap()
                                                    .and_then(|style| {
                                                        style.get_property_value("font-size").ok()
                                                    });
                                                if let Some(root_font_size_in_px) = root_font_size_in_px {
                                                    let root_font_size = root_font_size_in_px
                                                        .parse::<f64>()
                                                        .unwrap();
                                                    let tooltip_dimensions = tooltip_ref
                                                        .get_bounding_client_rect();
                                                    let container_dimensions = parent_ref
                                                        .get_bounding_client_rect();
                                                    let client_x = e.client_x() as f64;
                                                    let client_y = e.client_y() as f64;
                                                    let is_outside_tooltip = {
                                                        client_y + 2.6 * root_font_size < tooltip_dimensions.top()
                                                    }
                                                        || {
                                                            client_y - 0.6 * root_font_size
                                                                > tooltip_dimensions.bottom()
                                                        }
                                                        || {
                                                            client_x + 0.6 * root_font_size < tooltip_dimensions.left()
                                                        }
                                                        || {
                                                            client_x - 0.6 * root_font_size > tooltip_dimensions.right()
                                                        };
                                                    let is_outside_container = {
                                                        client_y + 0.6 * root_font_size < container_dimensions.top()
                                                    }
                                                        || {
                                                            client_y - 0.6 * root_font_size
                                                                > container_dimensions.bottom()
                                                        }
                                                        || {
                                                            client_x + 0.6 * root_font_size
                                                                < container_dimensions.left()
                                                        }
                                                        || {
                                                            client_x - 0.6 * root_font_size
                                                                > container_dimensions.right()
                                                        };
                                                    if is_outside_tooltip && is_outside_container {
                                                        hide_tooltip();
                                                    }
                                                }
                                            }
                                        }
                                    };
                                    _ = use_event_listener(
                                        cx,
                                        window(),
                                        ev::mousemove,
                                        handle_mouse_move,
                                    );
                                    _ = use_event_listener(
                                        cx,
                                        parent_ref,
                                        ev::mouseenter,
                                        move |_| { show_tooltip() },
                                    );
                                    _ = use_event_listener(
                                        cx,
                                        parent_ref,
                                        ev::focus,
                                        move |_| { show_tooltip() },
                                    );
                                    _ = use_event_listener(
                                        cx,
                                        parent_ref,
                                        ev::blur,
                                        move |_| { hide_tooltip() },
                                    );
                                },
                            );
                            let get_tooltip_dimensions = move || {
                                if let Some(r#ref) = tooltip_ref.get() {
                                    let root_font_size_in_px = window()
                                        .get_computed_style(&document().body().unwrap())
                                        .unwrap()
                                        .and_then(|style| {
                                            style.get_property_value("font-size").ok()
                                        });
                                    if let Some(root_font_size_in_px) = root_font_size_in_px {
                                        let root_font_size = root_font_size_in_px
                                            .parse::<f64>()
                                            .unwrap();
                                        let bounding_rect = r#ref.get_bounding_client_rect();
                                        let parent_left = bounding_rect.left();
                                        let parent_top = bounding_rect.top();
                                        let parent_width = r#ref.offset_width() as f64;
                                        let parent_height = r#ref.offset_height() as f64;
                                        let tooltip_width = 16f64 * root_font_size;
                                        (
                                            parent_top + parent_height + root_font_size,
                                            parent_left + parent_width / 2f64 - tooltip_width / 2f64,
                                            tooltip_width,
                                        )
                                    } else {
                                        (0f64, 0f64, 0f64)
                                    }
                                } else {
                                    (0f64, 0f64, 0f64)
                                }
                            };
                            {
                                ::leptos::component_view(
                                    &Portal,
                                    cx,
                                    ::leptos::component_props_builder(&Portal)
                                        .children({
                                            Box::new(move |cx| {
                                                {
                                                    ::leptos::Fragment::lazy(|| {
                                                        [
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::span;
                                                                ::leptos::leptos_dom::html::span(cx)
                                                                    .attr(
                                                                        "style",
                                                                        (
                                                                            cx,
                                                                            move || {
                                                                                let (top, left, width) = get_tooltip_dimensions();
                                                                                {
                                                                                    let res = ::alloc::fmt::format(
                                                                                        format_args!(
                                                                                            "top: {0}; left: {1}; width: {2}",
                                                                                            top,
                                                                                            left,
                                                                                            width,
                                                                                        ),
                                                                                    );
                                                                                    res
                                                                                }
                                                                            },
                                                                        ),
                                                                    )
                                                                    .node_ref(tooltip_ref)
                                                                    .attr(
                                                                        "class",
                                                                        (
                                                                            cx,
                                                                            move || {
                                                                                let res = ::alloc::fmt::format(
                                                                                    format_args!(
                                                                                        "tooltip pos-fix br-sm {0} {1}",
                                                                                        if is_visible.get() { "tooltip-visible" } else { "" },
                                                                                        variant.as_css_name(),
                                                                                    ),
                                                                                );
                                                                                res
                                                                            },
                                                                        ),
                                                                    )
                                                                    .child((
                                                                        cx,
                                                                        {
                                                                            let _ = ::leptos::leptos_dom::html::span;
                                                                            ::leptos::leptos_dom::html::span(cx)
                                                                                .attr(
                                                                                    "class",
                                                                                    (cx, "tip px-md py-xxs full-width fc-fs-fs pos-rel"),
                                                                                )
                                                                                .child((
                                                                                    cx,
                                                                                    {
                                                                                        let _ = ::leptos::leptos_dom::html::span;
                                                                                        ::leptos::leptos_dom::html::span(cx)
                                                                                            .attr(
                                                                                                "class",
                                                                                                (cx, "fr-ct-ct txt-white full-width txt-xxs"),
                                                                                            )
                                                                                            .child((cx, { &content }))
                                                                                            .child((cx, { children(cx) }))
                                                                                    },
                                                                                ))
                                                                        },
                                                                    ))
                                                            }
                                                                .into_view(cx),
                                                        ]
                                                            .to_vec()
                                                    })
                                                }
                                                    .with_view_marker("<Portal/>-children")
                                            })
                                        })
                                        .build(),
                                )
                            }
                        }
                        let TooltipProps { content, variant, parent_ref, children } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "Tooltip",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "content",
                                        value: std::cell::Cell::new(Some(&content)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "variant",
                                        value: std::cell::Cell::new(Some(&variant)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "parent_ref",
                                        value: std::cell::Cell::new(Some(&parent_ref)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "children",
                                        value: std::cell::Cell::new(Some(&children)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::tooltip",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/tooltip.rs"),
                                                    Some(6u32),
                                                    Some("frontend::components::tooltip"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __Tooltip(cx, content, variant, parent_ref, children)
                            },
                        )
                    }
                }
            }
        }
    }
    mod tooltip_container {
        use crate::prelude::*;
        ///Props for the [`TooltipContainer`] component.
        ///
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **children**: [`impl Into<ChildrenFn>`](ChildrenFn)
        ///    -  The children of the container
        ///# Optional Props
        ///- **content**: [`impl Into<String>`](String)
        ///    -  The content of the tooltip
        ///- **label**: [`Children`]
        ///    -  The label to display in the container
        ///- **disable_focus**: [`bool`]
        ///    -  Whether to disable focus on the container
        ///       (useful for when the container is not visible)
        ///- **icon_color**: [`impl Into<PatrColor>`](PatrColor)
        ///    -  The color variant of the icon in the tooltip
        ///- **variant**: [`impl Into<SecondaryColorVariant>`](SecondaryColorVariant)
        ///    -  The color variant of the tooltip
        ///- **class**: [`impl Into<String>`](String)
        ///    -  Additional class names to add to the container
        #[builder(doc)]
        pub struct TooltipContainerProps {
            /// The content of the tooltip
            #[builder(
                setter(
                    doc = "**content**: `impl`[`Into<String>`]\n\n The content of the tooltip"
                )
            )]
            #[builder(default, setter(into))]
            pub content: String,
            /// The label to display in the container
            #[builder(
                setter(
                    doc = "**label**: [`Children`]\n\n The label to display in the container"
                )
            )]
            #[builder(default, setter(strip_option))]
            pub label: Option<Children>,
            /// Whether to disable focus on the container
            /// (useful for when the container is not visible)
            #[builder(
                setter(
                    doc = "**disable_focus**: [`bool`]\n\n Whether to disable focus on the container\n (useful for when the container is not visible)"
                )
            )]
            #[builder(default)]
            pub disable_focus: bool,
            /// The color variant of the icon in the tooltip
            #[builder(
                setter(
                    doc = "**icon_color**: `impl`[`Into<PatrColor>`]\n\n The color variant of the icon in the tooltip"
                )
            )]
            #[builder(default, setter(into))]
            pub icon_color: PatrColor,
            /// The color variant of the tooltip
            #[builder(
                setter(
                    doc = "**variant**: `impl`[`Into<SecondaryColorVariant>`]\n\n The color variant of the tooltip"
                )
            )]
            #[builder(default, setter(into))]
            pub variant: SecondaryColorVariant,
            /// Additional class names to add to the container
            #[builder(
                setter(
                    doc = "**class**: `impl`[`Into<String>`]\n\n Additional class names to add to the container"
                )
            )]
            #[builder(default, setter(into))]
            pub class: String,
            /// The children of the container
            #[builder(
                setter(
                    doc = "**children**: `impl`[`Into<ChildrenFn>`]\n\n The children of the container"
                )
            )]
            #[builder(setter(into))]
            #[allow(missing_docs)]
            pub children: ChildrenFn,
        }
        impl TooltipContainerProps {
            /**
                Create a builder for building `TooltipContainerProps`.
                On the builder, call `.content(...)`(optional), `.label(...)`(optional), `.disable_focus(...)`(optional), `.icon_color(...)`(optional), `.variant(...)`(optional), `.class(...)`(optional), `.children(...)` to set the values of the fields.
                Finally, call `.build()` to create the instance of `TooltipContainerProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> TooltipContainerPropsBuilder<
                ((), (), (), (), (), (), ()),
            > {
                TooltipContainerPropsBuilder {
                    fields: ((), (), (), (), (), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`TooltipContainerProps`] instances.

See [`TooltipContainerProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct TooltipContainerPropsBuilder<
            TypedBuilderFields = ((), (), (), (), (), (), ()),
        > {
            fields: TypedBuilderFields,
            phantom: (),
        }
        impl<TypedBuilderFields> Clone
        for TooltipContainerPropsBuilder<TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait TooltipContainerPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> TooltipContainerPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> TooltipContainerPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __label,
            __disable_focus,
            __icon_color,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            ((), __label, __disable_focus, __icon_color, __variant, __class, __children),
        > {
            #[doc = "**content**: `impl`[`Into<String>`]\n\n The content of the tooltip"]
            pub fn content(
                self,
                content: impl ::core::convert::Into<String>,
            ) -> TooltipContainerPropsBuilder<
                (
                    (String,),
                    __label,
                    __disable_focus,
                    __icon_color,
                    __variant,
                    __class,
                    __children,
                ),
            > {
                let content = (content.into(),);
                let (_, label, disable_focus, icon_color, variant, class, children) = self
                    .fields;
                TooltipContainerPropsBuilder {
                    fields: (
                        content,
                        label,
                        disable_focus,
                        icon_color,
                        variant,
                        class,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Repeated_field_content {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __label,
            __disable_focus,
            __icon_color,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (
                (String,),
                __label,
                __disable_focus,
                __icon_color,
                __variant,
                __class,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field content")]
            pub fn content(
                self,
                _: TooltipContainerPropsBuilder_Error_Repeated_field_content,
            ) -> TooltipContainerPropsBuilder<
                (
                    (String,),
                    __label,
                    __disable_focus,
                    __icon_color,
                    __variant,
                    __class,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __disable_focus,
            __icon_color,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (
                __content,
                (),
                __disable_focus,
                __icon_color,
                __variant,
                __class,
                __children,
            ),
        > {
            #[doc = "**label**: [`Children`]\n\n The label to display in the container"]
            pub fn label(
                self,
                label: Children,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    (Option<Children>,),
                    __disable_focus,
                    __icon_color,
                    __variant,
                    __class,
                    __children,
                ),
            > {
                let label = (Some(label),);
                let (content, _, disable_focus, icon_color, variant, class, children) = self
                    .fields;
                TooltipContainerPropsBuilder {
                    fields: (
                        content,
                        label,
                        disable_focus,
                        icon_color,
                        variant,
                        class,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Repeated_field_label {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __disable_focus,
            __icon_color,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (
                __content,
                (Option<Children>,),
                __disable_focus,
                __icon_color,
                __variant,
                __class,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field label")]
            pub fn label(
                self,
                _: TooltipContainerPropsBuilder_Error_Repeated_field_label,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    (Option<Children>,),
                    __disable_focus,
                    __icon_color,
                    __variant,
                    __class,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __icon_color,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (__content, __label, (), __icon_color, __variant, __class, __children),
        > {
            #[doc = "**disable_focus**: [`bool`]\n\n Whether to disable focus on the container\n (useful for when the container is not visible)"]
            pub fn disable_focus(
                self,
                disable_focus: bool,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    (bool,),
                    __icon_color,
                    __variant,
                    __class,
                    __children,
                ),
            > {
                let disable_focus = (disable_focus,);
                let (content, label, _, icon_color, variant, class, children) = self
                    .fields;
                TooltipContainerPropsBuilder {
                    fields: (
                        content,
                        label,
                        disable_focus,
                        icon_color,
                        variant,
                        class,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Repeated_field_disable_focus {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __icon_color,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (__content, __label, (bool,), __icon_color, __variant, __class, __children),
        > {
            #[deprecated(note = "Repeated field disable_focus")]
            pub fn disable_focus(
                self,
                _: TooltipContainerPropsBuilder_Error_Repeated_field_disable_focus,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    (bool,),
                    __icon_color,
                    __variant,
                    __class,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (__content, __label, __disable_focus, (), __variant, __class, __children),
        > {
            #[doc = "**icon_color**: `impl`[`Into<PatrColor>`]\n\n The color variant of the icon in the tooltip"]
            pub fn icon_color(
                self,
                icon_color: impl ::core::convert::Into<PatrColor>,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    (PatrColor,),
                    __variant,
                    __class,
                    __children,
                ),
            > {
                let icon_color = (icon_color.into(),);
                let (content, label, disable_focus, _, variant, class, children) = self
                    .fields;
                TooltipContainerPropsBuilder {
                    fields: (
                        content,
                        label,
                        disable_focus,
                        icon_color,
                        variant,
                        class,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Repeated_field_icon_color {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __variant,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (
                __content,
                __label,
                __disable_focus,
                (PatrColor,),
                __variant,
                __class,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field icon_color")]
            pub fn icon_color(
                self,
                _: TooltipContainerPropsBuilder_Error_Repeated_field_icon_color,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    (PatrColor,),
                    __variant,
                    __class,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __icon_color,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (__content, __label, __disable_focus, __icon_color, (), __class, __children),
        > {
            #[doc = "**variant**: `impl`[`Into<SecondaryColorVariant>`]\n\n The color variant of the tooltip"]
            pub fn variant(
                self,
                variant: impl ::core::convert::Into<SecondaryColorVariant>,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    __icon_color,
                    (SecondaryColorVariant,),
                    __class,
                    __children,
                ),
            > {
                let variant = (variant.into(),);
                let (content, label, disable_focus, icon_color, _, class, children) = self
                    .fields;
                TooltipContainerPropsBuilder {
                    fields: (
                        content,
                        label,
                        disable_focus,
                        icon_color,
                        variant,
                        class,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Repeated_field_variant {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __icon_color,
            __class,
            __children,
        > TooltipContainerPropsBuilder<
            (
                __content,
                __label,
                __disable_focus,
                __icon_color,
                (SecondaryColorVariant,),
                __class,
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field variant")]
            pub fn variant(
                self,
                _: TooltipContainerPropsBuilder_Error_Repeated_field_variant,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    __icon_color,
                    (SecondaryColorVariant,),
                    __class,
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __icon_color,
            __variant,
            __children,
        > TooltipContainerPropsBuilder<
            (
                __content,
                __label,
                __disable_focus,
                __icon_color,
                __variant,
                (),
                __children,
            ),
        > {
            #[doc = "**class**: `impl`[`Into<String>`]\n\n Additional class names to add to the container"]
            pub fn class(
                self,
                class: impl ::core::convert::Into<String>,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    __icon_color,
                    __variant,
                    (String,),
                    __children,
                ),
            > {
                let class = (class.into(),);
                let (content, label, disable_focus, icon_color, variant, _, children) = self
                    .fields;
                TooltipContainerPropsBuilder {
                    fields: (
                        content,
                        label,
                        disable_focus,
                        icon_color,
                        variant,
                        class,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __icon_color,
            __variant,
            __children,
        > TooltipContainerPropsBuilder<
            (
                __content,
                __label,
                __disable_focus,
                __icon_color,
                __variant,
                (String,),
                __children,
            ),
        > {
            #[deprecated(note = "Repeated field class")]
            pub fn class(
                self,
                _: TooltipContainerPropsBuilder_Error_Repeated_field_class,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    __icon_color,
                    __variant,
                    (String,),
                    __children,
                ),
            > {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __icon_color,
            __variant,
            __class,
        > TooltipContainerPropsBuilder<
            (__content, __label, __disable_focus, __icon_color, __variant, __class, ()),
        > {
            #[doc = "**children**: `impl`[`Into<ChildrenFn>`]\n\n The children of the container"]
            pub fn children(
                self,
                children: impl ::core::convert::Into<ChildrenFn>,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    __icon_color,
                    __variant,
                    __class,
                    (ChildrenFn,),
                ),
            > {
                let children = (children.into(),);
                let (content, label, disable_focus, icon_color, variant, class, _) = self
                    .fields;
                TooltipContainerPropsBuilder {
                    fields: (
                        content,
                        label,
                        disable_focus,
                        icon_color,
                        variant,
                        class,
                        children,
                    ),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Repeated_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content,
            __label,
            __disable_focus,
            __icon_color,
            __variant,
            __class,
        > TooltipContainerPropsBuilder<
            (
                __content,
                __label,
                __disable_focus,
                __icon_color,
                __variant,
                __class,
                (ChildrenFn,),
            ),
        > {
            #[deprecated(note = "Repeated field children")]
            pub fn children(
                self,
                _: TooltipContainerPropsBuilder_Error_Repeated_field_children,
            ) -> TooltipContainerPropsBuilder<
                (
                    __content,
                    __label,
                    __disable_focus,
                    __icon_color,
                    __variant,
                    __class,
                    (ChildrenFn,),
                ),
            > {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum TooltipContainerPropsBuilder_Error_Missing_required_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            __content,
            __label,
            __disable_focus,
            __icon_color,
            __variant,
            __class,
        > TooltipContainerPropsBuilder<
            (__content, __label, __disable_focus, __icon_color, __variant, __class, ()),
        > {
            #[deprecated(note = "Missing required field children")]
            pub fn build(
                self,
                _: TooltipContainerPropsBuilder_Error_Missing_required_field_children,
            ) -> TooltipContainerProps {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            __content: TooltipContainerPropsBuilder_Optional<String>,
            __label: TooltipContainerPropsBuilder_Optional<Option<Children>>,
            __disable_focus: TooltipContainerPropsBuilder_Optional<bool>,
            __icon_color: TooltipContainerPropsBuilder_Optional<PatrColor>,
            __variant: TooltipContainerPropsBuilder_Optional<SecondaryColorVariant>,
            __class: TooltipContainerPropsBuilder_Optional<String>,
        > TooltipContainerPropsBuilder<
            (
                __content,
                __label,
                __disable_focus,
                __icon_color,
                __variant,
                __class,
                (ChildrenFn,),
            ),
        > {
            ///Finalise the builder and create its [`TooltipContainerProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> TooltipContainerProps {
                let (
                    content,
                    label,
                    disable_focus,
                    icon_color,
                    variant,
                    class,
                    children,
                ) = self.fields;
                let content = TooltipContainerPropsBuilder_Optional::into_value(
                    content,
                    || ::core::default::Default::default(),
                );
                let label = TooltipContainerPropsBuilder_Optional::into_value(
                    label,
                    || ::core::default::Default::default(),
                );
                let disable_focus = TooltipContainerPropsBuilder_Optional::into_value(
                    disable_focus,
                    || ::core::default::Default::default(),
                );
                let icon_color = TooltipContainerPropsBuilder_Optional::into_value(
                    icon_color,
                    || ::core::default::Default::default(),
                );
                let variant = TooltipContainerPropsBuilder_Optional::into_value(
                    variant,
                    || ::core::default::Default::default(),
                );
                let class = TooltipContainerPropsBuilder_Optional::into_value(
                    class,
                    || ::core::default::Default::default(),
                );
                let children = children.0;
                TooltipContainerProps {
                    content,
                    label,
                    disable_focus,
                    icon_color,
                    variant,
                    class,
                    children,
                }
                    .into()
            }
        }
        impl ::leptos::Props for TooltipContainerProps {
            type Builder = TooltipContainerPropsBuilder;
            fn builder() -> Self::Builder {
                TooltipContainerProps::builder()
            }
        }
        impl ::leptos::IntoView for TooltipContainerProps {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                TooltipContainer(cx, self).into_view(cx)
            }
        }
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **children**: [`impl Into<ChildrenFn>`](ChildrenFn)
        ///    -  The children of the container
        ///# Optional Props
        ///- **content**: [`impl Into<String>`](String)
        ///    -  The content of the tooltip
        ///- **label**: [`Children`]
        ///    -  The label to display in the container
        ///- **disable_focus**: [`bool`]
        ///    -  Whether to disable focus on the container
        ///       (useful for when the container is not visible)
        ///- **icon_color**: [`impl Into<PatrColor>`](PatrColor)
        ///    -  The color variant of the icon in the tooltip
        ///- **variant**: [`impl Into<SecondaryColorVariant>`](SecondaryColorVariant)
        ///    -  The color variant of the tooltip
        ///- **class**: [`impl Into<String>`](String)
        ///    -  Additional class names to add to the container
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn TooltipContainer(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: TooltipContainerProps,
        ) -> impl IntoView {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<TooltipContainer />",
                                    "frontend::components::tooltip_container",
                                    tracing::Level::INFO,
                                    Some("frontend/src/components/tooltip_container.rs"),
                                    Some(3u32),
                                    Some("frontend::components::tooltip_container"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __TooltipContainer(
                            cx: Scope,
                            content: String,
                            label: Option<Children>,
                            disable_focus: bool,
                            icon_color: PatrColor,
                            variant: SecondaryColorVariant,
                            class: String,
                            children: ChildrenFn,
                        ) -> impl IntoView {
                            let container_ref = create_node_ref::<html::Span>(cx);
                            {
                                {
                                    let _ = ::leptos::leptos_dom::html::span;
                                    ::leptos::leptos_dom::html::span(cx)
                                        .node_ref(container_ref)
                                        .attr(
                                            "tab_index",
                                            (cx, { if disable_focus { -1 } else { 0 } }),
                                        )
                                        .attr(
                                            "class",
                                            (
                                                cx,
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!(
                                                            "fr-ct-ct pos-rel br-sm mx-xxs tooltip-container {0} {1}",
                                                            if disable_focus { "enable-focus" } else { "" },
                                                            class,
                                                        ),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                        .child((
                                            cx,
                                            {
                                                if let Some(label) = label {
                                                    label(cx)
                                                } else {
                                                    {
                                                        ::leptos::component_view(
                                                            &Icon,
                                                            cx,
                                                            ::leptos::component_props_builder(&Icon)
                                                                .icon(#[allow(unused_braces)] IconType::Info)
                                                                .size(#[allow(unused_braces)] { ExtraSmall })
                                                                .color(#[allow(unused_braces)] { icon_color })
                                                                .class(#[allow(unused_braces)] "br-round cursor-pointer")
                                                                .build(),
                                                        )
                                                    }
                                                        .into()
                                                }
                                            },
                                        ))
                                        .child((
                                            cx,
                                            ::leptos::component_view(
                                                &Tooltip,
                                                cx,
                                                ::leptos::component_props_builder(&Tooltip)
                                                    .content(#[allow(unused_braces)] { content })
                                                    .parent_ref(#[allow(unused_braces)] { container_ref })
                                                    .children(#[allow(unused_braces)] { children })
                                                    .variant(#[allow(unused_braces)] { variant })
                                                    .build(),
                                            ),
                                        ))
                                }
                            }
                        }
                        let TooltipContainerProps {
                            content,
                            label,
                            disable_focus,
                            icon_color,
                            variant,
                            class,
                            children,
                        } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "TooltipContainer",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "content",
                                        value: std::cell::Cell::new(Some(&content)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "label",
                                        value: std::cell::Cell::new(Some(&label)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "disable_focus",
                                        value: std::cell::Cell::new(Some(&disable_focus)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "icon_color",
                                        value: std::cell::Cell::new(Some(&icon_color)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "variant",
                                        value: std::cell::Cell::new(Some(&variant)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "class",
                                        value: std::cell::Cell::new(Some(&class)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "children",
                                        value: std::cell::Cell::new(Some(&children)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::components::tooltip_container",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/components/tooltip_container.rs"),
                                                    Some(3u32),
                                                    Some("frontend::components::tooltip_container"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __TooltipContainer(
                                    cx,
                                    content,
                                    label,
                                    disable_focus,
                                    icon_color,
                                    variant,
                                    class,
                                    children,
                                )
                            },
                        )
                    }
                }
            }
        }
    }
    mod top_nav {
        mod feedback_modal {}
        mod profile_card {
            use crate::prelude::*;
            ///Props for the [`ProfileCard`] component.
            ///
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            ///- **on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]
            ///    -  The click handler for the profile card
            ///# Optional Props
            ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
            ///    -  Additional class names to apply to the profile card, if any
            #[builder(doc)]
            pub struct ProfileCardProps {
                /// The click handler for the profile card
                #[builder(
                    setter(
                        doc = "**on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]\n\n The click handler for the profile card"
                    )
                )]
                #[builder()]
                pub on_click: Box<dyn Fn(&ev::MouseEvent)>,
                /// Additional class names to apply to the profile card, if any
                #[builder(
                    setter(
                        doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the profile card, if any"
                    )
                )]
                #[builder(default, setter(into))]
                pub class: MaybeSignal<String>,
            }
            impl ProfileCardProps {
                /**
                Create a builder for building `ProfileCardProps`.
                On the builder, call `.on_click(...)`, `.class(...)`(optional) to set the values of the fields.
                Finally, call `.build()` to create the instance of `ProfileCardProps`.
                */
                #[allow(dead_code, clippy::default_trait_access)]
                pub fn builder() -> ProfileCardPropsBuilder<((), ())> {
                    ProfileCardPropsBuilder {
                        fields: ((), ()),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[must_use]
            /**Builder for [`ProfileCardProps`] instances.

See [`ProfileCardProps::builder()`] for more info.*/
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub struct ProfileCardPropsBuilder<TypedBuilderFields = ((), ())> {
                fields: TypedBuilderFields,
                phantom: (),
            }
            impl<TypedBuilderFields> Clone
            for ProfileCardPropsBuilder<TypedBuilderFields>
            where
                TypedBuilderFields: Clone,
            {
                #[allow(clippy::default_trait_access)]
                fn clone(&self) -> Self {
                    Self {
                        fields: self.fields.clone(),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub trait ProfileCardPropsBuilder_Optional<T> {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
            }
            impl<T> ProfileCardPropsBuilder_Optional<T> for () {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                    default()
                }
            }
            impl<T> ProfileCardPropsBuilder_Optional<T> for (T,) {
                fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                    self.0
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl<__class> ProfileCardPropsBuilder<((), __class)> {
                #[doc = "**on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]\n\n The click handler for the profile card"]
                pub fn on_click(
                    self,
                    on_click: Box<dyn Fn(&ev::MouseEvent)>,
                ) -> ProfileCardPropsBuilder<
                    ((Box<dyn Fn(&ev::MouseEvent)>,), __class),
                > {
                    let on_click = (on_click,);
                    let (_, class) = self.fields;
                    ProfileCardPropsBuilder {
                        fields: (on_click, class),
                        phantom: self.phantom,
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub enum ProfileCardPropsBuilder_Error_Repeated_field_on_click {}
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl<
                __class,
            > ProfileCardPropsBuilder<((Box<dyn Fn(&ev::MouseEvent)>,), __class)> {
                #[deprecated(note = "Repeated field on_click")]
                pub fn on_click(
                    self,
                    _: ProfileCardPropsBuilder_Error_Repeated_field_on_click,
                ) -> ProfileCardPropsBuilder<
                    ((Box<dyn Fn(&ev::MouseEvent)>,), __class),
                > {
                    self
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl<__on_click> ProfileCardPropsBuilder<(__on_click, ())> {
                #[doc = "**class**: `impl`[`Into<MaybeSignal<String>>`]\n\n Additional class names to apply to the profile card, if any"]
                pub fn class(
                    self,
                    class: impl ::core::convert::Into<MaybeSignal<String>>,
                ) -> ProfileCardPropsBuilder<(__on_click, (MaybeSignal<String>,))> {
                    let class = (class.into(),);
                    let (on_click, _) = self.fields;
                    ProfileCardPropsBuilder {
                        fields: (on_click, class),
                        phantom: self.phantom,
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub enum ProfileCardPropsBuilder_Error_Repeated_field_class {}
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl<
                __on_click,
            > ProfileCardPropsBuilder<(__on_click, (MaybeSignal<String>,))> {
                #[deprecated(note = "Repeated field class")]
                pub fn class(
                    self,
                    _: ProfileCardPropsBuilder_Error_Repeated_field_class,
                ) -> ProfileCardPropsBuilder<(__on_click, (MaybeSignal<String>,))> {
                    self
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub enum ProfileCardPropsBuilder_Error_Missing_required_field_on_click {}
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
            impl<__class> ProfileCardPropsBuilder<((), __class)> {
                #[deprecated(note = "Missing required field on_click")]
                pub fn build(
                    self,
                    _: ProfileCardPropsBuilder_Error_Missing_required_field_on_click,
                ) -> ProfileCardProps {
                    { ::std::rt::begin_panic("explicit panic") };
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl<
                __class: ProfileCardPropsBuilder_Optional<MaybeSignal<String>>,
            > ProfileCardPropsBuilder<((Box<dyn Fn(&ev::MouseEvent)>,), __class)> {
                ///Finalise the builder and create its [`ProfileCardProps`] instance
                #[allow(clippy::default_trait_access)]
                pub fn build(self) -> ProfileCardProps {
                    let (on_click, class) = self.fields;
                    let on_click = on_click.0;
                    let class = ProfileCardPropsBuilder_Optional::into_value(
                        class,
                        || ::core::default::Default::default(),
                    );
                    ProfileCardProps {
                        on_click,
                        class,
                    }
                        .into()
                }
            }
            impl ::leptos::Props for ProfileCardProps {
                type Builder = ProfileCardPropsBuilder;
                fn builder() -> Self::Builder {
                    ProfileCardProps::builder()
                }
            }
            impl ::leptos::IntoView for ProfileCardProps {
                fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                    ProfileCard(cx, self).into_view(cx)
                }
            }
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            ///- **on_click**: [`Box<dyn Fn(&ev::MouseEvent)>`]
            ///    -  The click handler for the profile card
            ///# Optional Props
            ///- **class**: [`impl Into<MaybeSignal<String>>`](MaybeSignal<String>)
            ///    -  Additional class names to apply to the profile card, if any
            #[allow(non_snake_case, clippy::too_many_arguments)]
            #[allow(clippy::let_with_type_underscore)]
            pub fn ProfileCard(
                #[allow(unused_variables)]
                cx: ::leptos::Scope,
                props: ProfileCardProps,
            ) -> impl IntoView {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "<ProfileCard />",
                                        "frontend::components::top_nav::profile_card",
                                        tracing::Level::INFO,
                                        Some("frontend/src/components/top_nav/profile_card.rs"),
                                        Some(3u32),
                                        Some("frontend::components::top_nav::profile_card"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    CALLSITE.metadata(),
                                );
                                if (match tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            span.record_all(
                                                &{ CALLSITE.metadata().fields().value_set(&[]) },
                                            );
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore
                        )]
                        if false {
                            let __tracing_attr_fake_return: _ = {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "this is just for type inference, and is unreachable code",
                                        ),
                                    ),
                                );
                            };
                            return __tracing_attr_fake_return;
                        }
                        {
                            #[allow(clippy::needless_lifetimes)]
                            pub fn __ProfileCard(
                                cx: Scope,
                                on_click: Box<dyn Fn(&ev::MouseEvent)>,
                                class: MaybeSignal<String>,
                            ) -> impl IntoView {
                                let first_name = "Rakshith";
                                let last_name = "Ravi";
                                {
                                    ::leptos::component_view(
                                        &Link,
                                        cx,
                                        ::leptos::component_props_builder(&Link)
                                            .on_click(#[allow(unused_braces)] on_click)
                                            .class(
                                                #[allow(unused_braces)]
                                                MaybeSignal::derive(
                                                    cx,
                                                    move || {
                                                        {
                                                            let res = ::alloc::fmt::format(
                                                                format_args!(
                                                                    "fr-fe-ct px-lg row-card br-lg bg-secondary-light ml-sm {0}",
                                                                    class.get(),
                                                                ),
                                                            );
                                                            res
                                                        }
                                                    },
                                                ),
                                            )
                                            .children({
                                                Box::new(move |cx| {
                                                    {
                                                        ::leptos::Fragment::lazy(|| {
                                                            [
                                                                {
                                                                    let _ = ::leptos::leptos_dom::html::strong;
                                                                    ::leptos::leptos_dom::html::strong(cx)
                                                                        .attr(
                                                                            "class",
                                                                            (
                                                                                cx,
                                                                                "txt-of-ellipsis txt-medium txt-sm mr-md of-hidden w-30",
                                                                            ),
                                                                        )
                                                                        .child((cx, { first_name }))
                                                                        .child((cx, { last_name }))
                                                                }
                                                                    .into_view(cx),
                                                                ::leptos::component_view(
                                                                        &Avatar,
                                                                        cx,
                                                                        ::leptos::component_props_builder(&Avatar)
                                                                            .size(#[allow(unused_braces)] Small)
                                                                            .first_name(#[allow(unused_braces)] { first_name })
                                                                            .last_name(#[allow(unused_braces)] { last_name })
                                                                            .build(),
                                                                    )
                                                                    .into_view(cx),
                                                            ]
                                                                .to_vec()
                                                        })
                                                    }
                                                        .with_view_marker("<Link/>-children")
                                                })
                                            })
                                            .build(),
                                    )
                                }
                            }
                            let ProfileCardProps { on_click, class } = props;
                            let span = ::leptos::leptos_dom::tracing::Span::current();
                            ::leptos::leptos_dom::Component::new(
                                "ProfileCard",
                                move |cx| {
                                    #[cfg(debug_assertions)]
                                    let _guard = span.entered();
                                    {
                                        use ::leptos::leptos_dom::tracing_property::{
                                            Match, SerializeMatch, DefaultMatch,
                                        };
                                        let mut props = String::from('[');
                                        let prop = (&&Match {
                                            name: "on_click",
                                            value: std::cell::Cell::new(Some(&on_click)),
                                        })
                                            .spez();
                                        props
                                            .push_str(
                                                &{
                                                    let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                    res
                                                },
                                            );
                                        let prop = (&&Match {
                                            name: "class",
                                            value: std::cell::Cell::new(Some(&class)),
                                        })
                                            .spez();
                                        props
                                            .push_str(
                                                &{
                                                    let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                    res
                                                },
                                            );
                                        props.pop();
                                        props.push(']');
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "leptos_dom::tracing_props",
                                                        "frontend::components::top_nav::profile_card",
                                                        ::leptos::leptos_dom::tracing::Level::TRACE,
                                                        Some("frontend/src/components/top_nav/profile_card.rs"),
                                                        Some(3u32),
                                                        Some("frontend::components::top_nav::profile_card"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["props"],
                                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::SPAN,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let mut interest = ::tracing::subscriber::Interest::never();
                                            if ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::leptos::leptos_dom::tracing::Level::TRACE
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    interest = CALLSITE.interest();
                                                    !interest.is_never()
                                                }
                                                && ::tracing::__macro_support::__is_enabled(
                                                    CALLSITE.metadata(),
                                                    interest,
                                                )
                                            {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(
                                                    meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = meta.fields().iter();
                                                        meta.fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                        Some(&props as &dyn Value),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            } else {
                                                let span = ::tracing::__macro_support::__disabled_span(
                                                    CALLSITE.metadata(),
                                                );
                                                if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            span.record_all(
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = CALLSITE.metadata().fields().iter();
                                                                    CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                    Some(&props as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            );
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                                span
                                            }
                                        };
                                    };
                                    __ProfileCard(cx, on_click, class)
                                },
                            )
                        }
                    }
                }
            }
        }
        mod top_nav {
            use crate::prelude::*;
            ///Props for the [`TopNav`] component.
            ///
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            #[builder(doc)]
            pub struct TopNavProps {}
            impl TopNavProps {
                /**
                Create a builder for building `TopNavProps`.
                On the builder, call  to set the values of the fields.
                Finally, call `.build()` to create the instance of `TopNavProps`.
                */
                #[allow(dead_code, clippy::default_trait_access)]
                pub fn builder() -> TopNavPropsBuilder<()> {
                    TopNavPropsBuilder {
                        fields: (),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[must_use]
            /**Builder for [`TopNavProps`] instances.

See [`TopNavProps::builder()`] for more info.*/
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub struct TopNavPropsBuilder<TypedBuilderFields = ()> {
                fields: TypedBuilderFields,
                phantom: (),
            }
            impl<TypedBuilderFields> Clone for TopNavPropsBuilder<TypedBuilderFields>
            where
                TypedBuilderFields: Clone,
            {
                #[allow(clippy::default_trait_access)]
                fn clone(&self) -> Self {
                    Self {
                        fields: self.fields.clone(),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub trait TopNavPropsBuilder_Optional<T> {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
            }
            impl<T> TopNavPropsBuilder_Optional<T> for () {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                    default()
                }
            }
            impl<T> TopNavPropsBuilder_Optional<T> for (T,) {
                fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                    self.0
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl TopNavPropsBuilder<()> {
                ///Finalise the builder and create its [`TopNavProps`] instance
                #[allow(clippy::default_trait_access)]
                pub fn build(self) -> TopNavProps {
                    let () = self.fields;
                    TopNavProps {}.into()
                }
            }
            impl ::leptos::Props for TopNavProps {
                type Builder = TopNavPropsBuilder;
                fn builder() -> Self::Builder {
                    TopNavProps::builder()
                }
            }
            impl ::leptos::IntoView for TopNavProps {
                fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                    TopNav(cx).into_view(cx)
                }
            }
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            #[allow(non_snake_case, clippy::too_many_arguments)]
            #[allow(clippy::let_with_type_underscore)]
            pub fn TopNav(
                #[allow(unused_variables)]
                cx: ::leptos::Scope,
            ) -> impl IntoView {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "<TopNav />",
                                        "frontend::components::top_nav::top_nav",
                                        tracing::Level::INFO,
                                        Some("frontend/src/components/top_nav/top_nav.rs"),
                                        Some(3u32),
                                        Some("frontend::components::top_nav::top_nav"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    CALLSITE.metadata(),
                                );
                                if (match tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            span.record_all(
                                                &{ CALLSITE.metadata().fields().value_set(&[]) },
                                            );
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore
                        )]
                        if false {
                            let __tracing_attr_fake_return: _ = {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "this is just for type inference, and is unreachable code",
                                        ),
                                    ),
                                );
                            };
                            return __tracing_attr_fake_return;
                        }
                        {
                            #[allow(clippy::needless_lifetimes)]
                            pub fn __TopNav(cx: Scope) -> impl IntoView {
                                let open_feedback = create_rw_signal(cx, false);
                                let show_profile_settings = create_rw_signal(cx, false);
                                {
                                    {
                                        let _ = ::leptos::leptos_dom::html::header;
                                        ::leptos::leptos_dom::html::header(cx)
                                            .attr("class", (cx, "full-width fr-sb-ct pt-xl pb-md"))
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::nav;
                                                    ::leptos::leptos_dom::html::nav(cx)
                                                        .attr("class", (cx, "full-width fr-fe-ct"))
                                                        .child((
                                                            cx,
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::button;
                                                                ::leptos::leptos_dom::html::button(cx)
                                                                    .on(::leptos::ev::click, move |_| open_feedback.set(true))
                                                                    .attr("class", (cx, "btn btn-secondary row-card mx-sm"))
                                                                    .child("\n\t\t\t\t\tFeedback\n\t\t\t\t")
                                                            },
                                                        ))
                                                        .child((
                                                            cx,
                                                            {
                                                                move || {
                                                                    open_feedback
                                                                        .get()
                                                                        .then(move || { { leptos::leptos_dom::Unit } })
                                                                }
                                                            },
                                                        ))
                                                        .child((
                                                            cx,
                                                            ::leptos::component_view(
                                                                &ProfileCard,
                                                                cx,
                                                                ::leptos::component_props_builder(&ProfileCard)
                                                                    .on_click(
                                                                        #[allow(unused_braces)]
                                                                        Box::new(move |_| { show_profile_settings.set(true) }),
                                                                    )
                                                                    .build(),
                                                            ),
                                                        ))
                                                },
                                            ))
                                    }
                                }
                            }
                            let span = ::leptos::leptos_dom::tracing::Span::current();
                            ::leptos::leptos_dom::Component::new(
                                "TopNav",
                                move |cx| {
                                    #[cfg(debug_assertions)]
                                    let _guard = span.entered();
                                    __TopNav(cx)
                                },
                            )
                        }
                    }
                }
            }
        }
        pub use self::{feedback_modal::*, profile_card::*, top_nav::*};
    }
    pub use self::{
        alert::*, avatar::*, badge::*, containers::*, icon::*, input::*, link::*,
        otp_input::*, portal::*, spinner::*, tooltip::*, tooltip_container::*, top_nav::*,
    };
}
mod pages {
    mod auth {
        mod confirm_sign_up {
            use crate::prelude::*;
            ///Props for the [`ConfirmSignUp`] component.
            ///
            ///# Required Props
            ///- **_cx**: [`Scope`]
            ///    -  The scope of the component.
            #[builder(doc)]
            pub struct ConfirmSignUpProps {}
            impl ConfirmSignUpProps {
                /**
                Create a builder for building `ConfirmSignUpProps`.
                On the builder, call  to set the values of the fields.
                Finally, call `.build()` to create the instance of `ConfirmSignUpProps`.
                */
                #[allow(dead_code, clippy::default_trait_access)]
                pub fn builder() -> ConfirmSignUpPropsBuilder<()> {
                    ConfirmSignUpPropsBuilder {
                        fields: (),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[must_use]
            /**Builder for [`ConfirmSignUpProps`] instances.

See [`ConfirmSignUpProps::builder()`] for more info.*/
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub struct ConfirmSignUpPropsBuilder<TypedBuilderFields = ()> {
                fields: TypedBuilderFields,
                phantom: (),
            }
            impl<TypedBuilderFields> Clone
            for ConfirmSignUpPropsBuilder<TypedBuilderFields>
            where
                TypedBuilderFields: Clone,
            {
                #[allow(clippy::default_trait_access)]
                fn clone(&self) -> Self {
                    Self {
                        fields: self.fields.clone(),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub trait ConfirmSignUpPropsBuilder_Optional<T> {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
            }
            impl<T> ConfirmSignUpPropsBuilder_Optional<T> for () {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                    default()
                }
            }
            impl<T> ConfirmSignUpPropsBuilder_Optional<T> for (T,) {
                fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                    self.0
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl ConfirmSignUpPropsBuilder<()> {
                ///Finalise the builder and create its [`ConfirmSignUpProps`] instance
                #[allow(clippy::default_trait_access)]
                pub fn build(self) -> ConfirmSignUpProps {
                    let () = self.fields;
                    ConfirmSignUpProps {}.into()
                }
            }
            impl ::leptos::Props for ConfirmSignUpProps {
                type Builder = ConfirmSignUpPropsBuilder;
                fn builder() -> Self::Builder {
                    ConfirmSignUpProps::builder()
                }
            }
            impl ::leptos::IntoView for ConfirmSignUpProps {
                fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                    ConfirmSignUp(cx).into_view(cx)
                }
            }
            ///# Required Props
            ///- **_cx**: [`Scope`]
            ///    -  The scope of the component.
            #[allow(non_snake_case, clippy::too_many_arguments)]
            #[allow(clippy::let_with_type_underscore)]
            pub fn ConfirmSignUp(
                #[allow(unused_variables)]
                _cx: ::leptos::Scope,
            ) -> impl IntoView {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "<ConfirmSignUp />",
                                        "frontend::pages::auth::confirm_sign_up",
                                        tracing::Level::INFO,
                                        Some("frontend/src/pages/auth/confirm_sign_up.rs"),
                                        Some(3u32),
                                        Some("frontend::pages::auth::confirm_sign_up"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    CALLSITE.metadata(),
                                );
                                if (match tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            span.record_all(
                                                &{ CALLSITE.metadata().fields().value_set(&[]) },
                                            );
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore
                        )]
                        if false {
                            let __tracing_attr_fake_return: _ = {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "this is just for type inference, and is unreachable code",
                                        ),
                                    ),
                                );
                            };
                            return __tracing_attr_fake_return;
                        }
                        {
                            #[allow(clippy::needless_lifetimes)]
                            pub fn __ConfirmSignUp(_cx: Scope) -> impl IntoView {}
                            let span = ::leptos::leptos_dom::tracing::Span::current();
                            ::leptos::leptos_dom::Component::new(
                                "ConfirmSignUp",
                                move |cx| {
                                    #[cfg(debug_assertions)]
                                    let _guard = span.entered();
                                    __ConfirmSignUp(cx)
                                },
                            )
                        }
                    }
                }
            }
        }
        mod login {
            use std::rc::Rc;
            use leptos_router::{use_navigate, NavigateOptions};
            use models::{
                api::auth::{LoginRequest, LoginResponse},
                ApiErrorResponse, ApiErrorResponseBody, ApiRequest, ApiSuccessResponse,
                ErrorType,
            };
            use crate::prelude::*;
            ///Props for the [`Login`] component.
            ///
            /// The login page
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            #[builder(doc)]
            pub struct LoginProps {}
            impl LoginProps {
                /**
                Create a builder for building `LoginProps`.
                On the builder, call  to set the values of the fields.
                Finally, call `.build()` to create the instance of `LoginProps`.
                */
                #[allow(dead_code, clippy::default_trait_access)]
                pub fn builder() -> LoginPropsBuilder<()> {
                    LoginPropsBuilder {
                        fields: (),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[must_use]
            /**Builder for [`LoginProps`] instances.

See [`LoginProps::builder()`] for more info.*/
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub struct LoginPropsBuilder<TypedBuilderFields = ()> {
                fields: TypedBuilderFields,
                phantom: (),
            }
            impl<TypedBuilderFields> Clone for LoginPropsBuilder<TypedBuilderFields>
            where
                TypedBuilderFields: Clone,
            {
                #[allow(clippy::default_trait_access)]
                fn clone(&self) -> Self {
                    Self {
                        fields: self.fields.clone(),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub trait LoginPropsBuilder_Optional<T> {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
            }
            impl<T> LoginPropsBuilder_Optional<T> for () {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                    default()
                }
            }
            impl<T> LoginPropsBuilder_Optional<T> for (T,) {
                fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                    self.0
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl LoginPropsBuilder<()> {
                ///Finalise the builder and create its [`LoginProps`] instance
                #[allow(clippy::default_trait_access)]
                pub fn build(self) -> LoginProps {
                    let () = self.fields;
                    LoginProps {}.into()
                }
            }
            impl ::leptos::Props for LoginProps {
                type Builder = LoginPropsBuilder;
                fn builder() -> Self::Builder {
                    LoginProps::builder()
                }
            }
            impl ::leptos::IntoView for LoginProps {
                fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                    Login(cx).into_view(cx)
                }
            }
            /// The login page
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            #[allow(non_snake_case, clippy::too_many_arguments)]
            #[allow(clippy::let_with_type_underscore)]
            pub fn Login(
                #[allow(unused_variables)]
                cx: ::leptos::Scope,
            ) -> impl IntoView {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "<Login />",
                                        "frontend::pages::auth::login",
                                        tracing::Level::INFO,
                                        Some("frontend/src/pages/auth/login.rs"),
                                        Some(16u32),
                                        Some("frontend::pages::auth::login"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    CALLSITE.metadata(),
                                );
                                if (match tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            span.record_all(
                                                &{ CALLSITE.metadata().fields().value_set(&[]) },
                                            );
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore
                        )]
                        if false {
                            let __tracing_attr_fake_return: _ = {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "this is just for type inference, and is unreachable code",
                                        ),
                                    ),
                                );
                            };
                            return __tracing_attr_fake_return;
                        }
                        {
                            #[allow(clippy::needless_lifetimes)]
                            pub fn __Login(cx: Scope) -> impl IntoView {
                                let set_state = expect_context::<
                                    WriteSignal<AppStorage>,
                                >(cx);
                                let show_password = create_rw_signal(cx, false);
                                let show_create_account_button = create_rw_signal(
                                    cx,
                                    false,
                                );
                                let show_otp_input = create_rw_signal(cx, false);
                                let username_error = create_rw_signal(cx, String::from(""));
                                let password_error = create_rw_signal(cx, String::from(""));
                                let mfa_otp_error = create_rw_signal(cx, String::from(""));
                                let handle_errors = move |error, message| match error {
                                    ErrorType::MfaRequired => {
                                        show_otp_input.set(true);
                                    }
                                    ErrorType::MfaOtpInvalid => {
                                        mfa_otp_error.set(message);
                                    }
                                    ErrorType::InvalidPassword => {
                                        password_error.set(message);
                                    }
                                    ErrorType::UserNotFound => {
                                        username_error.set(error.message().into());
                                        show_create_account_button.set(true);
                                    }
                                    _ => {
                                        password_error.set(message);
                                    }
                                };
                                let login_action = create_action(
                                    cx,
                                    move |
                                        (
                                            username,
                                            password,
                                            mfa_otp,
                                        ): &(String, String, Option<String>)|
                                    {
                                        let user_id = username.clone();
                                        let password = password.clone();
                                        let mfa_otp = mfa_otp.clone();
                                        async move {
                                            let result = make_request(
                                                    ApiRequest::<LoginRequest>::builder()
                                                        .path(Default::default())
                                                        .query(())
                                                        .headers(())
                                                        .body(LoginRequest {
                                                            user_id,
                                                            password,
                                                            mfa_otp,
                                                        })
                                                        .build(),
                                                )
                                                .await;
                                            let LoginResponse { access_token, refresh_token } = match result {
                                                Ok(
                                                    ApiSuccessResponse { status_code: _, headers: (), body },
                                                ) => body,
                                                Err(
                                                    ApiErrorResponse {
                                                        status_code: _,
                                                        body: ApiErrorResponseBody { success: _, error, message },
                                                    },
                                                ) => {
                                                    handle_errors(error, message);
                                                    return;
                                                }
                                            };
                                            set_state
                                                .set(AppStorage::LoggedIn {
                                                    user_id: Default::default(),
                                                    access_token,
                                                    refresh_token,
                                                    default_workspace: None,
                                                });
                                        }
                                    },
                                );
                                let login_loading = login_action.pending();
                                let user_id_ref = create_node_ref(cx);
                                let password_ref = create_node_ref(cx);
                                let mfa_otp_ref = create_node_ref(cx);
                                let handle_login = move |e: ev::SubmitEvent| {
                                    e.prevent_default();
                                    let user_id = user_id_ref
                                        .get()
                                        .map(|input: HtmlElement<html::Input>| input.value())
                                        .unwrap();
                                    let password = password_ref
                                        .get()
                                        .map(|input: HtmlElement<html::Input>| input.value())
                                        .unwrap();
                                    let mfa_otp = mfa_otp_ref
                                        .get()
                                        .map(|input: HtmlElement<html::Input>| input.value());
                                    if user_id.is_empty() {
                                        username_error
                                            .set("Username / Email cannot be empty".into());
                                        _ = user_id_ref.get().unwrap().focus();
                                        return;
                                    }
                                    if password.is_empty() {
                                        password_error.set("Password cannot be empty".into());
                                        _ = password_ref.get().unwrap().focus();
                                        return;
                                    }
                                    login_action.dispatch((user_id, password, mfa_otp));
                                };
                                let handle_create_new_account = move |e: &ev::MouseEvent| {
                                    e.prevent_default();
                                    let user_id = user_id_ref
                                        .get()
                                        .map(|input: HtmlElement<html::Input>| input.value())
                                        .unwrap();
                                    let is_email = user_id.contains('@');
                                    let navigate = use_navigate(cx);
                                    _ = navigate(
                                        {
                                            let res = ::alloc::fmt::format(
                                                format_args!(
                                                    "{0}?{1}",
                                                    AppRoute::LoggedOutRoutes(LoggedOutRoutes::SignUp)
                                                        .to_string()
                                                        .as_str(),
                                                    serde_urlencoded::to_string([
                                                            (
                                                                if is_email { "email" } else { "username" },
                                                                user_id.as_str(),
                                                            ),
                                                        ])
                                                        .unwrap(),
                                                ),
                                            );
                                            res
                                        }
                                            .as_str(),
                                        NavigateOptions::default(),
                                    );
                                };
                                {
                                    {
                                        let _ = ::leptos::leptos_dom::html::form;
                                        ::leptos::leptos_dom::html::form(cx)
                                            .attr("class", (cx, "box-onboard txt-white fc-fs-fs"))
                                            .on(::leptos::ev::submit, handle_login)
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::div;
                                                    ::leptos::leptos_dom::html::div(cx)
                                                        .attr("class", (cx, "fr-sb-bl mb-lg full-width"))
                                                        .child((
                                                            cx,
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::h1;
                                                                ::leptos::leptos_dom::html::h1(cx)
                                                                    .attr("class", (cx, "txt-primary txt-xl txt-medium"))
                                                                    .child((cx, { "Sign In" }))
                                                            },
                                                        ))
                                                        .child((
                                                            cx,
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::p;
                                                                ::leptos::leptos_dom::html::p(cx)
                                                                    .attr("class", (cx, "txt-white txt-thin fr-fs-fs"))
                                                                    .child("\n\t\t\t\t\tNew user?\n\t\t\t\t\t")
                                                                    .child((
                                                                        cx,
                                                                        ::leptos::component_view(
                                                                            &Link,
                                                                            cx,
                                                                            ::leptos::component_props_builder(&Link)
                                                                                .disabled(#[allow(unused_braces)] { login_loading })
                                                                                .to(
                                                                                    #[allow(unused_braces)]
                                                                                    AppRoute::LoggedOutRoutes(LoggedOutRoutes::SignUp),
                                                                                )
                                                                                .class(#[allow(unused_braces)] "ml-xs")
                                                                                .children({
                                                                                    Box::new(move |cx| {
                                                                                        {
                                                                                            ::leptos::Fragment::lazy(|| {
                                                                                                ["\n\t\t\t\t\t\tSign Up\n\t\t\t\t\t".into_view(cx)].to_vec()
                                                                                            })
                                                                                        }
                                                                                            .with_view_marker("<Link/>-children")
                                                                                    })
                                                                                })
                                                                                .build(),
                                                                        ),
                                                                    ))
                                                            },
                                                        ))
                                                },
                                            ))
                                            .child((
                                                cx,
                                                ::leptos::component_view(
                                                    &Input,
                                                    cx,
                                                    ::leptos::component_props_builder(&Input)
                                                        .r#type(#[allow(unused_braces)] "text")
                                                        .class(#[allow(unused_braces)] "full-width")
                                                        .disabled(#[allow(unused_braces)] { login_loading })
                                                        .id(#[allow(unused_braces)] "username")
                                                        .on_input(
                                                            #[allow(unused_braces)]
                                                            Box::new(move |_| {
                                                                username_error.update(|password| password.clear());
                                                            }),
                                                        )
                                                        .r#ref(#[allow(unused_braces)] user_id_ref)
                                                        .placeholder(#[allow(unused_braces)] "Username/Email")
                                                        .start_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(IconType::User)
                                                                        .size(ExtraSmall)
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .build(),
                                                ),
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::div;
                                                    ::leptos::leptos_dom::html::div(cx)
                                                        .attr("class", (cx, "fr-fs-ct"))
                                                        .child((
                                                            cx,
                                                            {
                                                                move || {
                                                                    username_error
                                                                        .get()
                                                                        .some_if_not_empty()
                                                                        .map(|username| {
                                                                            {
                                                                                ::leptos::component_view(
                                                                                    &Alert,
                                                                                    cx,
                                                                                    ::leptos::component_props_builder(&Alert)
                                                                                        .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                                        .class(#[allow(unused_braces)] "mt-xs")
                                                                                        .message(#[allow(unused_braces)] username)
                                                                                        .build(),
                                                                                )
                                                                            }
                                                                        })
                                                                }
                                                            },
                                                        ))
                                                        .child((
                                                            cx,
                                                            {
                                                                move || {
                                                                    show_create_account_button
                                                                        .with(|value| {
                                                                            value
                                                                                .then(move || {
                                                                                    ::leptos::component_view(
                                                                                        &Link,
                                                                                        cx,
                                                                                        ::leptos::component_props_builder(&Link)
                                                                                            .disabled(#[allow(unused_braces)] { login_loading })
                                                                                            .to(
                                                                                                #[allow(unused_braces)]
                                                                                                AppRoute::LoggedOutRoutes(LoggedOutRoutes::SignUp),
                                                                                            )
                                                                                            .on_click(
                                                                                                #[allow(unused_braces)]
                                                                                                Box::new(handle_create_new_account),
                                                                                            )
                                                                                            .class(
                                                                                                #[allow(unused_braces)]
                                                                                                "ml-sm txt-underline txt-medium mt-xs",
                                                                                            )
                                                                                            .children({
                                                                                                Box::new(move |cx| {
                                                                                                    {
                                                                                                        ::leptos::Fragment::lazy(|| {
                                                                                                            [
                                                                                                                "\n\t\t\t\t\t\t\t\tCreate a new account?\n\t\t\t\t\t\t\t"
                                                                                                                    .into_view(cx),
                                                                                                            ]
                                                                                                                .to_vec()
                                                                                                        })
                                                                                                    }
                                                                                                        .with_view_marker("<Link/>-children")
                                                                                                })
                                                                                            })
                                                                                            .build(),
                                                                                    )
                                                                                })
                                                                        })
                                                                }
                                                            },
                                                        ))
                                                },
                                            ))
                                            .child((
                                                cx,
                                                ::leptos::component_view(
                                                    &Input,
                                                    cx,
                                                    ::leptos::component_props_builder(&Input)
                                                        .class(#[allow(unused_braces)] "mt-md full-width")
                                                        .r#type(
                                                            #[allow(unused_braces)]
                                                            {
                                                                MaybeSignal::derive(
                                                                    cx,
                                                                    move || {
                                                                        if show_password.get() {
                                                                            "text".to_owned()
                                                                        } else {
                                                                            "password".to_owned()
                                                                        }
                                                                    },
                                                                )
                                                            },
                                                        )
                                                        .on_input(
                                                            #[allow(unused_braces)]
                                                            Box::new(move |_| {
                                                                password_error.update(|password| password.clear());
                                                            }),
                                                        )
                                                        .id(#[allow(unused_braces)] "password")
                                                        .r#ref(#[allow(unused_braces)] password_ref)
                                                        .placeholder(#[allow(unused_braces)] "Password")
                                                        .disabled(#[allow(unused_braces)] { login_loading })
                                                        .start_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(IconType::Shield)
                                                                        .size(ExtraSmall)
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .end_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(
                                                                            MaybeSignal::derive(
                                                                                cx,
                                                                                move || {
                                                                                    if show_password.get() {
                                                                                        IconType::Eye
                                                                                    } else {
                                                                                        IconType::EyeOff
                                                                                    }
                                                                                },
                                                                            ),
                                                                        )
                                                                        .color(Grey)
                                                                        .size(ExtraSmall)
                                                                        .on_click(
                                                                            Rc::new(move |_| {
                                                                                show_password.update(|value| *value = !*value);
                                                                            }),
                                                                        )
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .build(),
                                                ),
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    move || {
                                                        password_error
                                                            .get()
                                                            .some_if_not_empty()
                                                            .map(|password| {
                                                                {
                                                                    ::leptos::component_view(
                                                                        &Alert,
                                                                        cx,
                                                                        ::leptos::component_props_builder(&Alert)
                                                                            .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                            .class(#[allow(unused_braces)] "mt-xs")
                                                                            .message(#[allow(unused_braces)] { password })
                                                                            .build(),
                                                                    )
                                                                }
                                                            })
                                                    }
                                                },
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    move || {
                                                        show_otp_input
                                                            .get()
                                                            .then(|| {
                                                                {
                                                                    {
                                                                        ::leptos::Fragment::lazy(|| {
                                                                            [
                                                                                {
                                                                                    let _ = ::leptos::leptos_dom::html::p;
                                                                                    ::leptos::leptos_dom::html::p(cx)
                                                                                        .attr("class", (cx, "mt-xl txt-center txt-grey"))
                                                                                        .child(
                                                                                            "\n\t\t\t\t\t\tEnter the OTP generated by your authenticator app to log in. ",
                                                                                        )
                                                                                        .child((cx, { ::leptos::leptos_dom::html::br(cx) }))
                                                                                        .child("\n\t\t\t\t\t\tThis additional step is required as ")
                                                                                        .child("you've")
                                                                                        .child(
                                                                                            " enabled Two-Factor\n\t\t\t\t\t\tAuthentication for your account.\n\t\t\t\t\t",
                                                                                        )
                                                                                }
                                                                                    .into_view(cx),
                                                                                ::leptos::component_view(
                                                                                        &OtpInput,
                                                                                        cx,
                                                                                        ::leptos::component_props_builder(&OtpInput)
                                                                                            .id(#[allow(unused_braces)] "mfa-otp")
                                                                                            .r#ref(#[allow(unused_braces)] mfa_otp_ref)
                                                                                            .on_submit(
                                                                                                #[allow(unused_braces)]
                                                                                                Rc::new(move |_| {
                                                                                                    handle_login(ev::SubmitEvent::new("submit").unwrap());
                                                                                                }),
                                                                                            )
                                                                                            .disabled(#[allow(unused_braces)] { login_loading })
                                                                                            .class(#[allow(unused_braces)] "mt-xl")
                                                                                            .build(),
                                                                                    )
                                                                                    .into_view(cx),
                                                                            ]
                                                                                .to_vec()
                                                                        })
                                                                    }
                                                                }
                                                            })
                                                    }
                                                },
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    move || {
                                                        mfa_otp_error
                                                            .get()
                                                            .some_if_not_empty()
                                                            .map(|mfa_otp| {
                                                                {
                                                                    ::leptos::component_view(
                                                                        &Alert,
                                                                        cx,
                                                                        ::leptos::component_props_builder(&Alert)
                                                                            .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                            .class(#[allow(unused_braces)] "mt-xs")
                                                                            .message(#[allow(unused_braces)] { mfa_otp })
                                                                            .build(),
                                                                    )
                                                                }
                                                            })
                                                    }
                                                },
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::div;
                                                    ::leptos::leptos_dom::html::div(cx)
                                                        .attr("class", (cx, "fr-sb-ct full-width mt-xs"))
                                                        .child((
                                                            cx,
                                                            ::leptos::component_view(
                                                                &Link,
                                                                cx,
                                                                ::leptos::component_props_builder(&Link)
                                                                    .to(
                                                                        #[allow(unused_braces)]
                                                                        AppRoute::LoggedOutRoutes(LoggedOutRoutes::ForgotPassword),
                                                                    )
                                                                    .disabled(#[allow(unused_braces)] { login_loading })
                                                                    .children({
                                                                        Box::new(move |cx| {
                                                                            {
                                                                                ::leptos::Fragment::lazy(|| {
                                                                                    ["\n\t\t\t\t\tForgot Password?\n\t\t\t\t".into_view(cx)]
                                                                                        .to_vec()
                                                                                })
                                                                            }
                                                                                .with_view_marker("<Link/>-children")
                                                                        })
                                                                    })
                                                                    .build(),
                                                            ),
                                                        ))
                                                },
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    move || {
                                                        if login_loading.get() {
                                                            {
                                                                ::leptos::component_view(
                                                                    &Spinner,
                                                                    cx,
                                                                    ::leptos::component_props_builder(&Spinner)
                                                                        .class(#[allow(unused_braces)] "mt-md mr-xl ml-auto")
                                                                        .build(),
                                                                )
                                                            }
                                                        } else {
                                                            {
                                                                ::leptos::component_view(
                                                                    &Link,
                                                                    cx,
                                                                    ::leptos::component_props_builder(&Link)
                                                                        .r#type(#[allow(unused_braces)] "submit")
                                                                        .variant(#[allow(unused_braces)] LinkVariant::Contained)
                                                                        .class(#[allow(unused_braces)] "mt-md ml-auto")
                                                                        .children({
                                                                            Box::new(move |cx| {
                                                                                {
                                                                                    ::leptos::Fragment::lazy(|| {
                                                                                        ["\n\t\t\t\t\t\tLOGIN\n\t\t\t\t\t".into_view(cx)].to_vec()
                                                                                    })
                                                                                }
                                                                                    .with_view_marker("<Link/>-children")
                                                                            })
                                                                        })
                                                                        .build(),
                                                                )
                                                            }
                                                        }
                                                    }
                                                },
                                            ))
                                    }
                                }
                            }
                            let span = ::leptos::leptos_dom::tracing::Span::current();
                            ::leptos::leptos_dom::Component::new(
                                "Login",
                                move |cx| {
                                    #[cfg(debug_assertions)]
                                    let _guard = span.entered();
                                    __Login(cx)
                                },
                            )
                        }
                    }
                }
            }
        }
        mod sign_up {
            use std::rc::Rc;
            use leptos_router::use_query_map;
            use leptos_use::use_debounce_fn_with_arg;
            use models::{
                api::auth::{
                    CreateAccountRequest, CreateAccountResponse, IsEmailValidQuery,
                    IsEmailValidRequest, IsEmailValidResponse, IsUsernameValidQuery,
                    IsUsernameValidRequest, IsUsernameValidResponse, RecoveryMethod,
                },
                ApiErrorResponse, ApiErrorResponseBody, ApiRequest, ApiSuccessResponse,
                ErrorType,
            };
            use crate::prelude::*;
            ///Props for the [`SignUp`] component.
            ///
            /// The login page
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            #[builder(doc)]
            pub struct SignUpProps {}
            impl SignUpProps {
                /**
                Create a builder for building `SignUpProps`.
                On the builder, call  to set the values of the fields.
                Finally, call `.build()` to create the instance of `SignUpProps`.
                */
                #[allow(dead_code, clippy::default_trait_access)]
                pub fn builder() -> SignUpPropsBuilder<()> {
                    SignUpPropsBuilder {
                        fields: (),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[must_use]
            /**Builder for [`SignUpProps`] instances.

See [`SignUpProps::builder()`] for more info.*/
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub struct SignUpPropsBuilder<TypedBuilderFields = ()> {
                fields: TypedBuilderFields,
                phantom: (),
            }
            impl<TypedBuilderFields> Clone for SignUpPropsBuilder<TypedBuilderFields>
            where
                TypedBuilderFields: Clone,
            {
                #[allow(clippy::default_trait_access)]
                fn clone(&self) -> Self {
                    Self {
                        fields: self.fields.clone(),
                        phantom: ::core::default::Default::default(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(dead_code, non_camel_case_types, non_snake_case)]
            pub trait SignUpPropsBuilder_Optional<T> {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
            }
            impl<T> SignUpPropsBuilder_Optional<T> for () {
                fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                    default()
                }
            }
            impl<T> SignUpPropsBuilder_Optional<T> for (T,) {
                fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                    self.0
                }
            }
            #[allow(dead_code, non_camel_case_types, missing_docs)]
            impl SignUpPropsBuilder<()> {
                ///Finalise the builder and create its [`SignUpProps`] instance
                #[allow(clippy::default_trait_access)]
                pub fn build(self) -> SignUpProps {
                    let () = self.fields;
                    SignUpProps {}.into()
                }
            }
            impl ::leptos::Props for SignUpProps {
                type Builder = SignUpPropsBuilder;
                fn builder() -> Self::Builder {
                    SignUpProps::builder()
                }
            }
            impl ::leptos::IntoView for SignUpProps {
                fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                    SignUp(cx).into_view(cx)
                }
            }
            /// The login page
            ///# Required Props
            ///- **cx**: [`Scope`]
            ///    -  The scope of the component
            #[allow(non_snake_case, clippy::too_many_arguments)]
            #[allow(clippy::let_with_type_underscore)]
            pub fn SignUp(
                #[allow(unused_variables)]
                cx: ::leptos::Scope,
            ) -> impl IntoView {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "<SignUp />",
                                        "frontend::pages::auth::sign_up",
                                        tracing::Level::INFO,
                                        Some("frontend/src/pages/auth/sign_up.rs"),
                                        Some(27u32),
                                        Some("frontend::pages::auth::sign_up"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    CALLSITE.metadata(),
                                );
                                if (match tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            span.record_all(
                                                &{ CALLSITE.metadata().fields().value_set(&[]) },
                                            );
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore
                        )]
                        if false {
                            let __tracing_attr_fake_return: _ = {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "this is just for type inference, and is unreachable code",
                                        ),
                                    ),
                                );
                            };
                            return __tracing_attr_fake_return;
                        }
                        {
                            #[allow(clippy::needless_lifetimes)]
                            pub fn __SignUp(cx: Scope) -> impl IntoView {
                                let first_name_ref = create_node_ref(cx);
                                let last_name_ref = create_node_ref(cx);
                                let username_ref = create_node_ref(cx);
                                let query = use_query_map(cx);
                                let email_ref = create_node_ref(cx);
                                let password_ref = create_node_ref(cx);
                                let confirm_password_ref = create_node_ref(cx);
                                let show_password = create_rw_signal(cx, false);
                                let first_name_error = create_rw_signal(
                                    cx,
                                    String::from(""),
                                );
                                let last_name_error = create_rw_signal(
                                    cx,
                                    String::from(""),
                                );
                                let username_default = query
                                    .get_untracked()
                                    .get("username")
                                    .cloned()
                                    .unwrap_or_default();
                                let username_error_type = create_rw_signal(
                                    cx,
                                    NotificationType::Error,
                                );
                                let username_error = create_rw_signal(cx, String::from(""));
                                let username_verifying = create_rw_signal(cx, false);
                                let email_default = query
                                    .get_untracked()
                                    .get("email")
                                    .cloned()
                                    .unwrap_or_default();
                                let email_error = create_rw_signal(cx, String::from(""));
                                let email_error_type = create_rw_signal(
                                    cx,
                                    NotificationType::Error,
                                );
                                let email_verifying = create_rw_signal(cx, false);
                                let password_error = create_rw_signal(cx, String::from(""));
                                let confirm_password_error = create_rw_signal(
                                    cx,
                                    String::from(""),
                                );
                                let show_login_username_button = create_rw_signal(
                                    cx,
                                    false,
                                );
                                let handle_errors = move |error, message| match error {
                                    ErrorType::InvalidPassword => {
                                        password_error.set(message);
                                    }
                                    ErrorType::UserNotFound => {
                                        username_error.set(error.message().into());
                                        show_login_username_button.set(true);
                                    }
                                    ErrorType::InvalidEmail => {
                                        email_error.set(message);
                                    }
                                    _ => {
                                        confirm_password_error.set(message);
                                    }
                                };
                                let username_valid_action = create_action(
                                    cx,
                                    move |username: &String| {
                                        let username = username.clone();
                                        async move {
                                            let result = make_request(
                                                    ApiRequest::<IsUsernameValidRequest>::builder()
                                                        .path(Default::default())
                                                        .query(IsUsernameValidQuery { username })
                                                        .headers(())
                                                        .body(IsUsernameValidRequest)
                                                        .build(),
                                                )
                                                .await;
                                            let IsUsernameValidResponse { available } = match result {
                                                Ok(
                                                    ApiSuccessResponse { status_code: _, headers: (), body },
                                                ) => body,
                                                Err(
                                                    ApiErrorResponse {
                                                        status_code: _,
                                                        body: ApiErrorResponseBody { success: _, error, message },
                                                    },
                                                ) => {
                                                    handle_errors(error, message);
                                                    return;
                                                }
                                            };
                                            if !available {
                                                username_error.set("Username is already taken".to_string());
                                                username_error_type.set(NotificationType::Error);
                                            } else {
                                                username_error.set("Username is available".to_string());
                                                username_error_type.set(NotificationType::Success);
                                            }
                                            if username_verifying.get_untracked() {
                                                username_verifying.set(false);
                                            }
                                        }
                                    },
                                );
                                let email_valid_action = create_action(
                                    cx,
                                    move |email: &String| {
                                        let email = email.clone();
                                        async move {
                                            let result = make_request(
                                                    ApiRequest::<IsEmailValidRequest>::builder()
                                                        .path(Default::default())
                                                        .query(IsEmailValidQuery { email })
                                                        .headers(())
                                                        .body(IsEmailValidRequest)
                                                        .build(),
                                                )
                                                .await;
                                            let IsEmailValidResponse { available } = match result {
                                                Ok(
                                                    ApiSuccessResponse { status_code: _, headers: (), body },
                                                ) => body,
                                                Err(
                                                    ApiErrorResponse {
                                                        status_code: _,
                                                        body: ApiErrorResponseBody { success: _, error, message },
                                                    },
                                                ) => {
                                                    handle_errors(error, message);
                                                    return;
                                                }
                                            };
                                            if !available {
                                                email_error.set("Email is already taken".to_string());
                                                email_error_type.set(NotificationType::Error);
                                            } else {
                                                email_error.set("Email is available".to_string());
                                                email_error_type.set(NotificationType::Success);
                                            }
                                            if email_verifying.get_untracked() {
                                                email_verifying.set(false);
                                            }
                                        }
                                    },
                                );
                                let sign_up_action = create_action(
                                    cx,
                                    move |
                                        (
                                            first_name,
                                            last_name,
                                            username,
                                            email,
                                            password,
                                        ): &(String, String, String, String, String)|
                                    {
                                        let first_name = first_name.clone();
                                        let last_name = last_name.clone();
                                        let username = username.clone();
                                        let recovery_email = email.clone();
                                        let password = password.clone();
                                        async move {
                                            let result = make_request(
                                                    ApiRequest::<CreateAccountRequest>::builder()
                                                        .path(Default::default())
                                                        .query(())
                                                        .headers(())
                                                        .body(CreateAccountRequest {
                                                            first_name,
                                                            last_name,
                                                            username,
                                                            password,
                                                            recovery_method: RecoveryMethod::Email {
                                                                recovery_email,
                                                            },
                                                        })
                                                        .build(),
                                                )
                                                .await;
                                            let CreateAccountResponse = match result {
                                                Ok(
                                                    ApiSuccessResponse { status_code: _, headers: (), body },
                                                ) => body,
                                                Err(
                                                    ApiErrorResponse {
                                                        status_code: _,
                                                        body: ApiErrorResponseBody { success: _, error, message },
                                                    },
                                                ) => {
                                                    handle_errors(error, message);
                                                    return;
                                                }
                                            };
                                        }
                                    },
                                );
                                let check_username_valid = use_debounce_fn_with_arg(
                                    move |username: String| {
                                        if !username.is_empty() {
                                            username_valid_action.dispatch(username);
                                        } else {
                                            username_error.set("".into());
                                        }
                                    },
                                    MaybeSignal::Static(500f64),
                                );
                                let check_email_valid = use_debounce_fn_with_arg(
                                    move |email: String| {
                                        if !email.is_empty() {
                                            email_valid_action.dispatch(email);
                                        } else {
                                            email_error.set("".into());
                                        }
                                    },
                                    MaybeSignal::Static(500f64),
                                );
                                let check_confirm_password_valid = use_debounce_fn_with_arg(
                                    move |confirm_password: String| {
                                        if confirm_password.is_empty() {
                                            confirm_password_error
                                                .set("Please confirm your Password again".into());
                                            return;
                                        }
                                        if password_ref
                                            .get()
                                            .map(|element: HtmlElement<html::Input>| element.value())
                                            .unwrap() != confirm_password
                                        {
                                            confirm_password_error.set("Passwords do not match".into());
                                        }
                                    },
                                    MaybeSignal::Static(500f64),
                                );
                                let handle_login_username = |e: &ev::MouseEvent| {
                                    e.prevent_default();
                                };
                                let handle_sign_up = move |e: ev::SubmitEvent| {
                                    e.prevent_default();
                                    let first_name = first_name_ref
                                        .get()
                                        .map(|value: HtmlElement<html::Input>| value.value())
                                        .unwrap();
                                    let last_name = last_name_ref
                                        .get()
                                        .map(|value: HtmlElement<html::Input>| value.value())
                                        .unwrap();
                                    let username = username_ref
                                        .get()
                                        .map(|value: HtmlElement<html::Input>| value.value())
                                        .unwrap();
                                    let email = email_ref
                                        .get()
                                        .map(|value: HtmlElement<html::Input>| value.value())
                                        .unwrap();
                                    let password = password_ref
                                        .get()
                                        .map(|value: HtmlElement<html::Input>| value.value())
                                        .unwrap();
                                    let confirm_password = confirm_password_ref
                                        .get()
                                        .map(|value: HtmlElement<html::Input>| value.value())
                                        .unwrap();
                                    let mut invalid_data = false;
                                    if first_name.is_empty() {
                                        first_name_error.set("First Name cannot be empty".into());
                                        _ = first_name_ref.get().unwrap().focus();
                                        invalid_data = true;
                                    }
                                    if last_name.is_empty() {
                                        last_name_error.set("Last Name cannot be empty".into());
                                        _ = last_name_ref.get().unwrap().focus();
                                        invalid_data = true;
                                    }
                                    if username.is_empty() {
                                        username_error.set("Username cannot be empty".into());
                                        _ = username_ref.get().unwrap().focus();
                                        invalid_data = true;
                                    }
                                    if email.is_empty() {
                                        email_error.set("Email cannot be empty".into());
                                        _ = email_ref.get().unwrap().focus();
                                        invalid_data = true;
                                    }
                                    if password.is_empty() {
                                        password_error.set("Password cannot be empty".into());
                                        _ = password_ref.get().unwrap().focus();
                                        invalid_data = true;
                                    }
                                    if confirm_password.is_empty() {
                                        confirm_password_error
                                            .set("Please confirm your Password again".into());
                                        _ = confirm_password_ref.get().unwrap().focus();
                                        invalid_data = true;
                                    }
                                    if password != confirm_password {
                                        confirm_password_error.set("Passwords do not match".into());
                                        _ = confirm_password_ref.get().unwrap().focus();
                                        invalid_data = true;
                                    }
                                    if invalid_data {
                                        return;
                                    }
                                    sign_up_action
                                        .dispatch((
                                            first_name,
                                            last_name,
                                            username,
                                            email,
                                            password,
                                        ));
                                };
                                let sign_up_loading = sign_up_action.pending();
                                {
                                    {
                                        let _ = ::leptos::leptos_dom::html::form;
                                        ::leptos::leptos_dom::html::form(cx)
                                            .attr("class", (cx, "box-onboard txt-white fc-fs-fs"))
                                            .on(::leptos::ev::submit, handle_sign_up)
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::div;
                                                    ::leptos::leptos_dom::html::div(cx)
                                                        .attr("class", (cx, "fr-sb-bl mb-lg full-width"))
                                                        .child((
                                                            cx,
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::h1;
                                                                ::leptos::leptos_dom::html::h1(cx)
                                                                    .attr("class", (cx, "txt-primary txt-xl txt-medium"))
                                                                    .child((cx, { "Sign In" }))
                                                            },
                                                        ))
                                                        .child((
                                                            cx,
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::p;
                                                                ::leptos::leptos_dom::html::p(cx)
                                                                    .attr("class", (cx, "txt-white txt-thin fr-fs-fs"))
                                                                    .child("\n\t\t\t\t\tAlready have an account?\n\t\t\t\t\t")
                                                                    .child((
                                                                        cx,
                                                                        ::leptos::component_view(
                                                                            &Link,
                                                                            cx,
                                                                            ::leptos::component_props_builder(&Link)
                                                                                .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                                                .to(
                                                                                    #[allow(unused_braces)]
                                                                                    AppRoute::LoggedOutRoutes(LoggedOutRoutes::Login),
                                                                                )
                                                                                .class(#[allow(unused_braces)] "ml-xs")
                                                                                .children({
                                                                                    Box::new(move |cx| {
                                                                                        {
                                                                                            ::leptos::Fragment::lazy(|| {
                                                                                                ["\n\t\t\t\t\t\tLogin\n\t\t\t\t\t".into_view(cx)].to_vec()
                                                                                            })
                                                                                        }
                                                                                            .with_view_marker("<Link/>-children")
                                                                                    })
                                                                                })
                                                                                .build(),
                                                                        ),
                                                                    ))
                                                            },
                                                        ))
                                                },
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::div;
                                                    ::leptos::leptos_dom::html::div(cx)
                                                        .attr("class", (cx, "fr-ct-fs full-width"))
                                                        .child((
                                                            cx,
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::div;
                                                                ::leptos::leptos_dom::html::div(cx)
                                                                    .attr("class", (cx, "fc-fs-fs grid-col-6 pr-xxs"))
                                                                    .child((
                                                                        cx,
                                                                        ::leptos::component_view(
                                                                            &Input,
                                                                            cx,
                                                                            ::leptos::component_props_builder(&Input)
                                                                                .r#ref(#[allow(unused_braces)] first_name_ref)
                                                                                .class(#[allow(unused_braces)] "py-xs")
                                                                                .r#type(#[allow(unused_braces)] "text")
                                                                                .id(#[allow(unused_braces)] "firstName")
                                                                                .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                                                .placeholder(#[allow(unused_braces)] "First Name")
                                                                                .on_input(
                                                                                    #[allow(unused_braces)]
                                                                                    Box::new(move |_| {
                                                                                        first_name_error.update(|value| value.clear());
                                                                                    }),
                                                                                )
                                                                                .start_icon(
                                                                                    #[allow(unused_braces)]
                                                                                    {
                                                                                        Some(
                                                                                            IconProps::builder()
                                                                                                .icon(IconType::User)
                                                                                                .size(ExtraSmall)
                                                                                                .build(),
                                                                                        )
                                                                                    },
                                                                                )
                                                                                .build(),
                                                                        ),
                                                                    ))
                                                                    .child((
                                                                        cx,
                                                                        {
                                                                            move || {
                                                                                first_name_error
                                                                                    .get()
                                                                                    .some_if_not_empty()
                                                                                    .map(|username| {
                                                                                        {
                                                                                            ::leptos::component_view(
                                                                                                &Alert,
                                                                                                cx,
                                                                                                ::leptos::component_props_builder(&Alert)
                                                                                                    .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                                                    .class(#[allow(unused_braces)] "mt-xs")
                                                                                                    .message(#[allow(unused_braces)] username)
                                                                                                    .build(),
                                                                                            )
                                                                                        }
                                                                                    })
                                                                            }
                                                                        },
                                                                    ))
                                                            },
                                                        ))
                                                        .child((
                                                            cx,
                                                            {
                                                                let _ = ::leptos::leptos_dom::html::div;
                                                                ::leptos::leptos_dom::html::div(cx)
                                                                    .attr("class", (cx, "fc-fs-fs grid-col-6 pl-xxs"))
                                                                    .child((
                                                                        cx,
                                                                        ::leptos::component_view(
                                                                            &Input,
                                                                            cx,
                                                                            ::leptos::component_props_builder(&Input)
                                                                                .r#ref(#[allow(unused_braces)] last_name_ref)
                                                                                .class(#[allow(unused_braces)] "py-xs")
                                                                                .r#type(#[allow(unused_braces)] "text")
                                                                                .id(#[allow(unused_braces)] "lastName")
                                                                                .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                                                .placeholder(#[allow(unused_braces)] "Last Name")
                                                                                .on_input(
                                                                                    #[allow(unused_braces)]
                                                                                    Box::new(move |_| {
                                                                                        last_name_error.update(|value| value.clear());
                                                                                    }),
                                                                                )
                                                                                .start_icon(
                                                                                    #[allow(unused_braces)]
                                                                                    {
                                                                                        Some(
                                                                                            IconProps::builder()
                                                                                                .icon(IconType::User)
                                                                                                .size(ExtraSmall)
                                                                                                .build(),
                                                                                        )
                                                                                    },
                                                                                )
                                                                                .build(),
                                                                        ),
                                                                    ))
                                                                    .child((
                                                                        cx,
                                                                        {
                                                                            move || {
                                                                                last_name_error
                                                                                    .get()
                                                                                    .some_if_not_empty()
                                                                                    .map(|username| {
                                                                                        {
                                                                                            ::leptos::component_view(
                                                                                                &Alert,
                                                                                                cx,
                                                                                                ::leptos::component_props_builder(&Alert)
                                                                                                    .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                                                    .class(#[allow(unused_braces)] "mt-xs")
                                                                                                    .message(#[allow(unused_braces)] username)
                                                                                                    .build(),
                                                                                            )
                                                                                        }
                                                                                    })
                                                                            }
                                                                        },
                                                                    ))
                                                            },
                                                        ))
                                                },
                                            ))
                                            .child((
                                                cx,
                                                ::leptos::component_view(
                                                    &Input,
                                                    cx,
                                                    ::leptos::component_props_builder(&Input)
                                                        .r#ref(#[allow(unused_braces)] username_ref)
                                                        .r#type(#[allow(unused_braces)] "text")
                                                        .class(#[allow(unused_braces)] "mt-lg full-width")
                                                        .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                        .id(#[allow(unused_braces)] "username")
                                                        .value(#[allow(unused_braces)] username_default)
                                                        .loading(#[allow(unused_braces)] username_verifying)
                                                        .on_input(
                                                            #[allow(unused_braces)]
                                                            Box::new(move |ev| {
                                                                let value = event_target_value(&ev);
                                                                if username_verifying.get_untracked() != !value.is_empty() {
                                                                    username_verifying.set(!value.is_empty());
                                                                }
                                                                check_username_valid(value);
                                                                username_error.update(|password| password.clear());
                                                            }),
                                                        )
                                                        .placeholder(#[allow(unused_braces)] "Username")
                                                        .start_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(IconType::User)
                                                                        .size(ExtraSmall)
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .build(),
                                                ),
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::div;
                                                    ::leptos::leptos_dom::html::div(cx)
                                                        .attr("class", (cx, "fr-fs-ct"))
                                                        .child((
                                                            cx,
                                                            {
                                                                move || {
                                                                    let username_error = username_error.get();
                                                                    let username_error_type = username_error_type.get();
                                                                    username_error
                                                                        .some_if_not_empty()
                                                                        .map(|username| {
                                                                            {
                                                                                ::leptos::component_view(
                                                                                    &Alert,
                                                                                    cx,
                                                                                    ::leptos::component_props_builder(&Alert)
                                                                                        .r#type(#[allow(unused_braces)] username_error_type)
                                                                                        .class(#[allow(unused_braces)] "mt-xs")
                                                                                        .message(#[allow(unused_braces)] username)
                                                                                        .build(),
                                                                                )
                                                                            }
                                                                        })
                                                                }
                                                            },
                                                        ))
                                                        .child((
                                                            cx,
                                                            {
                                                                move || {
                                                                    show_login_username_button
                                                                        .with(|value| {
                                                                            value
                                                                                .then(move || {
                                                                                    ::leptos::component_view(
                                                                                        &Link,
                                                                                        cx,
                                                                                        ::leptos::component_props_builder(&Link)
                                                                                            .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                                                            .on_click(
                                                                                                #[allow(unused_braces)]
                                                                                                Box::new(handle_login_username),
                                                                                            )
                                                                                            .class(
                                                                                                #[allow(unused_braces)]
                                                                                                "ml-sm txt-underline txt-medium mt-xs",
                                                                                            )
                                                                                            .children({
                                                                                                Box::new(move |cx| {
                                                                                                    {
                                                                                                        ::leptos::Fragment::lazy(|| {
                                                                                                            [
                                                                                                                "\n\t\t\t\t\t\t\t\tLogin as ".into_view(cx),
                                                                                                                { move || { username_ref.get().unwrap().value() } }
                                                                                                                    .into_view(cx),
                                                                                                                "?\n\t\t\t\t\t\t\t".into_view(cx),
                                                                                                            ]
                                                                                                                .to_vec()
                                                                                                        })
                                                                                                    }
                                                                                                        .with_view_marker("<Link/>-children")
                                                                                                })
                                                                                            })
                                                                                            .build(),
                                                                                    )
                                                                                })
                                                                        })
                                                                }
                                                            },
                                                        ))
                                                },
                                            ))
                                            .child((
                                                cx,
                                                ::leptos::component_view(
                                                    &Input,
                                                    cx,
                                                    ::leptos::component_props_builder(&Input)
                                                        .r#ref(#[allow(unused_braces)] email_ref)
                                                        .id(#[allow(unused_braces)] "email")
                                                        .class(#[allow(unused_braces)] "mt-lg full-width")
                                                        .r#type(#[allow(unused_braces)] "email")
                                                        .disabled(#[allow(unused_braces)] sign_up_loading)
                                                        .loading(#[allow(unused_braces)] email_verifying)
                                                        .value(#[allow(unused_braces)] email_default)
                                                        .on_input(
                                                            #[allow(unused_braces)]
                                                            Box::new(move |ev| {
                                                                let value = event_target_value(&ev);
                                                                if email_verifying.get_untracked() != !value.is_empty() {
                                                                    email_verifying.set(!value.is_empty());
                                                                }
                                                                check_email_valid(value);
                                                                email_error.update(|password| password.clear());
                                                            }),
                                                        )
                                                        .placeholder(#[allow(unused_braces)] "patron@email.com")
                                                        .start_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(IconType::Mail)
                                                                        .size(ExtraSmall)
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .build(),
                                                ),
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    move || {
                                                        email_error
                                                            .get()
                                                            .some_if_not_empty()
                                                            .map(|email| {
                                                                {
                                                                    ::leptos::component_view(
                                                                        &Alert,
                                                                        cx,
                                                                        ::leptos::component_props_builder(&Alert)
                                                                            .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                            .class(#[allow(unused_braces)] "mt-xs")
                                                                            .message(#[allow(unused_braces)] email)
                                                                            .build(),
                                                                    )
                                                                }
                                                            })
                                                    }
                                                },
                                            ))
                                            .child((
                                                cx,
                                                ::leptos::component_view(
                                                    &Input,
                                                    cx,
                                                    ::leptos::component_props_builder(&Input)
                                                        .r#ref(#[allow(unused_braces)] password_ref)
                                                        .class(#[allow(unused_braces)] "mt-md full-width")
                                                        .r#type(
                                                            #[allow(unused_braces)]
                                                            {
                                                                MaybeSignal::derive(
                                                                    cx,
                                                                    move || {
                                                                        if show_password.get() {
                                                                            "text".to_owned()
                                                                        } else {
                                                                            "password".to_owned()
                                                                        }
                                                                    },
                                                                )
                                                            },
                                                        )
                                                        .on_input(
                                                            #[allow(unused_braces)]
                                                            Box::new(move |ev| {
                                                                let value = event_target_value(&ev);
                                                                if !value.is_empty() {
                                                                    check_confirm_password_valid(value);
                                                                }
                                                                password_error.update(|password| password.clear());
                                                            }),
                                                        )
                                                        .id(#[allow(unused_braces)] "password")
                                                        .placeholder(#[allow(unused_braces)] "Password")
                                                        .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                        .start_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(IconType::Shield)
                                                                        .size(ExtraSmall)
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .end_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(
                                                                            MaybeSignal::derive(
                                                                                cx,
                                                                                move || {
                                                                                    if show_password.get() {
                                                                                        IconType::Eye
                                                                                    } else {
                                                                                        IconType::EyeOff
                                                                                    }
                                                                                },
                                                                            ),
                                                                        )
                                                                        .color(Grey)
                                                                        .size(ExtraSmall)
                                                                        .on_click(
                                                                            Rc::new(move |_| {
                                                                                show_password.update(|value| *value = !*value);
                                                                            }),
                                                                        )
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .build(),
                                                ),
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    move || {
                                                        password_error
                                                            .get()
                                                            .some_if_not_empty()
                                                            .map(|password| {
                                                                {
                                                                    ::leptos::component_view(
                                                                        &Alert,
                                                                        cx,
                                                                        ::leptos::component_props_builder(&Alert)
                                                                            .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                            .class(#[allow(unused_braces)] "mt-xs")
                                                                            .message(#[allow(unused_braces)] { password })
                                                                            .build(),
                                                                    )
                                                                }
                                                            })
                                                    }
                                                },
                                            ))
                                            .child((
                                                cx,
                                                ::leptos::component_view(
                                                    &Input,
                                                    cx,
                                                    ::leptos::component_props_builder(&Input)
                                                        .r#ref(#[allow(unused_braces)] confirm_password_ref)
                                                        .class(#[allow(unused_braces)] "mt-md full-width")
                                                        .r#type(
                                                            #[allow(unused_braces)]
                                                            {
                                                                MaybeSignal::derive(
                                                                    cx,
                                                                    move || {
                                                                        if show_password.get() {
                                                                            "text".to_owned()
                                                                        } else {
                                                                            "password".to_owned()
                                                                        }
                                                                    },
                                                                )
                                                            },
                                                        )
                                                        .on_input(
                                                            #[allow(unused_braces)]
                                                            Box::new(move |_| {
                                                                confirm_password_error.update(|password| password.clear());
                                                            }),
                                                        )
                                                        .id(#[allow(unused_braces)] "password")
                                                        .placeholder(#[allow(unused_braces)] "Confirm Password")
                                                        .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                        .start_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(IconType::Shield)
                                                                        .size(ExtraSmall)
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .end_icon(
                                                            #[allow(unused_braces)]
                                                            {
                                                                Some(
                                                                    IconProps::builder()
                                                                        .icon(
                                                                            MaybeSignal::derive(
                                                                                cx,
                                                                                move || {
                                                                                    if show_password.get() {
                                                                                        IconType::Eye
                                                                                    } else {
                                                                                        IconType::EyeOff
                                                                                    }
                                                                                },
                                                                            ),
                                                                        )
                                                                        .color(Grey)
                                                                        .size(ExtraSmall)
                                                                        .on_click(
                                                                            Rc::new(move |_| {
                                                                                show_password.update(|value| *value = !*value);
                                                                            }),
                                                                        )
                                                                        .build(),
                                                                )
                                                            },
                                                        )
                                                        .build(),
                                                ),
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    move || {
                                                        confirm_password_error
                                                            .get()
                                                            .some_if_not_empty()
                                                            .map(|password| {
                                                                {
                                                                    ::leptos::component_view(
                                                                        &Alert,
                                                                        cx,
                                                                        ::leptos::component_props_builder(&Alert)
                                                                            .r#type(#[allow(unused_braces)] NotificationType::Error)
                                                                            .class(#[allow(unused_braces)] "mt-xs")
                                                                            .message(#[allow(unused_braces)] { password })
                                                                            .build(),
                                                                    )
                                                                }
                                                            })
                                                    }
                                                },
                                            ))
                                            .child((
                                                cx,
                                                {
                                                    let _ = ::leptos::leptos_dom::html::div;
                                                    ::leptos::leptos_dom::html::div(cx)
                                                        .attr("class", (cx, "fr-fe-ct full-width pt-md"))
                                                        .child((
                                                            cx,
                                                            ::leptos::component_view(
                                                                &Link,
                                                                cx,
                                                                ::leptos::component_props_builder(&Link)
                                                                    .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                                    .class(#[allow(unused_braces)] "btn mr-xs txt-thin txt-xs")
                                                                    .children({
                                                                        Box::new(move |cx| {
                                                                            {
                                                                                ::leptos::Fragment::lazy(|| {
                                                                                    ["\n\t\t\t\t\tALREADY HAVE AN OTP?\n\t\t\t\t".into_view(cx)]
                                                                                        .to_vec()
                                                                                })
                                                                            }
                                                                                .with_view_marker("<Link/>-children")
                                                                        })
                                                                    })
                                                                    .build(),
                                                            ),
                                                        ))
                                                        .child((
                                                            cx,
                                                            {
                                                                move || {
                                                                    if sign_up_loading.get() {
                                                                        {
                                                                            ::leptos::component_view(
                                                                                &Spinner,
                                                                                cx,
                                                                                ::leptos::component_props_builder(&Spinner)
                                                                                    .class(#[allow(unused_braces)] "mx-xl")
                                                                                    .build(),
                                                                            )
                                                                        }
                                                                    } else {
                                                                        {
                                                                            ::leptos::component_view(
                                                                                &Link,
                                                                                cx,
                                                                                ::leptos::component_props_builder(&Link)
                                                                                    .disabled(#[allow(unused_braces)] { sign_up_loading })
                                                                                    .r#type(#[allow(unused_braces)] "submit")
                                                                                    .variant(#[allow(unused_braces)] LinkVariant::Contained)
                                                                                    .children({
                                                                                        Box::new(move |cx| {
                                                                                            {
                                                                                                ::leptos::Fragment::lazy(|| {
                                                                                                    ["\n\t\t\t\t\t\t\t\tNEXT\n\t\t\t\t\t\t\t".into_view(cx)]
                                                                                                        .to_vec()
                                                                                                })
                                                                                            }
                                                                                                .with_view_marker("<Link/>-children")
                                                                                        })
                                                                                    })
                                                                                    .build(),
                                                                            )
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                        ))
                                                },
                                            ))
                                    }
                                }
                            }
                            let span = ::leptos::leptos_dom::tracing::Span::current();
                            ::leptos::leptos_dom::Component::new(
                                "SignUp",
                                move |cx| {
                                    #[cfg(debug_assertions)]
                                    let _guard = span.entered();
                                    __SignUp(cx)
                                },
                            )
                        }
                    }
                }
            }
        }
        pub use self::{confirm_sign_up::*, login::*, sign_up::*};
    }
    pub use self::auth::*;
}
mod utils {
    mod app_route {
        use axum_extra::routing::TypedPath;
        use leptos_router::{
            use_params as use_router_params, use_query as use_router_query, Params, Route,
        };
        use serde::{de::DeserializeOwned, Serialize};
        use crate::prelude::*;
        /// A trait for types that can be used as a route in the application.
        /// It also provides the path as well as the query parameters for the route.
        pub trait TypedRoute: TypedPath + Params + DeserializeOwned + Serialize + PartialEq + Default + Clone + 'static {
            /// The query parameters for the route.
            type Query: Params
                + DeserializeOwned
                + Serialize
                + PartialEq
                + Clone
                + Default
                + 'static;
        }
        /// A wrapper around a type that implements `TypedRoute` to provide the query
        /// parameters for the route through the context.
        struct Query<T>(T);
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Query<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Query", &&self.0)
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for Query<T> {
            #[inline]
            fn clone(&self) -> Query<T> {
                Query(::core::clone::Clone::clone(&self.0))
            }
        }
        /// A wrapper around a type that implements `TypedRoute` to provide the path
        /// parameters for the route through the context.
        struct UrlParams<T>(T);
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for UrlParams<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UrlParams",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for UrlParams<T> {
            #[inline]
            fn clone(&self) -> UrlParams<T> {
                UrlParams(::core::clone::Clone::clone(&self.0))
            }
        }
        ///Props for the [`AppRoute`] component.
        ///
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **_route**: [`R`]
        ///    -  The path of the route
        ///- **view**: [`F`]
        ///    -  The view for the route
        ///- **children**: [`Children`]
        ///    -  The children of the route
        #[builder(doc)]
        pub struct AppRouteProps<R, F, V>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            /// The path of the route
            #[builder(setter(doc = "**_route**: [`R`]\n\n The path of the route"))]
            #[builder()]
            pub _route: R,
            /// The view for the route
            #[builder(setter(doc = "**view**: [`F`]\n\n The view for the route"))]
            #[builder()]
            pub view: F,
            /// The children of the route
            #[builder(
                setter(doc = "**children**: [`Children`]\n\n The children of the route")
            )]
            #[builder()]
            #[allow(missing_docs)]
            pub children: Children,
        }
        impl<R, F, V> AppRouteProps<R, F, V>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            /**
                Create a builder for building `AppRouteProps`.
                On the builder, call `._route(...)`, `.view(...)`, `.children(...)` to set the values of the fields.
                Finally, call `.build()` to create the instance of `AppRouteProps`.
                */
            #[allow(dead_code, clippy::default_trait_access)]
            pub fn builder() -> AppRoutePropsBuilder<R, F, V, ((), (), ())> {
                AppRoutePropsBuilder {
                    fields: ((), (), ()),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        /**Builder for [`AppRouteProps`] instances.

See [`AppRouteProps::builder()`] for more info.*/
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub struct AppRoutePropsBuilder<R, F, V, TypedBuilderFields = ((), (), ())> {
            fields: TypedBuilderFields,
            phantom: (
                ::core::marker::PhantomData<R>,
                ::core::marker::PhantomData<F>,
                ::core::marker::PhantomData<V>,
            ),
        }
        impl<R, F, V, TypedBuilderFields> Clone
        for AppRoutePropsBuilder<R, F, V, TypedBuilderFields>
        where
            TypedBuilderFields: Clone,
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[allow(clippy::default_trait_access)]
            fn clone(&self) -> Self {
                Self {
                    fields: self.fields.clone(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait AppRoutePropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> AppRoutePropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> AppRoutePropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            R,
            F,
            V,
            __view,
            __children,
        > AppRoutePropsBuilder<R, F, V, ((), __view, __children)>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[doc = "**_route**: [`R`]\n\n The path of the route"]
            pub fn _route(
                self,
                _route: R,
            ) -> AppRoutePropsBuilder<R, F, V, ((R,), __view, __children)> {
                let _route = (_route,);
                let (_, view, children) = self.fields;
                AppRoutePropsBuilder {
                    fields: (_route, view, children),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AppRoutePropsBuilder_Error_Repeated_field__route {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            R,
            F,
            V,
            __view,
            __children,
        > AppRoutePropsBuilder<R, F, V, ((R,), __view, __children)>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[deprecated(note = "Repeated field _route")]
            pub fn _route(
                self,
                _: AppRoutePropsBuilder_Error_Repeated_field__route,
            ) -> AppRoutePropsBuilder<R, F, V, ((R,), __view, __children)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            R,
            F,
            V,
            ___route,
            __children,
        > AppRoutePropsBuilder<R, F, V, (___route, (), __children)>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[doc = "**view**: [`F`]\n\n The view for the route"]
            pub fn view(
                self,
                view: F,
            ) -> AppRoutePropsBuilder<R, F, V, (___route, (F,), __children)> {
                let view = (view,);
                let (_route, _, children) = self.fields;
                AppRoutePropsBuilder {
                    fields: (_route, view, children),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AppRoutePropsBuilder_Error_Repeated_field_view {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            R,
            F,
            V,
            ___route,
            __children,
        > AppRoutePropsBuilder<R, F, V, (___route, (F,), __children)>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[deprecated(note = "Repeated field view")]
            pub fn view(
                self,
                _: AppRoutePropsBuilder_Error_Repeated_field_view,
            ) -> AppRoutePropsBuilder<R, F, V, (___route, (F,), __children)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            R,
            F,
            V,
            ___route,
            __view,
        > AppRoutePropsBuilder<R, F, V, (___route, __view, ())>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[doc = "**children**: [`Children`]\n\n The children of the route"]
            pub fn children(
                self,
                children: Children,
            ) -> AppRoutePropsBuilder<R, F, V, (___route, __view, (Children,))> {
                let children = (children,);
                let (_route, view, _) = self.fields;
                AppRoutePropsBuilder {
                    fields: (_route, view, children),
                    phantom: self.phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AppRoutePropsBuilder_Error_Repeated_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<
            R,
            F,
            V,
            ___route,
            __view,
        > AppRoutePropsBuilder<R, F, V, (___route, __view, (Children,))>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[deprecated(note = "Repeated field children")]
            pub fn children(
                self,
                _: AppRoutePropsBuilder_Error_Repeated_field_children,
            ) -> AppRoutePropsBuilder<R, F, V, (___route, __view, (Children,))> {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AppRoutePropsBuilder_Error_Missing_required_field__route {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<
            R,
            F,
            V,
            __view,
            __children,
        > AppRoutePropsBuilder<R, F, V, ((), __view, __children)>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[deprecated(note = "Missing required field _route")]
            pub fn build(
                self,
                _: AppRoutePropsBuilder_Error_Missing_required_field__route,
            ) -> AppRouteProps<R, F, V> {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AppRoutePropsBuilder_Error_Missing_required_field_view {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<R, F, V, __children> AppRoutePropsBuilder<R, F, V, ((R,), (), __children)>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[deprecated(note = "Missing required field view")]
            pub fn build(
                self,
                _: AppRoutePropsBuilder_Error_Missing_required_field_view,
            ) -> AppRouteProps<R, F, V> {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum AppRoutePropsBuilder_Error_Missing_required_field_children {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<R, F, V> AppRoutePropsBuilder<R, F, V, ((R,), (F,), ())>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            #[deprecated(note = "Missing required field children")]
            pub fn build(
                self,
                _: AppRoutePropsBuilder_Error_Missing_required_field_children,
            ) -> AppRouteProps<R, F, V> {
                { ::std::rt::begin_panic("explicit panic") };
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<R, F, V> AppRoutePropsBuilder<R, F, V, ((R,), (F,), (Children,))>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            ///Finalise the builder and create its [`AppRouteProps`] instance
            #[allow(clippy::default_trait_access)]
            pub fn build(self) -> AppRouteProps<R, F, V> {
                let (_route, view, children) = self.fields;
                let _route = _route.0;
                let view = view.0;
                let children = children.0;
                AppRouteProps {
                    _route,
                    view,
                    children,
                }
                    .into()
            }
        }
        impl<R, F, V> ::leptos::Props for AppRouteProps<R, F, V>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            type Builder = AppRoutePropsBuilder<R, F, V>;
            fn builder() -> Self::Builder {
                AppRouteProps::builder()
            }
        }
        impl<R, F, V> ::leptos::IntoView for AppRouteProps<R, F, V>
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            fn into_view(self, cx: ::leptos::Scope) -> ::leptos::View {
                AppRoute(cx, self).into_view(cx)
            }
        }
        ///# Required Props
        ///- **cx**: [`Scope`]
        ///    -  The scope of the component
        ///- **_route**: [`R`]
        ///    -  The path of the route
        ///- **view**: [`F`]
        ///    -  The view for the route
        ///- **children**: [`Children`]
        ///    -  The children of the route
        #[allow(non_snake_case, clippy::too_many_arguments)]
        #[allow(clippy::let_with_type_underscore)]
        pub fn AppRoute<R, F, V>(
            #[allow(unused_variables)]
            cx: ::leptos::Scope,
            props: AppRouteProps<R, F, V>,
        ) -> impl IntoView
        where
            R: TypedRoute,
            F: Fn(Scope) -> V + 'static,
            V: IntoView,
        {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "<AppRoute />",
                                    "frontend::utils::app_route",
                                    tracing::Level::INFO,
                                    Some("frontend/src/utils/app_route.rs"),
                                    Some(43u32),
                                    Some("frontend::utils::app_route"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                CALLSITE.metadata(),
                            );
                            if (match tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        span.record_all(
                                            &{ CALLSITE.metadata().fields().value_set(&[]) },
                                        );
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore
                    )]
                    if false {
                        let __tracing_attr_fake_return: _ = {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "this is just for type inference, and is unreachable code",
                                    ),
                                ),
                            );
                        };
                        return __tracing_attr_fake_return;
                    }
                    {
                        #[allow(clippy::needless_lifetimes)]
                        pub fn __AppRoute<R, F, V>(
                            cx: Scope,
                            _route: R,
                            view: F,
                            children: Children,
                        ) -> impl IntoView
                        where
                            R: TypedRoute,
                            F: Fn(Scope) -> V + 'static,
                            V: IntoView,
                        {
                            {
                                ::leptos::component_view(
                                    &Route,
                                    cx,
                                    ::leptos::component_props_builder(&Route)
                                        .view(
                                            #[allow(unused_braces)]
                                            {
                                                move |cx| {
                                                    let query: R::Query = use_router_query(cx)
                                                        .get_untracked()
                                                        .unwrap_or_default();
                                                    let params: R = use_router_params(cx)
                                                        .get_untracked()
                                                        .unwrap_or_default();
                                                    provide_context(cx, Query(query));
                                                    provide_context(cx, UrlParams(params));
                                                    view(cx)
                                                }
                                            },
                                        )
                                        .path(#[allow(unused_braces)] { <R as TypedPath>::PATH })
                                        .children({
                                            Box::new(move |cx| {
                                                {
                                                    ::leptos::Fragment::lazy(|| {
                                                        [{ children(cx) }.into_view(cx)].to_vec()
                                                    })
                                                }
                                                    .with_view_marker("<Route/>-children")
                                            })
                                        })
                                        .build(),
                                )
                            }
                        }
                        let AppRouteProps { _route, view, children } = props;
                        let span = ::leptos::leptos_dom::tracing::Span::current();
                        ::leptos::leptos_dom::Component::new(
                            "AppRoute",
                            move |cx| {
                                #[cfg(debug_assertions)]
                                let _guard = span.entered();
                                {
                                    use ::leptos::leptos_dom::tracing_property::{
                                        Match, SerializeMatch, DefaultMatch,
                                    };
                                    let mut props = String::from('[');
                                    let prop = (&&Match {
                                        name: "_route",
                                        value: std::cell::Cell::new(Some(&_route)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "view",
                                        value: std::cell::Cell::new(Some(&view)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    let prop = (&&Match {
                                        name: "children",
                                        value: std::cell::Cell::new(Some(&children)),
                                    })
                                        .spez();
                                    props
                                        .push_str(
                                            &{
                                                let res = ::alloc::fmt::format(format_args!("{0},", prop));
                                                res
                                            },
                                        );
                                    props.pop();
                                    props.push(']');
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "leptos_dom::tracing_props",
                                                    "frontend::utils::app_route",
                                                    ::leptos::leptos_dom::tracing::Level::TRACE,
                                                    Some("frontend/src/utils/app_route.rs"),
                                                    Some(43u32),
                                                    Some("frontend::utils::app_route"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["props"],
                                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::SPAN,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::leptos::leptos_dom::tracing::Level::TRACE
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::leptos::leptos_dom::tracing::Level::TRACE
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                interest = CALLSITE.interest();
                                                !interest.is_never()
                                            }
                                            && ::tracing::__macro_support::__is_enabled(
                                                CALLSITE.metadata(),
                                                interest,
                                            )
                                        {
                                            let meta = CALLSITE.metadata();
                                            ::tracing::Span::new(
                                                meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = meta.fields().iter();
                                                    meta.fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(&props as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        } else {
                                            let span = ::tracing::__macro_support::__disabled_span(
                                                CALLSITE.metadata(),
                                            );
                                            if (match ::leptos::leptos_dom::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        span.record_all(
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                                CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                                Some(&props as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        );
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                            span
                                        }
                                    };
                                };
                                __AppRoute(cx, _route, view, children)
                            },
                        )
                    }
                }
            }
        }
        /// Get the query parameters for the current route.
        pub fn use_query<R>(cx: Scope) -> R::Query
        where
            R: TypedRoute,
        {
            expect_context::<Query<R::Query>>(cx).0
        }
        /// Get the path parameters for the current route.
        pub fn use_params<R>(cx: Scope) -> R
        where
            R: TypedRoute,
        {
            expect_context::<UrlParams<R>>(cx).0
        }
    }
    mod color {
        use std::fmt::{self, Display, Formatter};
        /// All colors supported by CSS class names in the app.
        pub enum PatrColor {
            /// Primary yellow color. This is the default.
            #[default]
            Primary,
            /// Secondary purple color.
            Secondary,
            /// White color.
            White,
            /// Black color.
            Black,
            /// Grey color.
            Grey,
            /// Success green color.
            Success,
            /// Warning orange color.
            Warning,
            /// Error red color.
            Error,
            /// Info blue color.
            Info,
            /// Disabled color.
            Disabled,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PatrColor {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        PatrColor::Primary => "Primary",
                        PatrColor::Secondary => "Secondary",
                        PatrColor::White => "White",
                        PatrColor::Black => "Black",
                        PatrColor::Grey => "Grey",
                        PatrColor::Success => "Success",
                        PatrColor::Warning => "Warning",
                        PatrColor::Error => "Error",
                        PatrColor::Info => "Info",
                        PatrColor::Disabled => "Disabled",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PatrColor {
            #[inline]
            fn clone(&self) -> PatrColor {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for PatrColor {}
        #[automatically_derived]
        impl ::core::default::Default for PatrColor {
            #[inline]
            fn default() -> PatrColor {
                Self::Primary
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PatrColor {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PatrColor {
            #[inline]
            fn eq(&self, other: &PatrColor) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for PatrColor {}
        #[automatically_derived]
        impl ::core::cmp::Eq for PatrColor {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for PatrColor {
            #[inline]
            fn partial_cmp(
                &self,
                other: &PatrColor,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for PatrColor {
            #[inline]
            fn cmp(&self, other: &PatrColor) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
            }
        }
        impl Display for PatrColor {
            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                f.write_fmt(format_args!("{0}", self.as_css_name()))
            }
        }
        impl PatrColor {
            /// Returns the CSS name of the color.
            pub const fn as_css_name(self) -> &'static str {
                match self {
                    Primary => "primary",
                    Secondary => "secondary",
                    White => "white",
                    Black => "black",
                    Grey => "grey",
                    Success => "success",
                    Warning => "warning",
                    Error => "error",
                    Info => "info",
                    Disabled => "disabled",
                }
            }
            /// Returns the text color corresponding to this color.
            pub const fn as_text_color(self) -> TextColor {
                TextColor(self)
            }
        }
        pub use PatrColor::*;
        /// All text colors supported by CSS class names in the app.
        pub struct TextColor(pub PatrColor);
        #[automatically_derived]
        impl ::core::fmt::Debug for TextColor {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "TextColor",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TextColor {
            #[inline]
            fn clone(&self) -> TextColor {
                let _: ::core::clone::AssertParamIsClone<PatrColor>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TextColor {}
        #[automatically_derived]
        impl ::core::default::Default for TextColor {
            #[inline]
            fn default() -> TextColor {
                TextColor(::core::default::Default::default())
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TextColor {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TextColor {
            #[inline]
            fn eq(&self, other: &TextColor) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for TextColor {}
        #[automatically_derived]
        impl ::core::cmp::Eq for TextColor {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<PatrColor>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TextColor {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TextColor,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TextColor {
            #[inline]
            fn cmp(&self, other: &TextColor) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        impl Display for TextColor {
            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                f.write_fmt(format_args!("{0}", self.as_css_color()))
            }
        }
        impl TextColor {
            /// Returns the CSS name of the text color.
            pub const fn as_css_color(self) -> &'static str {
                match self.0 {
                    Primary => "txt-primary",
                    Secondary => "txt-secondary",
                    White => "txt-white",
                    Black => "txt-black",
                    Grey => "txt-grey",
                    Success => "txt-success",
                    Warning => "txt-warning",
                    Error => "txt-error",
                    Info => "txt-info",
                    Disabled => "txt-disabled",
                }
            }
        }
    }
    mod ext {
        /// Extension traits for string. Used for rendering components when the string
        /// is not empty.
        pub trait StringExt {
            /// Returns `Some(self)` if the string is not empty, `None` otherwise.
            fn some_if_not_empty(self) -> Option<String>;
        }
        impl StringExt for String {
            fn some_if_not_empty(self) -> Option<String> {
                if self.is_empty() { None } else { Some(self) }
            }
        }
    }
    mod fetch {
        use std::{str::FromStr, sync::OnceLock};
        use reqwest::Client;
        use serde::{de::DeserializeOwned, Serialize};
        use url::Url;
        use models::{
            prelude::*, utils::{constants, False, Headers},
            ApiErrorResponse, ApiErrorResponseBody, ApiResponseBody,
            ApiSuccessResponseBody,
        };
        static REQUEST_CLIENT: OnceLock<Client> = OnceLock::new();
        /// Makes a request to the API. Requires an ApiRequest object for a specific
        /// endpoint, and returns the response corresponding to that endpoint
        /// TODO implement automatically refreshing tokens
        pub async fn make_request<E>(
            ApiRequest { path, query, headers, body }: ApiRequest<E>,
        ) -> Result<ApiSuccessResponse<E>, ApiErrorResponse>
        where
            E: ApiEndpoint,
            E::ResponseBody: DeserializeOwned + Serialize,
            E::RequestBody: DeserializeOwned + Serialize,
        {
            let body = serde_json::to_value(&body).unwrap();
            let builder = REQUEST_CLIENT
                .get_or_init(initialize_client)
                .request(
                    E::METHOD,
                    Url::from_str(constants::API_BASE_URL)
                        .unwrap()
                        .join(path.to_string().as_str())
                        .unwrap(),
                )
                .query(&query)
                .headers(headers.to_header_map());
            let response = if body.is_null() { builder } else { builder.json(&body) }
                .send()
                .await;
            let response = match response {
                Ok(response) => response,
                Err(error) => {
                    return Err(ApiErrorResponse {
                        status_code: reqwest::StatusCode::INTERNAL_SERVER_ERROR,
                        body: ApiErrorResponseBody {
                            success: False,
                            error: ErrorType::server_error(error.to_string()),
                            message: error.to_string(),
                        },
                    });
                }
            };
            let status_code = response.status();
            let Some(headers) = E::ResponseHeaders::from_header_map(response.headers())
            else {
                return Err(ApiErrorResponse {
                    status_code: reqwest::StatusCode::INTERNAL_SERVER_ERROR,
                    body: ApiErrorResponseBody {
                        success: False,
                        error: ErrorType::server_error("invalid headers"),
                        message: "invalid headers".to_string(),
                    },
                });
            };
            match response.json::<ApiResponseBody<E::ResponseBody>>().await {
                Ok(
                    ApiResponseBody::Success(
                        ApiSuccessResponseBody { success: _, response: body },
                    ),
                ) => {
                    Ok(ApiSuccessResponse {
                        status_code,
                        headers,
                        body,
                    })
                }
                Ok(ApiResponseBody::Error(error)) => {
                    Err(ApiErrorResponse {
                        status_code,
                        body: error,
                    })
                }
                Err(error) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event frontend/src/utils/fetch.rs:94",
                                    "frontend::utils::fetch",
                                    ::tracing::Level::ERROR,
                                    Some("frontend/src/utils/fetch.rs"),
                                    Some(94u32),
                                    Some("frontend::utils::fetch"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&format_args!("{0}", error.to_string()) as &dyn Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = CALLSITE.metadata().fields().iter();
                                                        CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                        Some(&format_args!("{0}", error.to_string()) as &dyn Value),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    Err(ApiErrorResponse {
                        status_code: reqwest::StatusCode::INTERNAL_SERVER_ERROR,
                        body: ApiErrorResponseBody {
                            success: False,
                            error: ErrorType::server_error(error.to_string()),
                            message: error.to_string(),
                        },
                    })
                }
            }
        }
        fn initialize_client() -> Client {
            Client::builder().build().expect("failed to initialize client")
        }
    }
    mod notification_type {
        use super::PatrColor;
        /// All notification types supported by CSS class names in the app.
        pub enum NotificationType {
            /// Success notification
            Success,
            /// Warning notification
            Warning,
            /// Error notification
            Error,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NotificationType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        NotificationType::Success => "Success",
                        NotificationType::Warning => "Warning",
                        NotificationType::Error => "Error",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NotificationType {
            #[inline]
            fn clone(&self) -> NotificationType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NotificationType {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NotificationType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NotificationType {
            #[inline]
            fn eq(&self, other: &NotificationType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for NotificationType {}
        #[automatically_derived]
        impl ::core::cmp::Eq for NotificationType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for NotificationType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &NotificationType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for NotificationType {
            #[inline]
            fn cmp(&self, other: &NotificationType) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
            }
        }
        impl NotificationType {
            /// Returns the CSS name of the notification.
            pub const fn as_css_name(&self) -> &'static str {
                match self {
                    Success => "success",
                    Warning => "warning",
                    Error => "error",
                }
            }
            /// Returns the color of the notification.
            pub const fn as_patr_color(&self) -> PatrColor {
                match self {
                    Success => PatrColor::Success,
                    Warning => PatrColor::Warning,
                    Error => PatrColor::Error,
                }
            }
        }
        /// Converts a notification type into a color.
        impl From<NotificationType> for PatrColor {
            fn from(val: NotificationType) -> Self {
                val.as_patr_color()
            }
        }
        pub use NotificationType::*;
    }
    mod routes {
        use std::fmt::Display;
        /// The routes that the app can take
        pub enum AppRoute {
            /// The empty route. Mostly used for mounting other components. Must never
            /// be used as a route.
            #[default]
            Empty,
            /// The routes that can be taken when the user is logged in
            LoggedInRoutes(LoggedInRoutes),
            /// The routes that can be taken when the user is logged out
            LoggedOutRoutes(LoggedOutRoutes),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AppRoute {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    AppRoute::Empty => ::core::fmt::Formatter::write_str(f, "Empty"),
                    AppRoute::LoggedInRoutes(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "LoggedInRoutes",
                            &__self_0,
                        )
                    }
                    AppRoute::LoggedOutRoutes(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "LoggedOutRoutes",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AppRoute {
            #[inline]
            fn clone(&self) -> AppRoute {
                let _: ::core::clone::AssertParamIsClone<LoggedInRoutes>;
                let _: ::core::clone::AssertParamIsClone<LoggedOutRoutes>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for AppRoute {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AppRoute {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AppRoute {
            #[inline]
            fn eq(&self, other: &AppRoute) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            AppRoute::LoggedInRoutes(__self_0),
                            AppRoute::LoggedInRoutes(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            AppRoute::LoggedOutRoutes(__self_0),
                            AppRoute::LoggedOutRoutes(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for AppRoute {}
        #[automatically_derived]
        impl ::core::cmp::Eq for AppRoute {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<LoggedInRoutes>;
                let _: ::core::cmp::AssertParamIsEq<LoggedOutRoutes>;
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AppRoute {
            #[inline]
            fn default() -> AppRoute {
                Self::Empty
            }
        }
        impl AppRoute {
            /// Returns true if the route is empty, and false otherwise.
            pub fn is_empty(&self) -> bool {
                match self {
                    Self::Empty => true,
                    _ => false,
                }
            }
        }
        /// The routes that can be taken when the user is logged in
        pub enum LoggedOutRoutes {
            /// The login page
            Login,
            /// The sign up page
            SignUp,
            /// The forgot password page
            ForgotPassword,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LoggedOutRoutes {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        LoggedOutRoutes::Login => "Login",
                        LoggedOutRoutes::SignUp => "SignUp",
                        LoggedOutRoutes::ForgotPassword => "ForgotPassword",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LoggedOutRoutes {
            #[inline]
            fn clone(&self) -> LoggedOutRoutes {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LoggedOutRoutes {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LoggedOutRoutes {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LoggedOutRoutes {
            #[inline]
            fn eq(&self, other: &LoggedOutRoutes) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for LoggedOutRoutes {}
        #[automatically_derived]
        impl ::core::cmp::Eq for LoggedOutRoutes {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        /// The routes that can be taken when the user is logged out
        pub enum LoggedInRoutes {
            /// The home page
            Home,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LoggedInRoutes {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "Home")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LoggedInRoutes {
            #[inline]
            fn clone(&self) -> LoggedInRoutes {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LoggedInRoutes {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LoggedInRoutes {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LoggedInRoutes {
            #[inline]
            fn eq(&self, other: &LoggedInRoutes) -> bool {
                true
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for LoggedInRoutes {}
        #[automatically_derived]
        impl ::core::cmp::Eq for LoggedInRoutes {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl Display for AppRoute {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    Self::Empty => f.write_fmt(format_args!("")),
                    Self::LoggedInRoutes(logged_in_routes) => {
                        f.write_fmt(format_args!("{0}", logged_in_routes))
                    }
                    Self::LoggedOutRoutes(logged_out_routes) => {
                        f.write_fmt(format_args!("{0}", logged_out_routes))
                    }
                }
            }
        }
        impl Display for LoggedInRoutes {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(
                    format_args!(
                        "{0}",
                        match self {
                            Self::Home => "/home",
                        },
                    ),
                )
            }
        }
        impl Display for LoggedOutRoutes {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(
                    format_args!(
                        "{0}",
                        match self {
                            Self::Login => "/login",
                            Self::SignUp => "/sign-up",
                            Self::ForgotPassword => "/forgot-password",
                        },
                    ),
                )
            }
        }
    }
    mod size {
        use std::fmt::{self, Display, Formatter};
        /// All sizes supported by CSS class names in the app.
        pub enum Size {
            /// XXL
            ExtraExtraLarge,
            /// XL
            ExtraLarge,
            /// LG
            Large,
            /// MD - This is the default.
            #[default]
            Medium,
            /// SM
            Small,
            /// XS
            ExtraSmall,
            /// XXS
            ExtraExtraSmall,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Size {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Size::ExtraExtraLarge => "ExtraExtraLarge",
                        Size::ExtraLarge => "ExtraLarge",
                        Size::Large => "Large",
                        Size::Medium => "Medium",
                        Size::Small => "Small",
                        Size::ExtraSmall => "ExtraSmall",
                        Size::ExtraExtraSmall => "ExtraExtraSmall",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Size {
            #[inline]
            fn clone(&self) -> Size {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Size {}
        #[automatically_derived]
        impl ::core::default::Default for Size {
            #[inline]
            fn default() -> Size {
                Self::Medium
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Size {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Size {
            #[inline]
            fn eq(&self, other: &Size) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Size {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Size {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Size {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Size,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Size {
            #[inline]
            fn cmp(&self, other: &Size) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
            }
        }
        impl Display for Size {
            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                f.write_fmt(format_args!("{0}", self.as_css_name()))
            }
        }
        impl Size {
            /// Returns the CSS name of the size.
            pub const fn as_css_name(&self) -> &'static str {
                match self {
                    ExtraExtraLarge => "xxl",
                    ExtraLarge => "xl",
                    Large => "lg",
                    Medium => "md",
                    Small => "sm",
                    ExtraSmall => "xs",
                    ExtraExtraSmall => "xxs",
                }
            }
        }
        pub use Size::*;
    }
    mod state {
        use models::utils::Uuid;
        use serde::{Deserialize, Serialize};
        /// The data that will be stored in the user's browser storage.
        #[serde(rename_all = "camelCase", tag = "type")]
        pub enum AppStorage {
            /// Storage when the user is logged in. Contains the user's ID, access
            /// token, refresh token, and default workspace.
            #[serde(rename_all = "camelCase")]
            LoggedIn {
                /// The user's userId.
                user_id: Uuid,
                /// The user's access token.
                access_token: String,
                /// The user's refresh token.
                refresh_token: String,
                /// The user's default workspace, if they have any
                default_workspace: Option<Uuid>,
            },
            /// Storage when the user is logged out.
            #[serde(rename_all = "camelCase")]
            #[default]
            LoggedOut,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AppStorage {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    AppStorage::LoggedIn {
                        user_id: __self_0,
                        access_token: __self_1,
                        refresh_token: __self_2,
                        default_workspace: __self_3,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "LoggedIn",
                            "user_id",
                            __self_0,
                            "access_token",
                            __self_1,
                            "refresh_token",
                            __self_2,
                            "default_workspace",
                            &__self_3,
                        )
                    }
                    AppStorage::LoggedOut => {
                        ::core::fmt::Formatter::write_str(f, "LoggedOut")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AppStorage {
            #[inline]
            fn clone(&self) -> AppStorage {
                match self {
                    AppStorage::LoggedIn {
                        user_id: __self_0,
                        access_token: __self_1,
                        refresh_token: __self_2,
                        default_workspace: __self_3,
                    } => {
                        AppStorage::LoggedIn {
                            user_id: ::core::clone::Clone::clone(__self_0),
                            access_token: ::core::clone::Clone::clone(__self_1),
                            refresh_token: ::core::clone::Clone::clone(__self_2),
                            default_workspace: ::core::clone::Clone::clone(__self_3),
                        }
                    }
                    AppStorage::LoggedOut => AppStorage::LoggedOut,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AppStorage {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AppStorage {
            #[inline]
            fn eq(&self, other: &AppStorage) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            AppStorage::LoggedIn {
                                user_id: __self_0,
                                access_token: __self_1,
                                refresh_token: __self_2,
                                default_workspace: __self_3,
                            },
                            AppStorage::LoggedIn {
                                user_id: __arg1_0,
                                access_token: __arg1_1,
                                refresh_token: __arg1_2,
                                default_workspace: __arg1_3,
                            },
                        ) => {
                            *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                                && *__self_2 == *__arg1_2 && *__self_3 == *__arg1_3
                        }
                        _ => true,
                    }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AppStorage {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        AppStorage::LoggedIn {
                            ref user_id,
                            ref access_token,
                            ref refresh_token,
                            ref default_workspace,
                        } => {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "AppStorage",
                                0 + 1 + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "type",
                                "loggedIn",
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "userId",
                                user_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "accessToken",
                                access_token,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "refreshToken",
                                refresh_token,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "defaultWorkspace",
                                default_workspace,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                        AppStorage::LoggedOut => {
                            let mut __struct = _serde::Serializer::serialize_struct(
                                __serializer,
                                "AppStorage",
                                1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __struct,
                                "type",
                                "loggedOut",
                            )?;
                            _serde::ser::SerializeStruct::end(__struct)
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AppStorage {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "loggedIn" => _serde::__private::Ok(__Field::__field0),
                                "loggedOut" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"loggedIn" => _serde::__private::Ok(__Field::__field0),
                                b"loggedOut" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["loggedIn", "loggedOut"];
                    let (__tag, __content) = _serde::Deserializer::deserialize_any(
                        __deserializer,
                        _serde::__private::de::TaggedContentVisitor::<
                            __Field,
                        >::new("type", "internally tagged enum AppStorage"),
                    )?;
                    let __deserializer = _serde::__private::de::ContentDeserializer::<
                        __D::Error,
                    >::new(__content);
                    match __tag {
                        __Field::__field0 => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "userId" => _serde::__private::Ok(__Field::__field0),
                                        "accessToken" => _serde::__private::Ok(__Field::__field1),
                                        "refreshToken" => _serde::__private::Ok(__Field::__field2),
                                        "defaultWorkspace" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"userId" => _serde::__private::Ok(__Field::__field0),
                                        b"accessToken" => _serde::__private::Ok(__Field::__field1),
                                        b"refreshToken" => _serde::__private::Ok(__Field::__field2),
                                        b"defaultWorkspace" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<AppStorage>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = AppStorage;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant AppStorage::LoggedIn",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        Uuid,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct variant AppStorage::LoggedIn with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct variant AppStorage::LoggedIn with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct variant AppStorage::LoggedIn with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        Option<Uuid>,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct variant AppStorage::LoggedIn with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(AppStorage::LoggedIn {
                                        user_id: __field0,
                                        access_token: __field1,
                                        refresh_token: __field2,
                                        default_workspace: __field3,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<Uuid> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<Option<Uuid>> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("userId"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "accessToken",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "refreshToken",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "defaultWorkspace",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        Option<Uuid>,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("userId")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("accessToken")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("refreshToken")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("defaultWorkspace")?
                                        }
                                    };
                                    _serde::__private::Ok(AppStorage::LoggedIn {
                                        user_id: __field0,
                                        access_token: __field1,
                                        refresh_token: __field2,
                                        default_workspace: __field3,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "userId",
                                "accessToken",
                                "refreshToken",
                                "defaultWorkspace",
                            ];
                            _serde::Deserializer::deserialize_any(
                                __deserializer,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<AppStorage>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        __Field::__field1 => {
                            _serde::Deserializer::deserialize_any(
                                __deserializer,
                                _serde::__private::de::InternallyTaggedUnitVisitor::new(
                                    "AppStorage",
                                    "LoggedOut",
                                ),
                            )?;
                            _serde::__private::Ok(AppStorage::LoggedOut)
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for AppStorage {
            #[inline]
            fn default() -> AppStorage {
                Self::LoggedOut
            }
        }
        impl AppStorage {
            /// Returns true if the user is logged in, and false otherwise.
            pub fn is_logged_in(&self) -> bool {
                match self {
                    AppStorage::LoggedIn { .. } => true,
                    _ => false,
                }
            }
        }
    }
    mod variant {
        use std::fmt::{self, Display, Formatter};
        /// The variants of the secondary color.
        pub enum SecondaryColorVariant {
            /// The light variant. This is the default.
            #[default]
            Light,
            /// The medium variant.
            Medium,
            /// The dark variant.
            Dark,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SecondaryColorVariant {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        SecondaryColorVariant::Light => "Light",
                        SecondaryColorVariant::Medium => "Medium",
                        SecondaryColorVariant::Dark => "Dark",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SecondaryColorVariant {
            #[inline]
            fn clone(&self) -> SecondaryColorVariant {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SecondaryColorVariant {}
        #[automatically_derived]
        impl ::core::default::Default for SecondaryColorVariant {
            #[inline]
            fn default() -> SecondaryColorVariant {
                Self::Light
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SecondaryColorVariant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SecondaryColorVariant {
            #[inline]
            fn eq(&self, other: &SecondaryColorVariant) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for SecondaryColorVariant {}
        #[automatically_derived]
        impl ::core::cmp::Eq for SecondaryColorVariant {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for SecondaryColorVariant {
            #[inline]
            fn partial_cmp(
                &self,
                other: &SecondaryColorVariant,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for SecondaryColorVariant {
            #[inline]
            fn cmp(&self, other: &SecondaryColorVariant) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
            }
        }
        impl Display for SecondaryColorVariant {
            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                f.write_fmt(format_args!("{0}", self.as_css_name()))
            }
        }
        impl SecondaryColorVariant {
            /// Returns the CSS name of the variant.
            pub const fn as_css_name(self) -> &'static str {
                match self {
                    Light => "light",
                    Medium => "medium",
                    Dark => "dark",
                }
            }
        }
        pub use SecondaryColorVariant::*;
    }
    pub use self::{
        app_route::*, color::*, ext::*, fetch::*, notification_type::*, routes::*,
        size::*, state::*, variant::*,
    };
    /// All the constants used in the application.
    /// Constants are used to avoid hardcoding values, since that might introduce
    /// typos.
    pub mod constants {
        /// Path to the Feather icon sprite.
        pub const FEATHER_IMG: &str = "/icons/sprite/feather-sprite.svg";
    }
}
use app::App;
use wasm_bindgen::JsCast;
#[allow(dead_code)]
/// The main hydrate function. Called when the application starts to hydrate
/// from the server side.
pub fn hydrate() {
    wasm_logger::init(wasm_logger::Config::default());
    if true {
        console_error_panic_hook::set_once();
    }
    let root_element = document()
        .get_element_by_id("root")
        .expect("unable to find root element");
    mount_to(
        root_element.unchecked_into(),
        |cx| {
            {
                ::leptos::component_view(
                    &PortalProvider,
                    cx,
                    ::leptos::component_props_builder(&PortalProvider)
                        .children({
                            Box::new(move |cx| {
                                {
                                    ::leptos::Fragment::lazy(|| {
                                        [
                                            ::leptos::component_view(
                                                    &App,
                                                    cx,
                                                    ::leptos::component_props_builder(&App).build(),
                                                )
                                                .into_view(cx),
                                            ::leptos::component_view(
                                                    &PortalOutput,
                                                    cx,
                                                    ::leptos::component_props_builder(&PortalOutput)
                                                        .id(#[allow(unused_braces)] { PortalId })
                                                        .build(),
                                                )
                                                .into_view(cx),
                                        ]
                                            .to_vec()
                                    })
                                }
                                    .with_view_marker("<PortalProvider/>-children")
                            })
                        })
                        .build(),
                )
            }
        },
    );
}
#[automatically_derived]
const _: () = {
    /// The main hydrate function. Called when the application starts to hydrate
    /// from the server side.
    pub unsafe extern "C" fn __wasm_bindgen_generated_hydrate() -> <() as wasm_bindgen::convert::ReturnWasmAbi>::Abi {
        let _ret = {
            let _ret = hydrate();
            _ret
        };
        <() as wasm_bindgen::convert::ReturnWasmAbi>::return_abi(_ret)
    }
};
