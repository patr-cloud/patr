use std::{
	fmt::{self, Display, Formatter},
	future::Future,
};

use clap::ValueEnum;
use models::ApiErrorResponse;
use serde_json::Value;

use crate::prelude::*;

/// The output of a given command
#[derive(Debug, Clone)]
pub struct CommandOutput {
	/// The table / text version of a command's output
	pub text: String,
	/// The JSON output of a command
	pub json: Value,
}

impl CommandOutput {
	/// Create a new result with the given value
	pub fn into_result(self) -> Result<CommandOutput, ApiErrorResponse> {
		Ok(self)
	}
}

/// A trait that defines the functionality of a command.
/// Every command must implement this trait.
pub trait CommandExecutor {
	/// Execute the command with the arguments provided
	fn execute(
		self,
		global_args: GlobalArgs,
		state: AppState,
	) -> impl Future<Output = Result<CommandOutput, ApiErrorResponse>>;
}

/// A list of all possible output types generated by the CLI.
#[derive(Debug, Copy, Clone, Default, ValueEnum)]
#[value(rename_all = "kebab-case")]
pub enum OutputType {
	/// A plain text output.
	#[default]
	Text,
	/// A JSON output, minified.
	Json,
	/// A JSON output, pretty printed.
	PrettyJson,
}

impl Display for OutputType {
	fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
		match self {
			OutputType::Text => write!(f, "text"),
			OutputType::Json => write!(f, "json"),
			OutputType::PrettyJson => write!(f, "pretty-json"),
		}
	}
}
